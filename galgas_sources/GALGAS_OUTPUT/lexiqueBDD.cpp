//---------------------------------------------------------------------------*
//                                                                           *
//                          File 'lexiqueBDD.cpp'                            *
//         Generated by version GALGAS_BETA_VERSION (LL(1) grammar)          *
//                      march 21th, 2007, at 14h49'42"                       *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1

#include "bdd/C_BDD.h"


//--- END OF USER ZONE 1

//---------------------------------------------------------------------------*

#include "version_libpm.h"
#if LIBPM_VERSION != THE_LIBPM_VERSION
  #error "This file has been compiled with a version of GALGAS different than the version of libpm"
#endif

//---------------------------------------------------------------------------*

#include <ctype.h>
#include <string.h>

#include "utilities/MF_MemoryControl.h"
#include "lexiqueBDD.h"

#ifndef DO_NOT_GENERATE_CHECKINGS
  #define LINE_AND_SOURCE_FILE sourceText ()->sourceFileName ().cString (), lineNumber ()
  #define COMMA_LINE_AND_SOURCE_FILE , LINE_AND_SOURCE_FILE
#else
  #define LINE_AND_SOURCE_FILE
  #define COMMA_LINE_AND_SOURCE_FILE
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                               Constructor                                 *
//                                                                           *
//---------------------------------------------------------------------------*

lexiqueBDD::
lexiqueBDD (C_galgas_io * inParametersPtr,
                const C_String & inSourceFileName
                COMMA_LOCATION_ARGS)
: C_Lexique (inParametersPtr, inSourceFileName COMMA_THERE) {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        Lexical error message list                         *
//                                                                           *
//---------------------------------------------------------------------------*

//--- Message 0
static const char * gErrorMessage_0 = "number too large" ;
//--- Message 1
static const char * gErrorMessage_1 = "the character is not a decimal digit" ;
//--- Message 2
static const char * gErrorMessage_2 = "the character string does not end with \"" ;

//---------------------------------------------------------------------------*
//                                                                           *
//                          Syntax error messages                            *
//                                                                           *
//---------------------------------------------------------------------------*

//--- Syntax error message for terminal '$nombre$' :
static const char * gSyntaxErrorMessage_nombre = "a decimal integer" ;

//--- Syntax error message for terminal '$id$' :
static const char * gSyntaxErrorMessage_id = "an identifier" ;

//--- Syntax error message for terminal '$string$' :
static const char * gSyntaxErrorMessage_string = "a character string (between \" and \")" ;

//--- Syntax error message for terminal '$comp$' :
static const char * gSyntaxErrorMessage_comp = "the '=', '<>', '<=', '<', '>' or '>' delimitor" ;

//--- Syntax error message for terminal '$($' :
static const char * gSyntaxErrorMessage__28 = "the '(' delimiter" ;

//--- Syntax error message for terminal '$)$' :
static const char * gSyntaxErrorMessage__29 = "the ')' delimiter" ;

//--- Syntax error message for terminal '${$' :
static const char * gSyntaxErrorMessage__7B = "the '{' delimiter" ;

//--- Syntax error message for terminal '$}$' :
static const char * gSyntaxErrorMessage__7D = "the '}' delimiter" ;

//--- Syntax error message for terminal '$[$' :
static const char * gSyntaxErrorMessage__5B = "the '[' delimiter" ;

//--- Syntax error message for terminal '$]$' :
static const char * gSyntaxErrorMessage__5D = "the ']' delimiter" ;

//--- Syntax error message for terminal '$:=$' :
static const char * gSyntaxErrorMessage__3A_3D = "the ':=' delimiter" ;

//--- Syntax error message for terminal '$:$' :
static const char * gSyntaxErrorMessage__3A = "the ':' delimiter" ;

//--- Syntax error message for terminal '$.$' :
static const char * gSyntaxErrorMessage__2E = "the '.' delimiter" ;

//--- Syntax error message for terminal '$..$' :
static const char * gSyntaxErrorMessage__2E_2E = "the '..' delimiter" ;

//--- Syntax error message for terminal '$+=$' :
static const char * gSyntaxErrorMessage__2B_3D = "the '+=' delimiter" ;

//--- Syntax error message for terminal '$-=$' :
static const char * gSyntaxErrorMessage__2D_3D = "the '-=' delimiter" ;

//--- Syntax error message for terminal '$->$' :
static const char * gSyntaxErrorMessage__2D_3E = "the '->' delimiter" ;

//--- Syntax error message for terminal '$&$' :
static const char * gSyntaxErrorMessage__26 = "the '&' delimiter" ;

//--- Syntax error message for terminal '$|$' :
static const char * gSyntaxErrorMessage__7C = "the '|' delimiter" ;

//--- Syntax error message for terminal '$~$' :
static const char * gSyntaxErrorMessage__7E = "the '~' delimiter" ;

//--- Syntax error message for terminal '$,$' :
static const char * gSyntaxErrorMessage__2C = "the ',' delimiter" ;

//--- Syntax error message for terminal '$?$' :
static const char * gSyntaxErrorMessage__3F = "the '\?' delimiter" ;

//--- Syntax error message for terminal '$!$' :
static const char * gSyntaxErrorMessage__21 = "the '!' delimiter" ;

//--- Syntax error message for terminal '$;$' :
static const char * gSyntaxErrorMessage__3B = "the ';' delimiter" ;

//--- Syntax error message for terminal '$#$' :
static const char * gSyntaxErrorMessage__23 = "the '#' delimiter" ;

//--- Syntax error message for terminal '$ite_cache$' :
static const char * gSyntaxErrorMessage_ite_5Fcache = "the 'ite_cache' keyword" ;

//--- Syntax error message for terminal '$and_cache$' :
static const char * gSyntaxErrorMessage_and_5Fcache = "the 'and_cache' keyword" ;

//--- Syntax error message for terminal '$use_and$' :
static const char * gSyntaxErrorMessage_use_5Fand = "the 'use_and' keyword" ;

//--- Syntax error message for terminal '$use_ite$' :
static const char * gSyntaxErrorMessage_use_5Fite = "the 'use_ite' keyword" ;

//--- Syntax error message for terminal '$use_and_ite$' :
static const char * gSyntaxErrorMessage_use_5Fand_5Fite = "the 'use_and_ite' keyword" ;

//--- Syntax error message for terminal '$map$' :
static const char * gSyntaxErrorMessage_map = "the 'map' keyword" ;

//--- Syntax error message for terminal '$bdd$' :
static const char * gSyntaxErrorMessage_bdd = "the 'bdd' keyword" ;

//--- Syntax error message for terminal '$domain$' :
static const char * gSyntaxErrorMessage_domain = "the 'domain' keyword" ;

//--- Syntax error message for terminal '$bool$' :
static const char * gSyntaxErrorMessage_bool = "the 'bool' keyword" ;

//--- Syntax error message for terminal '$record$' :
static const char * gSyntaxErrorMessage_record = "the 'record' keyword" ;

//--- Syntax error message for terminal '$true$' :
static const char * gSyntaxErrorMessage_true = "the 'true' keyword" ;

//--- Syntax error message for terminal '$false$' :
static const char * gSyntaxErrorMessage_false = "the 'false' keyword" ;

//--- Syntax error message for terminal '$display$' :
static const char * gSyntaxErrorMessage_display = "the 'display' keyword" ;

//--- Syntax error message for terminal '$include$' :
static const char * gSyntaxErrorMessage_include = "the 'include' keyword" ;

//--- Syntax error message for terminal '$dump$' :
static const char * gSyntaxErrorMessage_dump = "the 'dump' keyword" ;

//--- Syntax error message for terminal '$verify$' :
static const char * gSyntaxErrorMessage_verify = "the 'verify' keyword" ;

//--- Syntax error message for terminal '$end$' :
static const char * gSyntaxErrorMessage_end = "the 'end' keyword" ;

//--- Syntax error message for terminal '$if$' :
static const char * gSyntaxErrorMessage_if = "the 'if' keyword" ;

//--- Syntax error message for terminal '$then$' :
static const char * gSyntaxErrorMessage_then = "the 'then' keyword" ;

//--- Syntax error message for terminal '$else$' :
static const char * gSyntaxErrorMessage_else = "the 'else' keyword" ;

//---------------------------------------------------------------------------*
//                                                                           *
//                appendTerminalMessageToSyntaxErrorMessage                  *
//                                                                           *
//---------------------------------------------------------------------------*

void lexiqueBDD::
appendTerminalMessageToSyntaxErrorMessage (const sint16 inTerminalIndex,
                                           C_String & outSyntaxErrorMessage) {
  static const char * syntaxErrorMessageArray [46] = {"end of source",
       gSyntaxErrorMessage_nombre,
       gSyntaxErrorMessage_id,
       gSyntaxErrorMessage_string,
       gSyntaxErrorMessage_comp,
       gSyntaxErrorMessage__28,
       gSyntaxErrorMessage__29,
       gSyntaxErrorMessage__7B,
       gSyntaxErrorMessage__7D,
       gSyntaxErrorMessage__5B,
       gSyntaxErrorMessage__5D,
       gSyntaxErrorMessage__3A_3D,
       gSyntaxErrorMessage__3A,
       gSyntaxErrorMessage__2E,
       gSyntaxErrorMessage__2E_2E,
       gSyntaxErrorMessage__2B_3D,
       gSyntaxErrorMessage__2D_3D,
       gSyntaxErrorMessage__2D_3E,
       gSyntaxErrorMessage__26,
       gSyntaxErrorMessage__7C,
       gSyntaxErrorMessage__7E,
       gSyntaxErrorMessage__2C,
       gSyntaxErrorMessage__3F,
       gSyntaxErrorMessage__21,
       gSyntaxErrorMessage__3B,
       gSyntaxErrorMessage__23,
       gSyntaxErrorMessage_ite_5Fcache,
       gSyntaxErrorMessage_and_5Fcache,
       gSyntaxErrorMessage_use_5Fand,
       gSyntaxErrorMessage_use_5Fite,
       gSyntaxErrorMessage_use_5Fand_5Fite,
       gSyntaxErrorMessage_map,
       gSyntaxErrorMessage_bdd,
       gSyntaxErrorMessage_domain,
       gSyntaxErrorMessage_bool,
       gSyntaxErrorMessage_record,
       gSyntaxErrorMessage_true,
       gSyntaxErrorMessage_false,
       gSyntaxErrorMessage_display,
       gSyntaxErrorMessage_include,
       gSyntaxErrorMessage_dump,
       gSyntaxErrorMessage_verify,
       gSyntaxErrorMessage_end,
       gSyntaxErrorMessage_if,
       gSyntaxErrorMessage_then,
       gSyntaxErrorMessage_else} ;
  outSyntaxErrorMessage << syntaxErrorMessageArray [inTerminalIndex] ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   Key words table 'delimiteursKerBDD'                     *
//                                                                           *
//---------------------------------------------------------------------------*

const sint16 lexiqueBDD::lexiqueBDD_table_size_delimiteursKerBDD = 21 ;

const C_lexique_table_entry lexiqueBDD::lexiqueBDD_table_for_delimiteursKerBDD [21] = {
  C_lexique_table_entry ("!", 1, lexiqueBDD_1__21),
  C_lexique_table_entry ("#", 1, lexiqueBDD_1__23),
  C_lexique_table_entry ("&", 1, lexiqueBDD_1__26),
  C_lexique_table_entry ("(", 1, lexiqueBDD_1__28),
  C_lexique_table_entry (")", 1, lexiqueBDD_1__29),
  C_lexique_table_entry (",", 1, lexiqueBDD_1__2C),
  C_lexique_table_entry (".", 1, lexiqueBDD_1__2E),
  C_lexique_table_entry (":", 1, lexiqueBDD_1__3A),
  C_lexique_table_entry (";", 1, lexiqueBDD_1__3B),
  C_lexique_table_entry ("\?", 1, lexiqueBDD_1__3F),
  C_lexique_table_entry ("[", 1, lexiqueBDD_1__5B),
  C_lexique_table_entry ("]", 1, lexiqueBDD_1__5D),
  C_lexique_table_entry ("{", 1, lexiqueBDD_1__7B),
  C_lexique_table_entry ("|", 1, lexiqueBDD_1__7C),
  C_lexique_table_entry ("}", 1, lexiqueBDD_1__7D),
  C_lexique_table_entry ("~", 1, lexiqueBDD_1__7E),
  C_lexique_table_entry ("+=", 2, lexiqueBDD_1__2B_3D),
  C_lexique_table_entry ("-=", 2, lexiqueBDD_1__2D_3D),
  C_lexique_table_entry ("->", 2, lexiqueBDD_1__2D_3E),
  C_lexique_table_entry ("..", 2, lexiqueBDD_1__2E_2E),
  C_lexique_table_entry (":=", 2, lexiqueBDD_1__3A_3D)
} ;

sint16 lexiqueBDD::search_into_delimiteursKerBDD (const C_String & inSearchedString) {
  return searchInList (inSearchedString, lexiqueBDD_table_for_delimiteursKerBDD, lexiqueBDD_table_size_delimiteursKerBDD) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   Key words table 'motsReservesKerBDD'                    *
//                                                                           *
//---------------------------------------------------------------------------*

const sint16 lexiqueBDD::lexiqueBDD_table_size_motsReservesKerBDD = 20 ;

const C_lexique_table_entry lexiqueBDD::lexiqueBDD_table_for_motsReservesKerBDD [20] = {
  C_lexique_table_entry ("if", 2, lexiqueBDD_1_if),
  C_lexique_table_entry ("bdd", 3, lexiqueBDD_1_bdd),
  C_lexique_table_entry ("end", 3, lexiqueBDD_1_end),
  C_lexique_table_entry ("map", 3, lexiqueBDD_1_map),
  C_lexique_table_entry ("bool", 4, lexiqueBDD_1_bool),
  C_lexique_table_entry ("dump", 4, lexiqueBDD_1_dump),
  C_lexique_table_entry ("else", 4, lexiqueBDD_1_else),
  C_lexique_table_entry ("then", 4, lexiqueBDD_1_then),
  C_lexique_table_entry ("true", 4, lexiqueBDD_1_true),
  C_lexique_table_entry ("false", 5, lexiqueBDD_1_false),
  C_lexique_table_entry ("domain", 6, lexiqueBDD_1_domain),
  C_lexique_table_entry ("record", 6, lexiqueBDD_1_record),
  C_lexique_table_entry ("verify", 6, lexiqueBDD_1_verify),
  C_lexique_table_entry ("display", 7, lexiqueBDD_1_display),
  C_lexique_table_entry ("include", 7, lexiqueBDD_1_include),
  C_lexique_table_entry ("use_and", 7, lexiqueBDD_1_use_5Fand),
  C_lexique_table_entry ("use_ite", 7, lexiqueBDD_1_use_5Fite),
  C_lexique_table_entry ("and_cache", 9, lexiqueBDD_1_and_5Fcache),
  C_lexique_table_entry ("ite_cache", 9, lexiqueBDD_1_ite_5Fcache),
  C_lexique_table_entry ("use_and_ite", 11, lexiqueBDD_1_use_5Fand_5Fite)
} ;

sint16 lexiqueBDD::search_into_motsReservesKerBDD (const C_String & inSearchedString) {
  return searchInList (inSearchedString, lexiqueBDD_table_for_motsReservesKerBDD, lexiqueBDD_table_size_motsReservesKerBDD) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          getCurrentTokenString                            *
//                                                                           *
//---------------------------------------------------------------------------*

C_String lexiqueBDD::
getCurrentTokenString (const cToken * inTokenPtr) const {
  cTokenFor_lexiqueBDD * _p = (cTokenFor_lexiqueBDD *) inTokenPtr ;
  C_String s ;
  if (_p == NULL) {
    s << "$$" ;
  }else{
    switch (_p->_mTokenCode) {
    case  lexiqueBDD_1_:
      s << "$$" ;
      break ;
    case  lexiqueBDD_1_nombre:
      s << '$'
        << "nombre"
        << '$' ;
    s << ' ' << _p->att_valeur ;
      break;
    case  lexiqueBDD_1_id:
      s << '$'
        << "id"
        << '$' ;
    s << ' ' ;
    s.writeCstringConstant (_p->att_token) ;
      break;
    case  lexiqueBDD_1_string:
      s << '$'
        << "string"
        << '$' ;
    s << ' ' ;
    s.writeCstringConstant (_p->att_token) ;
      break;
    case  lexiqueBDD_1_comp:
      s << '$'
        << "comp"
        << '$' ;
    s << ' ' << _p->att_valeur ;
      break;
    case  lexiqueBDD_1__28:
      s << '$'
        << "("
        << '$' ;
      break;
    case  lexiqueBDD_1__29:
      s << '$'
        << ")"
        << '$' ;
      break;
    case  lexiqueBDD_1__7B:
      s << '$'
        << "{"
        << '$' ;
      break;
    case  lexiqueBDD_1__7D:
      s << '$'
        << "}"
        << '$' ;
      break;
    case  lexiqueBDD_1__5B:
      s << '$'
        << "["
        << '$' ;
      break;
    case  lexiqueBDD_1__5D:
      s << '$'
        << "]"
        << '$' ;
      break;
    case  lexiqueBDD_1__3A_3D:
      s << '$'
        << ":="
        << '$' ;
      break;
    case  lexiqueBDD_1__3A:
      s << '$'
        << ":"
        << '$' ;
      break;
    case  lexiqueBDD_1__2E:
      s << '$'
        << "."
        << '$' ;
      break;
    case  lexiqueBDD_1__2E_2E:
      s << '$'
        << ".."
        << '$' ;
      break;
    case  lexiqueBDD_1__2B_3D:
      s << '$'
        << "+="
        << '$' ;
      break;
    case  lexiqueBDD_1__2D_3D:
      s << '$'
        << "-="
        << '$' ;
      break;
    case  lexiqueBDD_1__2D_3E:
      s << '$'
        << "->"
        << '$' ;
      break;
    case  lexiqueBDD_1__26:
      s << '$'
        << "&"
        << '$' ;
      break;
    case  lexiqueBDD_1__7C:
      s << '$'
        << "|"
        << '$' ;
      break;
    case  lexiqueBDD_1__7E:
      s << '$'
        << "~"
        << '$' ;
      break;
    case  lexiqueBDD_1__2C:
      s << '$'
        << ","
        << '$' ;
      break;
    case  lexiqueBDD_1__3F:
      s << '$'
        << "\?"
        << '$' ;
      break;
    case  lexiqueBDD_1__21:
      s << '$'
        << "!"
        << '$' ;
      break;
    case  lexiqueBDD_1__3B:
      s << '$'
        << ";"
        << '$' ;
      break;
    case  lexiqueBDD_1__23:
      s << '$'
        << "#"
        << '$' ;
      break;
    case  lexiqueBDD_1_ite_5Fcache:
      s << '$'
        << "ite_cache"
        << '$' ;
      break;
    case  lexiqueBDD_1_and_5Fcache:
      s << '$'
        << "and_cache"
        << '$' ;
      break;
    case  lexiqueBDD_1_use_5Fand:
      s << '$'
        << "use_and"
        << '$' ;
      break;
    case  lexiqueBDD_1_use_5Fite:
      s << '$'
        << "use_ite"
        << '$' ;
      break;
    case  lexiqueBDD_1_use_5Fand_5Fite:
      s << '$'
        << "use_and_ite"
        << '$' ;
      break;
    case  lexiqueBDD_1_map:
      s << '$'
        << "map"
        << '$' ;
      break;
    case  lexiqueBDD_1_bdd:
      s << '$'
        << "bdd"
        << '$' ;
      break;
    case  lexiqueBDD_1_domain:
      s << '$'
        << "domain"
        << '$' ;
      break;
    case  lexiqueBDD_1_bool:
      s << '$'
        << "bool"
        << '$' ;
      break;
    case  lexiqueBDD_1_record:
      s << '$'
        << "record"
        << '$' ;
      break;
    case  lexiqueBDD_1_true:
      s << '$'
        << "true"
        << '$' ;
      break;
    case  lexiqueBDD_1_false:
      s << '$'
        << "false"
        << '$' ;
      break;
    case  lexiqueBDD_1_display:
      s << '$'
        << "display"
        << '$' ;
      break;
    case  lexiqueBDD_1_include:
      s << '$'
        << "include"
        << '$' ;
      break;
    case  lexiqueBDD_1_dump:
      s << '$'
        << "dump"
        << '$' ;
      break;
    case  lexiqueBDD_1_verify:
      s << '$'
        << "verify"
        << '$' ;
      break;
    case  lexiqueBDD_1_end:
      s << '$'
        << "end"
        << '$' ;
      break;
    case  lexiqueBDD_1_if:
      s << '$'
        << "if"
        << '$' ;
      break;
    case  lexiqueBDD_1_then:
      s << '$'
        << "then"
        << '$' ;
      break;
    case  lexiqueBDD_1_else:
      s << '$'
        << "else"
        << '$' ;
      break;
    default:
      break ;
    }
  }
  return s ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                            parseLexicalToken                              *
//                                                                           *
//---------------------------------------------------------------------------*

bool lexiqueBDD::
parseLexicalToken (void) {
  cTokenFor_lexiqueBDD _token ;
  bool loop_ = true ;
  _token._mTokenCode = -1 ;
  while (_token._mTokenCode < 0) {
    _token.att_idf.clear () ;
    _token.att_token.clear () ;
    _token.att_valeur = 0 ;
    mCurrentTokenStartLocation = location () ;
    try{
      if (testForInputChar ('a', 'z') ||
          testForInputChar ('A', 'Z')) {
        do {
          scanner_action_enterCharacterIntoString (_token.att_idf, scanner_action_toLower (previousChar ())) ;
          scanner_action_enterCharacterIntoString (_token.att_token, previousChar ()) ;
          if (testForInputChar ('a', 'z') ||
              testForInputChar ('A', 'Z') ||
              testForInputChar ('_') ||
              testForInputChar ('0', '9')) {
          }else{
            loop_ = false ;
          }
        }while (loop_) ;
        loop_ = true ;
        _token._mTokenCode = search_into_motsReservesKerBDD (_token.att_idf) ;
        if (_token._mTokenCode == -1) {
          _token._mTokenCode = lexiqueBDD_1_id ;
        }
        _enterToken (_token) ;
      }else if (testForInputChar ('\"')) {
        do {
          if (testForInputChar (' ') ||
              testForInputChar ('!') ||
              testForInputChar ('#', '\xFF')) {
            scanner_action_enterCharacterIntoString (_token.att_token, previousChar ()) ;
          }else{
            loop_ = false ;
          }
        }while (loop_) ;
        loop_ = true ;
        if (testForInputChar ('\"')) {
          _token._mTokenCode = lexiqueBDD_1_string ;
          _enterToken (_token) ;
        }else{
          lexicalError (gErrorMessage_2 COMMA_LINE_AND_SOURCE_FILE) ;
        }
      }else if (testForInputChar ('0', '9')) {
        scanner_action_enterDigitIntoUlong (_token.att_valeur, previousChar (), gErrorMessage_0, gErrorMessage_1) ;
        do {
          if (testForInputChar ('0', '9')) {
            scanner_action_enterDigitIntoUlong (_token.att_valeur, previousChar (), gErrorMessage_0, gErrorMessage_1) ;
          }else if (testForInputChar ('_')) {
          }else{
            loop_ = false ;
          }
        }while (loop_) ;
        loop_ = true ;
        _token._mTokenCode = lexiqueBDD_1_nombre ;
        _enterToken (_token) ;
      }else if (testForInputString (":=", 2)) {
        _token._mTokenCode = lexiqueBDD_1__3A_3D ;
        _enterToken (_token) ;
      }else if (testForInputString ("..", 2)) {
        _token._mTokenCode = lexiqueBDD_1__2E_2E ;
        _enterToken (_token) ;
      }else if (testForInputString ("+=", 2)) {
        _token._mTokenCode = lexiqueBDD_1__2B_3D ;
        _enterToken (_token) ;
      }else if (testForInputString ("-=", 2)) {
        _token._mTokenCode = lexiqueBDD_1__2D_3D ;
        _enterToken (_token) ;
      }else if (testForInputString ("->", 2)) {
        _token._mTokenCode = lexiqueBDD_1__2D_3E ;
        _enterToken (_token) ;
      }else if (testForInputString ("(", 1)) {
        _token._mTokenCode = lexiqueBDD_1__28 ;
        _enterToken (_token) ;
      }else if (testForInputString (")", 1)) {
        _token._mTokenCode = lexiqueBDD_1__29 ;
        _enterToken (_token) ;
      }else if (testForInputString ("{", 1)) {
        _token._mTokenCode = lexiqueBDD_1__7B ;
        _enterToken (_token) ;
      }else if (testForInputString ("}", 1)) {
        _token._mTokenCode = lexiqueBDD_1__7D ;
        _enterToken (_token) ;
      }else if (testForInputString ("[", 1)) {
        _token._mTokenCode = lexiqueBDD_1__5B ;
        _enterToken (_token) ;
      }else if (testForInputString ("]", 1)) {
        _token._mTokenCode = lexiqueBDD_1__5D ;
        _enterToken (_token) ;
      }else if (testForInputString (":", 1)) {
        _token._mTokenCode = lexiqueBDD_1__3A ;
        _enterToken (_token) ;
      }else if (testForInputString (".", 1)) {
        _token._mTokenCode = lexiqueBDD_1__2E ;
        _enterToken (_token) ;
      }else if (testForInputString ("&", 1)) {
        _token._mTokenCode = lexiqueBDD_1__26 ;
        _enterToken (_token) ;
      }else if (testForInputString ("|", 1)) {
        _token._mTokenCode = lexiqueBDD_1__7C ;
        _enterToken (_token) ;
      }else if (testForInputString ("~", 1)) {
        _token._mTokenCode = lexiqueBDD_1__7E ;
        _enterToken (_token) ;
      }else if (testForInputString (",", 1)) {
        _token._mTokenCode = lexiqueBDD_1__2C ;
        _enterToken (_token) ;
      }else if (testForInputString ("\?", 1)) {
        _token._mTokenCode = lexiqueBDD_1__3F ;
        _enterToken (_token) ;
      }else if (testForInputString ("!", 1)) {
        _token._mTokenCode = lexiqueBDD_1__21 ;
        _enterToken (_token) ;
      }else if (testForInputString (";", 1)) {
        _token._mTokenCode = lexiqueBDD_1__3B ;
        _enterToken (_token) ;
      }else if (testForInputString ("#", 1)) {
        _token._mTokenCode = lexiqueBDD_1__23 ;
        _enterToken (_token) ;
      }else if (testForInputChar ('=')) {
        scanner_action_formerCompEgal (_token.att_valeur) ;
        _token._mTokenCode = lexiqueBDD_1_comp ;
        _enterToken (_token) ;
      }else if (testForInputChar ('<')) {
        if (testForInputChar ('>')) {
          scanner_action_formerCompNonEgal (_token.att_valeur) ;
          _token._mTokenCode = lexiqueBDD_1_comp ;
          _enterToken (_token) ;
        }else if (testForInputChar ('=')) {
          scanner_action_formerCompInfEgal (_token.att_valeur) ;
          _token._mTokenCode = lexiqueBDD_1_comp ;
          _enterToken (_token) ;
        }else{
          scanner_action_formerCompInf (_token.att_valeur) ;
          _token._mTokenCode = lexiqueBDD_1_comp ;
          _enterToken (_token) ;
        }
      }else if (testForInputChar ('>')) {
        if (testForInputChar ('=')) {
          scanner_action_formerCompSupEgal (_token.att_valeur) ;
          _token._mTokenCode = lexiqueBDD_1_comp ;
          _enterToken (_token) ;
        }else{
          scanner_action_formerCompSup (_token.att_valeur) ;
          _token._mTokenCode = lexiqueBDD_1_comp ;
          _enterToken (_token) ;
        }
      }else if (testForInputChar ('$')) {
        do {
          if (testForInputChar ('\x1', '\t') ||
              testForInputChar ('\v') ||
              testForInputChar ('\f') ||
              testForInputChar ('\xE', '\xFF')) {
          }else{
            loop_ = false ;
          }
        }while (loop_) ;
        loop_ = true ;
      }else if (testForInputChar ('\x1', ' ')) {
      }else if (testForInputChar ('\0')) { // End of source text ? 
        _token._mTokenCode = lexiqueBDD_1_ ; // Empty string code
      }else{ // Unknown input character
        unknownCharacterLexicalError (LINE_AND_SOURCE_FILE) ;
      }
    }catch (const C_lexicalErrorException &) {
      _token._mTokenCode = -1 ; // No token
      advance () ; // ... go throught unknown character
    }
  }
  return _token._mTokenCode > 0 ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   parseLexicalTokenForLexicalColoring                     *
//                                                                           *
//---------------------------------------------------------------------------*

sint16 lexiqueBDD::
parseLexicalTokenForLexicalColoring (void) {
  cTokenFor_lexiqueBDD _token ;
  bool loop_ = true ;
  _token._mTokenCode = -1 ;
  while (_token._mTokenCode < 0) {
    _token.att_idf.clear () ;
    _token.att_token.clear () ;
    _token.att_valeur = 0 ;
    mCurrentTokenStartLocation = location () ;
    try{
      if (testForInputChar ('a', 'z') ||
          testForInputChar ('A', 'Z')) {
        do {
          scanner_action_enterCharacterIntoString (_token.att_idf, scanner_action_toLower (previousChar ())) ;
          scanner_action_enterCharacterIntoString (_token.att_token, previousChar ()) ;
          if (testForInputChar ('a', 'z') ||
              testForInputChar ('A', 'Z') ||
              testForInputChar ('_') ||
              testForInputChar ('0', '9')) {
          }else{
            loop_ = false ;
          }
        }while (loop_) ;
        loop_ = true ;
        _token._mTokenCode = search_into_motsReservesKerBDD (_token.att_idf) ;
        if (_token._mTokenCode == -1) {
          _token._mTokenCode = lexiqueBDD_1_id ;
        }
      }else if (testForInputChar ('\"')) {
        do {
          if (testForInputChar (' ') ||
              testForInputChar ('!') ||
              testForInputChar ('#', '\xFF')) {
            scanner_action_enterCharacterIntoString (_token.att_token, previousChar ()) ;
          }else{
            loop_ = false ;
          }
        }while (loop_) ;
        loop_ = true ;
        if (testForInputChar ('\"')) {
          _token._mTokenCode = lexiqueBDD_1_string ;
        }else{
          lexicalError (gErrorMessage_2 COMMA_LINE_AND_SOURCE_FILE) ;
        }
      }else if (testForInputChar ('0', '9')) {
        scanner_action_enterDigitIntoUlong (_token.att_valeur, previousChar (), gErrorMessage_0, gErrorMessage_1) ;
        do {
          if (testForInputChar ('0', '9')) {
            scanner_action_enterDigitIntoUlong (_token.att_valeur, previousChar (), gErrorMessage_0, gErrorMessage_1) ;
          }else if (testForInputChar ('_')) {
          }else{
            loop_ = false ;
          }
        }while (loop_) ;
        loop_ = true ;
        _token._mTokenCode = lexiqueBDD_1_nombre ;
      }else if (testForInputString (":=", 2)) {
        _token._mTokenCode = lexiqueBDD_1__3A_3D ;
      }else if (testForInputString ("..", 2)) {
        _token._mTokenCode = lexiqueBDD_1__2E_2E ;
      }else if (testForInputString ("+=", 2)) {
        _token._mTokenCode = lexiqueBDD_1__2B_3D ;
      }else if (testForInputString ("-=", 2)) {
        _token._mTokenCode = lexiqueBDD_1__2D_3D ;
      }else if (testForInputString ("->", 2)) {
        _token._mTokenCode = lexiqueBDD_1__2D_3E ;
      }else if (testForInputString ("(", 1)) {
        _token._mTokenCode = lexiqueBDD_1__28 ;
      }else if (testForInputString (")", 1)) {
        _token._mTokenCode = lexiqueBDD_1__29 ;
      }else if (testForInputString ("{", 1)) {
        _token._mTokenCode = lexiqueBDD_1__7B ;
      }else if (testForInputString ("}", 1)) {
        _token._mTokenCode = lexiqueBDD_1__7D ;
      }else if (testForInputString ("[", 1)) {
        _token._mTokenCode = lexiqueBDD_1__5B ;
      }else if (testForInputString ("]", 1)) {
        _token._mTokenCode = lexiqueBDD_1__5D ;
      }else if (testForInputString (":", 1)) {
        _token._mTokenCode = lexiqueBDD_1__3A ;
      }else if (testForInputString (".", 1)) {
        _token._mTokenCode = lexiqueBDD_1__2E ;
      }else if (testForInputString ("&", 1)) {
        _token._mTokenCode = lexiqueBDD_1__26 ;
      }else if (testForInputString ("|", 1)) {
        _token._mTokenCode = lexiqueBDD_1__7C ;
      }else if (testForInputString ("~", 1)) {
        _token._mTokenCode = lexiqueBDD_1__7E ;
      }else if (testForInputString (",", 1)) {
        _token._mTokenCode = lexiqueBDD_1__2C ;
      }else if (testForInputString ("\?", 1)) {
        _token._mTokenCode = lexiqueBDD_1__3F ;
      }else if (testForInputString ("!", 1)) {
        _token._mTokenCode = lexiqueBDD_1__21 ;
      }else if (testForInputString (";", 1)) {
        _token._mTokenCode = lexiqueBDD_1__3B ;
      }else if (testForInputString ("#", 1)) {
        _token._mTokenCode = lexiqueBDD_1__23 ;
      }else if (testForInputChar ('=')) {
        scanner_action_formerCompEgal (_token.att_valeur) ;
        _token._mTokenCode = lexiqueBDD_1_comp ;
      }else if (testForInputChar ('<')) {
        if (testForInputChar ('>')) {
          scanner_action_formerCompNonEgal (_token.att_valeur) ;
          _token._mTokenCode = lexiqueBDD_1_comp ;
        }else if (testForInputChar ('=')) {
          scanner_action_formerCompInfEgal (_token.att_valeur) ;
          _token._mTokenCode = lexiqueBDD_1_comp ;
        }else{
          scanner_action_formerCompInf (_token.att_valeur) ;
          _token._mTokenCode = lexiqueBDD_1_comp ;
        }
      }else if (testForInputChar ('>')) {
        if (testForInputChar ('=')) {
          scanner_action_formerCompSupEgal (_token.att_valeur) ;
          _token._mTokenCode = lexiqueBDD_1_comp ;
        }else{
          scanner_action_formerCompSup (_token.att_valeur) ;
          _token._mTokenCode = lexiqueBDD_1_comp ;
        }
      }else if (testForInputChar ('$')) {
        do {
          if (testForInputChar ('\x1', '\t') ||
              testForInputChar ('\v') ||
              testForInputChar ('\f') ||
              testForInputChar ('\xE', '\xFF')) {
          }else{
            loop_ = false ;
          }
        }while (loop_) ;
        loop_ = true ;
      }else if (testForInputChar ('\x1', ' ')) {
      }else if (testForInputChar ('\0')) { // End of source text ? 
        _token._mTokenCode = lexiqueBDD_1_ ; // Empty string code
      }else{ // Unknown input character
        unknownCharacterLexicalError (LINE_AND_SOURCE_FILE) ;
      }
    }catch (const C_lexicalErrorException &) {
      _token._mTokenCode = -1 ; // No token
      advance () ; // ... go throught unknown character
      throw ;
    }
  }
  return _token._mTokenCode ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                            Styles definition                              *
//                                                                           *
//---------------------------------------------------------------------------*

sint32 lexiqueBDD::getStylesCount (void) {
  return 6 ;
}

//---------------------------------------------------------------------------*

const char * lexiqueBDD::getStyleName (const sint32 inIndex) {
  const char * kStylesArray [7] = {"Default style", "Identifiers", "Key words", "String constants", "Delimitors", "Integer constants", NULL} ;
  return (inIndex < 6) ? kStylesArray [inIndex] : NULL ;
} ;

//---------------------------------------------------------------------------*

const char * lexiqueBDD::getStyleIdentifier (const sint32 inIndex) {
  const char * kStylesArray [7] = {"", "identifier", "keyWords", "stringStyle", "delimitors", "integer_csts", NULL} ;
  return (inIndex < 6) ? kStylesArray [inIndex] : NULL ;
} ;

//---------------------------------------------------------------------------*

uint8 lexiqueBDD::
terminalStyleIndex (const sint32 inTerminal) {
  static const uint8 kTerminalSymbolStyles [46] = {0,
    5 /* lexiqueBDD_1_nombre */,
    1 /* lexiqueBDD_1_id */,
    3 /* lexiqueBDD_1_string */,
    4 /* lexiqueBDD_1_comp */,
    4 /* lexiqueBDD_1__28 */,
    4 /* lexiqueBDD_1__29 */,
    4 /* lexiqueBDD_1__7B */,
    4 /* lexiqueBDD_1__7D */,
    4 /* lexiqueBDD_1__5B */,
    4 /* lexiqueBDD_1__5D */,
    4 /* lexiqueBDD_1__3A_3D */,
    4 /* lexiqueBDD_1__3A */,
    4 /* lexiqueBDD_1__2E */,
    4 /* lexiqueBDD_1__2E_2E */,
    4 /* lexiqueBDD_1__2B_3D */,
    4 /* lexiqueBDD_1__2D_3D */,
    4 /* lexiqueBDD_1__2D_3E */,
    4 /* lexiqueBDD_1__26 */,
    4 /* lexiqueBDD_1__7C */,
    4 /* lexiqueBDD_1__7E */,
    4 /* lexiqueBDD_1__2C */,
    4 /* lexiqueBDD_1__3F */,
    4 /* lexiqueBDD_1__21 */,
    4 /* lexiqueBDD_1__3B */,
    4 /* lexiqueBDD_1__23 */,
    2 /* lexiqueBDD_1_ite_5Fcache */,
    2 /* lexiqueBDD_1_and_5Fcache */,
    2 /* lexiqueBDD_1_use_5Fand */,
    2 /* lexiqueBDD_1_use_5Fite */,
    2 /* lexiqueBDD_1_use_5Fand_5Fite */,
    2 /* lexiqueBDD_1_map */,
    2 /* lexiqueBDD_1_bdd */,
    2 /* lexiqueBDD_1_domain */,
    2 /* lexiqueBDD_1_bool */,
    2 /* lexiqueBDD_1_record */,
    2 /* lexiqueBDD_1_true */,
    2 /* lexiqueBDD_1_false */,
    2 /* lexiqueBDD_1_display */,
    2 /* lexiqueBDD_1_include */,
    2 /* lexiqueBDD_1_dump */,
    2 /* lexiqueBDD_1_verify */,
    2 /* lexiqueBDD_1_end */,
    2 /* lexiqueBDD_1_if */,
    2 /* lexiqueBDD_1_then */,
    2 /* lexiqueBDD_1_else */
  } ;
  return kTerminalSymbolStyles [inTerminal] ;
}

//---------------------------------------------------------------------------*

void lexiqueBDD::_enterToken (const cTokenFor_lexiqueBDD & inToken) {
  cTokenFor_lexiqueBDD * _p = NULL ;
  macroMyNew (_p, cTokenFor_lexiqueBDD ()) ;
  _p->_mTokenCode = inToken._mTokenCode ;
  _p->_mCurrentLocation = _mCurrentLocation ;
  _p->att_idf = inToken.att_idf ;
  _p->att_token = inToken.att_token ;
  _p->att_valeur = inToken.att_valeur ;
  _enterTokenFromPointer (_p) ;
}

//---------------------------------------------------------------------------*

void lexiqueBDD::
_assignFromAttribute_att_idf (GGS_lstring & outValue) const {
  cTokenFor_lexiqueBDD * _p = (cTokenFor_lexiqueBDD *) mCurrentTokenPtr ;
  outValue = GGS_lstring (* this, _p->att_idf) ;
}

//---------------------------------------------------------------------------*

void lexiqueBDD::
_assignFromAttribute_att_token (GGS_lstring & outValue) const {
  cTokenFor_lexiqueBDD * _p = (cTokenFor_lexiqueBDD *) mCurrentTokenPtr ;
  outValue = GGS_lstring (* this, _p->att_token) ;
}

//---------------------------------------------------------------------------*

void lexiqueBDD::
_assignFromAttribute_att_valeur (GGS_luint & outValue) const {
  cTokenFor_lexiqueBDD * _p = (cTokenFor_lexiqueBDD *) mCurrentTokenPtr ;
  outValue = GGS_luint (* this, _p->att_valeur) ;
}

//--- START OF USER ZONE 2

//---------------------------------------------------------------------*

void lexiqueBDD::
scanner_action_formerCompEgal (uint32 & ioValue) {
  ioValue = C_BDD::kEqual ;
}

//---------------------------------------------------------------------*

void lexiqueBDD::
scanner_action_formerCompNonEgal (uint32 & ioValue) {
  ioValue = C_BDD::kNotEqual ;
}

//---------------------------------------------------------------------*

void lexiqueBDD::
scanner_action_formerCompInfEgal (uint32 & ioValue) {
  ioValue = C_BDD::kLowerOrEqual ;
}

//---------------------------------------------------------------------*

void lexiqueBDD::
scanner_action_formerCompInf (uint32 & ioValue) {
  ioValue = C_BDD::kStrictLower ;
}

//---------------------------------------------------------------------*

void lexiqueBDD::
scanner_action_formerCompSupEgal (uint32 & ioValue) {
  ioValue = C_BDD::kGreaterOrEqual ;
}

//---------------------------------------------------------------------*

void lexiqueBDD::
scanner_action_formerCompSup (uint32 & ioValue) {
  ioValue = C_BDD::kStrictGreater ;
}

//---------------------------------------------------------------------*


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*

