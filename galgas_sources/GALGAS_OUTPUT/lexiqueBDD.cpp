//---------------------------------------------------------------------------*
//                                                                           *
//                          File 'lexiqueBDD.cpp'                            *
//         Generated by version GALGAS_BETA_VERSION (LL(1) grammar)          *
//                    december 27th, 2005, at 18h45'15"                      *
//                                                                           *
// This file is free software; you can redistribute it and/or modify it      *
// under the terms of the GNU Lesser General Public License as published     *
// by the Free Software Foundation; either version 2 of the License, or      *
// (at your option) any later version.                                       *
//                                                                           *
// This file is distributed in the hope it will be useful, but WITHOUT       *
// ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or     *
// FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public       *
// License for more details.                                                 *
//                                                                           *
// You should have received a copy of the GNU General Public License along   *
// with this program; if not, write to the Free Software Foundation          *
// Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA            *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1

#include "bdd/C_BDD.h"


//--- END OF USER ZONE 1

#include <ctype.h>
#include <string.h>

#include "lexiqueBDD.h"

//---------------------------------------------------------------------------*
//                                                                           *
//                               Constructor                                 *
//                                                                           *
//---------------------------------------------------------------------------*

lexiqueBDD::
lexiqueBDD (AC_galgas_io * inGalgasInputOutput)
: C_Lexique (inGalgasInputOutput) {
  att_idf.clear () ;
  att_token.clear () ;
  att_valeur = 0 ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        Lexical error message list                         *
//                                                                           *
//---------------------------------------------------------------------------*

//--- Message 0 (fin_commentaire_incorrect) :
static const char * gErrorMessage_0 = "incorrect commend ending" ;
//--- Message 1 (nombre_dec_trop_grand) :
static const char * gErrorMessage_1 = "number too large" ;
//--- Message 2 (car_non_chiffre) :
static const char * gErrorMessage_2 = "the character is not a decimal digit" ;
//--- Message 3 (fin_chaine_incorrecte) :
static const char * gErrorMessage_3 = "the character string does not end with \"" ;

//---------------------------------------------------------------------------*
//                                                                           *
//                          Syntax error messages                            *
//                                                                           *
//---------------------------------------------------------------------------*

//--- Syntax error message for terminal '$nombre$' :
static const char * gSyntaxErrorMessage_nombre = "a decimal integer" ;
//--- Syntax error message for terminal '$id$' :
static const char * gSyntaxErrorMessage_id = "an identifier" ;
//--- Syntax error message for terminal '$string$' :
static const char * gSyntaxErrorMessage_string = "a character string (between \" and \")" ;
//--- Syntax error message for terminal '$comp$' :
static const char * gSyntaxErrorMessage_comp = "the '=', '<>', '<=', '<', '>' or '>' delimitor" ;
//--- Syntax error message for terminal '$($' :
static const char * gSyntaxErrorMessage__28 = "the '(' delimiter" ;
//--- Syntax error message for terminal '$)$' :
static const char * gSyntaxErrorMessage__29 = "the ')' delimiter" ;
//--- Syntax error message for terminal '${$' :
static const char * gSyntaxErrorMessage__7B = "the '{' delimiter" ;
//--- Syntax error message for terminal '$}$' :
static const char * gSyntaxErrorMessage__7D = "the '}' delimiter" ;
//--- Syntax error message for terminal '$[$' :
static const char * gSyntaxErrorMessage__5B = "the '[' delimiter" ;
//--- Syntax error message for terminal '$]$' :
static const char * gSyntaxErrorMessage__5D = "the ']' delimiter" ;
//--- Syntax error message for terminal '$:=$' :
static const char * gSyntaxErrorMessage__3A_3D = "the ':=' delimiter" ;
//--- Syntax error message for terminal '$:$' :
static const char * gSyntaxErrorMessage__3A = "the ':' delimiter" ;
//--- Syntax error message for terminal '$.$' :
static const char * gSyntaxErrorMessage__2E = "the '.' delimiter" ;
//--- Syntax error message for terminal '$..$' :
static const char * gSyntaxErrorMessage__2E_2E = "the '..' delimiter" ;
//--- Syntax error message for terminal '$::$' :
static const char * gSyntaxErrorMessage__3A_3A = "the '::' delimiter" ;
//--- Syntax error message for terminal '$+=$' :
static const char * gSyntaxErrorMessage__2B_3D = "the '+=' delimiter" ;
//--- Syntax error message for terminal '$-=$' :
static const char * gSyntaxErrorMessage__2D_3D = "the '-=' delimiter" ;
//--- Syntax error message for terminal '$->$' :
static const char * gSyntaxErrorMessage__2D_3E = "the '->' delimiter" ;
//--- Syntax error message for terminal '$&$' :
static const char * gSyntaxErrorMessage__26 = "the '&' delimiter" ;
//--- Syntax error message for terminal '$|$' :
static const char * gSyntaxErrorMessage__7C = "the '|' delimiter" ;
//--- Syntax error message for terminal '$~$' :
static const char * gSyntaxErrorMessage__7E = "the '~' delimiter" ;
//--- Syntax error message for terminal '$,$' :
static const char * gSyntaxErrorMessage__2C = "the ',' delimiter" ;
//--- Syntax error message for terminal '$?$' :
static const char * gSyntaxErrorMessage__3F = "the '\?' delimiter" ;
//--- Syntax error message for terminal '$!$' :
static const char * gSyntaxErrorMessage__21 = "the '!' delimiter" ;
//--- Syntax error message for terminal '$;$' :
static const char * gSyntaxErrorMessage__3B = "the ';' delimiter" ;
//--- Syntax error message for terminal '$#$' :
static const char * gSyntaxErrorMessage__23 = "the '#' delimiter" ;
//--- Syntax error message for terminal '$ite_cache$' :
static const char * gSyntaxErrorMessage_ite_5Fcache = "the 'ite_cache' keyword" ;
//--- Syntax error message for terminal '$and_cache$' :
static const char * gSyntaxErrorMessage_and_5Fcache = "the 'and_cache' keyword" ;
//--- Syntax error message for terminal '$use_and$' :
static const char * gSyntaxErrorMessage_use_5Fand = "the 'use_and' keyword" ;
//--- Syntax error message for terminal '$use_ite$' :
static const char * gSyntaxErrorMessage_use_5Fite = "the 'use_ite' keyword" ;
//--- Syntax error message for terminal '$use_and_ite$' :
static const char * gSyntaxErrorMessage_use_5Fand_5Fite = "the 'use_and_ite' keyword" ;
//--- Syntax error message for terminal '$map$' :
static const char * gSyntaxErrorMessage_map = "the 'map' keyword" ;
//--- Syntax error message for terminal '$dimension$' :
static const char * gSyntaxErrorMessage_dimension = "the 'dimension' keyword" ;
//--- Syntax error message for terminal '$bdd$' :
static const char * gSyntaxErrorMessage_bdd = "the 'bdd' keyword" ;
//--- Syntax error message for terminal '$domain$' :
static const char * gSyntaxErrorMessage_domain = "the 'domain' keyword" ;
//--- Syntax error message for terminal '$bool$' :
static const char * gSyntaxErrorMessage_bool = "the 'bool' keyword" ;
//--- Syntax error message for terminal '$record$' :
static const char * gSyntaxErrorMessage_record = "the 'record' keyword" ;
//--- Syntax error message for terminal '$true$' :
static const char * gSyntaxErrorMessage_true = "the 'true' keyword" ;
//--- Syntax error message for terminal '$false$' :
static const char * gSyntaxErrorMessage_false = "the 'false' keyword" ;
//--- Syntax error message for terminal '$display$' :
static const char * gSyntaxErrorMessage_display = "the 'display' keyword" ;
//--- Syntax error message for terminal '$include$' :
static const char * gSyntaxErrorMessage_include = "the 'include' keyword" ;
//--- Syntax error message for terminal '$dump$' :
static const char * gSyntaxErrorMessage_dump = "the 'dump' keyword" ;
//--- Syntax error message for terminal '$verify$' :
static const char * gSyntaxErrorMessage_verify = "the 'verify' keyword" ;
//--- Syntax error message for terminal '$end$' :
static const char * gSyntaxErrorMessage_end = "the 'end' keyword" ;
//--- Syntax error message for terminal '$if$' :
static const char * gSyntaxErrorMessage_if = "the 'if' keyword" ;
//--- Syntax error message for terminal '$then$' :
static const char * gSyntaxErrorMessage_then = "the 'then' keyword" ;
//--- Syntax error message for terminal '$else$' :
static const char * gSyntaxErrorMessage_else = "the 'else' keyword" ;
//---------------------------------------------------------------------------*

void lexiqueBDD::
appendTerminalMessageToSyntaxErrorMessage (const sint16 inTerminalIndex,
                                           C_String & outSyntaxErrorMessage) {
  static const char * syntaxErrorMessageArray [48] = {"end of source",
       gSyntaxErrorMessage_nombre,
       gSyntaxErrorMessage_id,
       gSyntaxErrorMessage_string,
       gSyntaxErrorMessage_comp,
       gSyntaxErrorMessage__28,
       gSyntaxErrorMessage__29,
       gSyntaxErrorMessage__7B,
       gSyntaxErrorMessage__7D,
       gSyntaxErrorMessage__5B,
       gSyntaxErrorMessage__5D,
       gSyntaxErrorMessage__3A_3D,
       gSyntaxErrorMessage__3A,
       gSyntaxErrorMessage__2E,
       gSyntaxErrorMessage__2E_2E,
       gSyntaxErrorMessage__3A_3A,
       gSyntaxErrorMessage__2B_3D,
       gSyntaxErrorMessage__2D_3D,
       gSyntaxErrorMessage__2D_3E,
       gSyntaxErrorMessage__26,
       gSyntaxErrorMessage__7C,
       gSyntaxErrorMessage__7E,
       gSyntaxErrorMessage__2C,
       gSyntaxErrorMessage__3F,
       gSyntaxErrorMessage__21,
       gSyntaxErrorMessage__3B,
       gSyntaxErrorMessage__23,
       gSyntaxErrorMessage_ite_5Fcache,
       gSyntaxErrorMessage_and_5Fcache,
       gSyntaxErrorMessage_use_5Fand,
       gSyntaxErrorMessage_use_5Fite,
       gSyntaxErrorMessage_use_5Fand_5Fite,
       gSyntaxErrorMessage_map,
       gSyntaxErrorMessage_dimension,
       gSyntaxErrorMessage_bdd,
       gSyntaxErrorMessage_domain,
       gSyntaxErrorMessage_bool,
       gSyntaxErrorMessage_record,
       gSyntaxErrorMessage_true,
       gSyntaxErrorMessage_false,
       gSyntaxErrorMessage_display,
       gSyntaxErrorMessage_include,
       gSyntaxErrorMessage_dump,
       gSyntaxErrorMessage_verify,
       gSyntaxErrorMessage_end,
       gSyntaxErrorMessage_if,
       gSyntaxErrorMessage_then,
       gSyntaxErrorMessage_else} ;
  outSyntaxErrorMessage << syntaxErrorMessageArray [inTerminalIndex] ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   Key words table 'delimiteursKerBDD'                     *
//                                                                           *
//---------------------------------------------------------------------------*

const sint16 lexiqueBDD::lexiqueBDD_table_size_delimiteursKerBDD = 22 ;

const C_lexique_table_entry lexiqueBDD::lexiqueBDD_table_for_delimiteursKerBDD [22] = {
  C_lexique_table_entry ("!", 1, lexiqueBDD_1__21),
  C_lexique_table_entry ("#", 1, lexiqueBDD_1__23),
  C_lexique_table_entry ("&", 1, lexiqueBDD_1__26),
  C_lexique_table_entry ("(", 1, lexiqueBDD_1__28),
  C_lexique_table_entry (")", 1, lexiqueBDD_1__29),
  C_lexique_table_entry (",", 1, lexiqueBDD_1__2C),
  C_lexique_table_entry (".", 1, lexiqueBDD_1__2E),
  C_lexique_table_entry (":", 1, lexiqueBDD_1__3A),
  C_lexique_table_entry (";", 1, lexiqueBDD_1__3B),
  C_lexique_table_entry ("\?", 1, lexiqueBDD_1__3F),
  C_lexique_table_entry ("[", 1, lexiqueBDD_1__5B),
  C_lexique_table_entry ("]", 1, lexiqueBDD_1__5D),
  C_lexique_table_entry ("{", 1, lexiqueBDD_1__7B),
  C_lexique_table_entry ("|", 1, lexiqueBDD_1__7C),
  C_lexique_table_entry ("}", 1, lexiqueBDD_1__7D),
  C_lexique_table_entry ("~", 1, lexiqueBDD_1__7E),
  C_lexique_table_entry ("+=", 2, lexiqueBDD_1__2B_3D),
  C_lexique_table_entry ("-=", 2, lexiqueBDD_1__2D_3D),
  C_lexique_table_entry ("->", 2, lexiqueBDD_1__2D_3E),
  C_lexique_table_entry ("..", 2, lexiqueBDD_1__2E_2E),
  C_lexique_table_entry ("::", 2, lexiqueBDD_1__3A_3A),
  C_lexique_table_entry (":=", 2, lexiqueBDD_1__3A_3D)
} ;

sint16 lexiqueBDD::search_into_delimiteursKerBDD (const C_String & inSearchedString) {
  return searchInList (inSearchedString, lexiqueBDD_table_for_delimiteursKerBDD, lexiqueBDD_table_size_delimiteursKerBDD) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   Key words table 'motsReservesKerBDD'                    *
//                                                                           *
//---------------------------------------------------------------------------*

const sint16 lexiqueBDD::lexiqueBDD_table_size_motsReservesKerBDD = 21 ;

const C_lexique_table_entry lexiqueBDD::lexiqueBDD_table_for_motsReservesKerBDD [21] = {
  C_lexique_table_entry ("if", 2, lexiqueBDD_1_if),
  C_lexique_table_entry ("bdd", 3, lexiqueBDD_1_bdd),
  C_lexique_table_entry ("end", 3, lexiqueBDD_1_end),
  C_lexique_table_entry ("map", 3, lexiqueBDD_1_map),
  C_lexique_table_entry ("bool", 4, lexiqueBDD_1_bool),
  C_lexique_table_entry ("dump", 4, lexiqueBDD_1_dump),
  C_lexique_table_entry ("else", 4, lexiqueBDD_1_else),
  C_lexique_table_entry ("then", 4, lexiqueBDD_1_then),
  C_lexique_table_entry ("true", 4, lexiqueBDD_1_true),
  C_lexique_table_entry ("false", 5, lexiqueBDD_1_false),
  C_lexique_table_entry ("domain", 6, lexiqueBDD_1_domain),
  C_lexique_table_entry ("record", 6, lexiqueBDD_1_record),
  C_lexique_table_entry ("verify", 6, lexiqueBDD_1_verify),
  C_lexique_table_entry ("display", 7, lexiqueBDD_1_display),
  C_lexique_table_entry ("include", 7, lexiqueBDD_1_include),
  C_lexique_table_entry ("use_and", 7, lexiqueBDD_1_use_5Fand),
  C_lexique_table_entry ("use_ite", 7, lexiqueBDD_1_use_5Fite),
  C_lexique_table_entry ("and_cache", 9, lexiqueBDD_1_and_5Fcache),
  C_lexique_table_entry ("dimension", 9, lexiqueBDD_1_dimension),
  C_lexique_table_entry ("ite_cache", 9, lexiqueBDD_1_ite_5Fcache),
  C_lexique_table_entry ("use_and_ite", 11, lexiqueBDD_1_use_5Fand_5Fite)
} ;

sint16 lexiqueBDD::search_into_motsReservesKerBDD (const C_String & inSearchedString) {
  return searchInList (inSearchedString, lexiqueBDD_table_for_motsReservesKerBDD, lexiqueBDD_table_size_motsReservesKerBDD) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               Get next token : method 'parseLexicalToken'                 *
//                                                                           *
//---------------------------------------------------------------------------*

void lexiqueBDD::
parseLexicalToken (const bool inPropagateLexicaleErrorException) {
  bool loop_ = true ;
  mCurrentTokenCode = -1 ;
  att_idf.clear () ;
  att_token.clear () ;
  att_valeur = 0 ;
  while (mCurrentTokenCode < 0) {
    mCurrentTokenStartLocation = currentLocation () ;
    try{
      if (testForInputChar ('a', 'z') ||
          testForInputChar ('A', 'Z')) {
        do {
          scanner_action_enterCharacterIntoString (att_idf, scanner_action_toLower (previousChar ())) ;
          scanner_action_enterCharacterIntoString (att_token, previousChar ()) ;
          if (testForInputChar ('a', 'z') ||
              testForInputChar ('A', 'Z') ||
              testForInputChar ('_') ||
              testForInputChar ('0', '9')) {
          }else{
            loop_ = false ;
          }
        }while (loop_) ;
        loop_ = true ;
        mCurrentTokenCode = search_into_motsReservesKerBDD (att_idf) ;
        if (mCurrentTokenCode == -1) {
          mCurrentTokenCode = lexiqueBDD_1_id ;
        }
      }else if (testForInputChar ('\"')) {
        do {
          if (testForInputChar (' ') ||
              testForInputChar ('!') ||
              testForInputChar ('#', '\xFF')) {
            scanner_action_enterCharacterIntoString (att_token, previousChar ()) ;
          }else{
            loop_ = false ;
          }
        }while (loop_) ;
        loop_ = true ;
        if (testForInputChar ('\"')) {
          mCurrentTokenCode = lexiqueBDD_1_string ;
        }else{
          lexicalError (gErrorMessage_3) ;
        }
      }else if (testForInputChar ('0', '9')) {
        scanner_action_enterDigitIntoUlong (att_valeur, previousChar (), gErrorMessage_1, gErrorMessage_2) ;
        do {
          if (testForInputChar ('0', '9')) {
            scanner_action_enterDigitIntoUlong (att_valeur, previousChar (), gErrorMessage_1, gErrorMessage_2) ;
          }else if (testForInputChar ('_')) {
          }else{
            loop_ = false ;
          }
        }while (loop_) ;
        loop_ = true ;
        mCurrentTokenCode = lexiqueBDD_1_nombre ;
      }else if (testForInputString (":=", 2)) {
        mCurrentTokenCode = lexiqueBDD_1__3A_3D ;
      }else if (testForInputString ("..", 2)) {
        mCurrentTokenCode = lexiqueBDD_1__2E_2E ;
      }else if (testForInputString ("::", 2)) {
        mCurrentTokenCode = lexiqueBDD_1__3A_3A ;
      }else if (testForInputString ("+=", 2)) {
        mCurrentTokenCode = lexiqueBDD_1__2B_3D ;
      }else if (testForInputString ("-=", 2)) {
        mCurrentTokenCode = lexiqueBDD_1__2D_3D ;
      }else if (testForInputString ("->", 2)) {
        mCurrentTokenCode = lexiqueBDD_1__2D_3E ;
      }else if (testForInputString ("(", 1)) {
        mCurrentTokenCode = lexiqueBDD_1__28 ;
      }else if (testForInputString (")", 1)) {
        mCurrentTokenCode = lexiqueBDD_1__29 ;
      }else if (testForInputString ("{", 1)) {
        mCurrentTokenCode = lexiqueBDD_1__7B ;
      }else if (testForInputString ("}", 1)) {
        mCurrentTokenCode = lexiqueBDD_1__7D ;
      }else if (testForInputString ("[", 1)) {
        mCurrentTokenCode = lexiqueBDD_1__5B ;
      }else if (testForInputString ("]", 1)) {
        mCurrentTokenCode = lexiqueBDD_1__5D ;
      }else if (testForInputString (":", 1)) {
        mCurrentTokenCode = lexiqueBDD_1__3A ;
      }else if (testForInputString (".", 1)) {
        mCurrentTokenCode = lexiqueBDD_1__2E ;
      }else if (testForInputString ("&", 1)) {
        mCurrentTokenCode = lexiqueBDD_1__26 ;
      }else if (testForInputString ("|", 1)) {
        mCurrentTokenCode = lexiqueBDD_1__7C ;
      }else if (testForInputString ("~", 1)) {
        mCurrentTokenCode = lexiqueBDD_1__7E ;
      }else if (testForInputString (",", 1)) {
        mCurrentTokenCode = lexiqueBDD_1__2C ;
      }else if (testForInputString ("\?", 1)) {
        mCurrentTokenCode = lexiqueBDD_1__3F ;
      }else if (testForInputString ("!", 1)) {
        mCurrentTokenCode = lexiqueBDD_1__21 ;
      }else if (testForInputString (";", 1)) {
        mCurrentTokenCode = lexiqueBDD_1__3B ;
      }else if (testForInputString ("#", 1)) {
        mCurrentTokenCode = lexiqueBDD_1__23 ;
      }else if (testForInputChar ('=')) {
        scanner_action_formerCompEgal (att_valeur) ;
        mCurrentTokenCode = lexiqueBDD_1_comp ;
      }else if (testForInputChar ('<')) {
        if (testForInputChar ('>')) {
          scanner_action_formerCompNonEgal (att_valeur) ;
          mCurrentTokenCode = lexiqueBDD_1_comp ;
        }else if (testForInputChar ('=')) {
          scanner_action_formerCompInfEgal (att_valeur) ;
          mCurrentTokenCode = lexiqueBDD_1_comp ;
        }else{
          scanner_action_formerCompInf (att_valeur) ;
          mCurrentTokenCode = lexiqueBDD_1_comp ;
        }
      }else if (testForInputChar ('>')) {
        if (testForInputChar ('=')) {
          scanner_action_formerCompSupEgal (att_valeur) ;
          mCurrentTokenCode = lexiqueBDD_1_comp ;
        }else{
          scanner_action_formerCompSup (att_valeur) ;
          mCurrentTokenCode = lexiqueBDD_1_comp ;
        }
      }else if (testForInputChar ('$')) {
        do {
          if (testForInputChar ('\x1', '\t') ||
              testForInputChar ('\v', '\xFF')) {
          }else{
            loop_ = false ;
          }
        }while (loop_) ;
        loop_ = true ;
        if (testForInputChar ('\n') ||
            testForInputChar ('\0')) {
        }else{
          lexicalError (gErrorMessage_0) ;
        }
      }else if (testForInputChar ('\x1', ' ')) {
      }else if (testForInputChar ('\0')) { // End of source text ? 
        mCurrentTokenCode = lexiqueBDD_1_ ; // Empty string code
      }else{ // Unknown input character
        lexicalError ("Unknown character") ;
      }
    }catch (const C_lexicalErrorException &) {
      mCurrentTokenCode = -1 ; // No token
      advance () ; // ... go throught unknown character
      if (inPropagateLexicaleErrorException) {
        throw ;
      }
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                            Styles definition                              *
//                                                                           *
//---------------------------------------------------------------------------*

sint32 lexiqueBDD::getStylesCount (void) {
  return 6 ;
}

//---------------------------------------------------------------------------*

const char * lexiqueBDD::getStyleName (const sint32 inIndex) {
  const char * kStylesArray [7] = {"Default style", "Identifiers", "Key words", "String constants", "Delimitors", "Integer constants", NULL} ;
  return (inIndex < 6) ? kStylesArray [inIndex] : NULL ;
} ;

//---------------------------------------------------------------------------*

uint8 lexiqueBDD::
terminalStyleIndex (const sint32 inTerminal) {
  static const uint8 kTerminalSymbolStyles [48] = {0,
    5 /* lexiqueBDD_1_nombre */,
    1 /* lexiqueBDD_1_id */,
    3 /* lexiqueBDD_1_string */,
    4 /* lexiqueBDD_1_comp */,
    4 /* lexiqueBDD_1__28 */,
    4 /* lexiqueBDD_1__29 */,
    4 /* lexiqueBDD_1__7B */,
    4 /* lexiqueBDD_1__7D */,
    4 /* lexiqueBDD_1__5B */,
    4 /* lexiqueBDD_1__5D */,
    4 /* lexiqueBDD_1__3A_3D */,
    4 /* lexiqueBDD_1__3A */,
    4 /* lexiqueBDD_1__2E */,
    4 /* lexiqueBDD_1__2E_2E */,
    4 /* lexiqueBDD_1__3A_3A */,
    4 /* lexiqueBDD_1__2B_3D */,
    4 /* lexiqueBDD_1__2D_3D */,
    4 /* lexiqueBDD_1__2D_3E */,
    4 /* lexiqueBDD_1__26 */,
    4 /* lexiqueBDD_1__7C */,
    4 /* lexiqueBDD_1__7E */,
    4 /* lexiqueBDD_1__2C */,
    4 /* lexiqueBDD_1__3F */,
    4 /* lexiqueBDD_1__21 */,
    4 /* lexiqueBDD_1__3B */,
    4 /* lexiqueBDD_1__23 */,
    2 /* lexiqueBDD_1_ite_5Fcache */,
    2 /* lexiqueBDD_1_and_5Fcache */,
    2 /* lexiqueBDD_1_use_5Fand */,
    2 /* lexiqueBDD_1_use_5Fite */,
    2 /* lexiqueBDD_1_use_5Fand_5Fite */,
    2 /* lexiqueBDD_1_map */,
    2 /* lexiqueBDD_1_dimension */,
    2 /* lexiqueBDD_1_bdd */,
    2 /* lexiqueBDD_1_domain */,
    2 /* lexiqueBDD_1_bool */,
    2 /* lexiqueBDD_1_record */,
    2 /* lexiqueBDD_1_true */,
    2 /* lexiqueBDD_1_false */,
    2 /* lexiqueBDD_1_display */,
    2 /* lexiqueBDD_1_include */,
    2 /* lexiqueBDD_1_dump */,
    2 /* lexiqueBDD_1_verify */,
    2 /* lexiqueBDD_1_end */,
    2 /* lexiqueBDD_1_if */,
    2 /* lexiqueBDD_1_then */,
    2 /* lexiqueBDD_1_else */
  } ;
  return kTerminalSymbolStyles [inTerminal] ;
}

//--- START OF USER ZONE 2

//---------------------------------------------------------------------*

void lexiqueBDD::
scanner_action_formerCompEgal (unsigned long & ioValue) {
  ioValue = C_BDD::kEqual ;
}

//---------------------------------------------------------------------*

void lexiqueBDD::
scanner_action_formerCompNonEgal (unsigned long & ioValue) {
  ioValue = C_BDD::kNonEqual ;
}

//---------------------------------------------------------------------*

void lexiqueBDD::
scanner_action_formerCompInfEgal (unsigned long & ioValue) {
  ioValue = C_BDD::kLowerOrEqual ;
}

//---------------------------------------------------------------------*

void lexiqueBDD::
scanner_action_formerCompInf (unsigned long & ioValue) {
  ioValue = C_BDD::kStrictLower ;
}

//---------------------------------------------------------------------*

void lexiqueBDD::
scanner_action_formerCompSupEgal (unsigned long & ioValue) {
  ioValue = C_BDD::kGreaterOrEqual ;
}

//---------------------------------------------------------------------*

void lexiqueBDD::
scanner_action_formerCompSup (unsigned long & ioValue) {
  ioValue = C_BDD::kStrictGreater ;
}

//---------------------------------------------------------------------*


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*

