//---------------------------------------------------------------------------*
//                                                                           *
//                         File 'semantiqueBDD.cpp'                          *
//         Generated by version GALGAS_BETA_VERSION (LL(1) grammar)          *
//                       june 7th, 2006, at 11h53'34"                        *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

#include "utilities/MF_MemoryControl.h"
#include "files/C_TextFileWrite.h"
#include "semantiqueBDD.h"

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  static const char gGGSsourceFile [] = "semantiqueBDD.ggs" ;
  #define SOURCE_FILE_AT_LINE(line) , gGGSsourceFile, line
#else
  #define SOURCE_FILE_AT_LINE(line) 
#endif


//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//                     abstract class 'cPtr_typeDomain'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeDomain::
cPtr_typeDomain (LOCATION_ARGS)
:C_GGS_Object (THERE) {
}

//---------------------------------------------------------------------------*

void cPtr_typeDomain::
appendForDescription (C_Lexique & /* _inLexique */,
                      C_String & ioString
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeDomain:" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeDomain
::static_string_message_messageDomainType (void) {
  return "any domain" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeDomain::
message_messageDomainType (void) const {
  return "any domain" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_typeDomain'                        *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeDomain::
GGS_typeDomain (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeDomain::
GGS_typeDomain (const GGS_typeDomain & inOperand) {
  mPointer = (cPtr_typeDomain *) NULL ;
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeDomain::
~GGS_typeDomain (void) {
  macroDetachPointer (mPointer, cPtr_typeDomain) ;
}

//---------------------------------------------------------------------------*

void GGS_typeDomain::
operator = (const GGS_typeDomain & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeDomain * GGS_typeDomain::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return mPointer ;  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_typeDomain::
reader_messageDomainType (C_Lexique & /* _inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  return GGS_string (mPointer != NULL, C_String ((mPointer == NULL) ? "" : mPointer->message_messageDomainType ())) ;
}

//---------------------------------------------------------------------------*

void GGS_typeDomain::
drop_operation (void) {
  macroDetachPointer (mPointer, cPtr_typeDomain) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeDomain::
reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<class @typeDomain" ;
  if (isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'typeDirectDomain'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeDirectDomain::cPtr_typeDirectDomain (const GGS_luint & argument_0,
                                const GGS_luint & argument_1,
                                const GGS_luint & argument_2 COMMA_LOCATION_ARGS)
:cPtr_typeDomain (THERE),
mLowBound (argument_0),
mHighBound (argument_1),
mBitsCount (argument_2) {
}


const char * cPtr_typeDirectDomain::message_messageDomainType (void) const {
  return "an interval domain" ;
}

const char * cPtr_typeDirectDomain::static_string_message_messageDomainType (void) {
  return "an interval domain" ;
}

//---------------------------------------------------------------------------*

void cPtr_typeDirectDomain::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeDirectDomain:"
           << mLowBound.reader_description  (_inLexique COMMA_THERE)
           << mHighBound.reader_description  (_inLexique COMMA_THERE)
           << mBitsCount.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeDirectDomain'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeDirectDomain::
GGS_typeDirectDomain (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeDirectDomain GGS_typeDirectDomain::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_luint & argument_0,
                 const GGS_luint & argument_1,
                 const GGS_luint & argument_2 COMMA_LOCATION_ARGS) {
  cPtr_typeDirectDomain * _ptr = (cPtr_typeDirectDomain *) NULL ;
  macroMyNew (_ptr, cPtr_typeDirectDomain (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  GGS_typeDirectDomain result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeDirectDomain * GGS_typeDirectDomain::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeDirectDomain *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeDirectDomain *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_typeDirectDomain::
reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<class @typeDirectDomain" ;
  if (isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class map 'typeDomainMap'                          *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeDomainMap::
elementOf_GGS_typeDomainMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_typeDomainMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeDomainMap::
appendForMapDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "["
           << mKey.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "->" ;
  ioString << mInfo.mDomain.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_typeDomainMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_typeDomainMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_typeDomainMap * info = (e_typeDomainMap *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_typeDomainMap GGS_typeDomainMap::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeDomainMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeDomainMap::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_typeDomainMap::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_typeDomain &  inParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  sint32 index = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_typeDomainMap info  ;
    info.mDomain = inParameter0 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
    if (index < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeDomainMap::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_typeDomain   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop_operation () ;
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mDomain ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeDomainMap::method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_typeDomain   & outParameter0 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 "the '%K' domain is not declared",
                 inKey,
                 outParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeDomainMap::
method_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_typeDomain & inParameter0 COMMA_LOCATION_ARGS) {
  insertElement (_inLexique,
                 "the '%K' domain has been already declared",
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_typeDomainMap GGS_typeDomainMap::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_typeDomainMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeDomainMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mNextIndex = inMapToOverride.mSharedMapRoot->mNextIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeDomainMap GGS_typeDomainMap::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeDomainMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeDomainMap::reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<map @typeDomainMap " ;
  if (isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, s COMMA_THERE) ;
      p = p->nextObject () ;
    }
  }else{
    s << "not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'typeRecordDomain'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeRecordDomain::cPtr_typeRecordDomain (const GGS_typeDomainMap & argument_0 COMMA_LOCATION_ARGS)
:cPtr_typeDomain (THERE),
mRecordMap (argument_0) {
}


const char * cPtr_typeRecordDomain::message_messageDomainType (void) const {
  return "a record domain" ;
}

const char * cPtr_typeRecordDomain::static_string_message_messageDomainType (void) {
  return "a record domain" ;
}

//---------------------------------------------------------------------------*

void cPtr_typeRecordDomain::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeRecordDomain:"
           << mRecordMap.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeRecordDomain'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeRecordDomain::
GGS_typeRecordDomain (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeRecordDomain GGS_typeRecordDomain::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_typeDomainMap & argument_0 COMMA_LOCATION_ARGS) {
  cPtr_typeRecordDomain * _ptr = (cPtr_typeRecordDomain *) NULL ;
  macroMyNew (_ptr, cPtr_typeRecordDomain (argument_0 COMMA_THERE)) ;
  GGS_typeRecordDomain result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeRecordDomain * GGS_typeRecordDomain::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeRecordDomain *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeRecordDomain *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_typeRecordDomain::
reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<class @typeRecordDomain" ;
  if (isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@typeFormalArgumentsList'                 *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeFormalArgumentsList::
elementOf_GGS_typeFormalArgumentsList (const GGS_luint & argument_0,
                                const GGS_luint & argument_1,
                                const GGS_luint & argument_2,
                                const GGS_luint & argument_3):
mNextItem (NULL),
mVariableIndex (argument_0),
mVariableBitSize (argument_1),
mLowBound (argument_2),
mHighBound (argument_3) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeFormalArgumentsList::
appendForListDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "[" ;
  ioString << mVariableIndex.reader_description  (_inLexique COMMA_THERE) ;
  ioString << mVariableBitSize.reader_description  (_inLexique COMMA_THERE) ;
  ioString << mLowBound.reader_description  (_inLexique COMMA_THERE) ;
  ioString << mHighBound.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     List '@typeFormalArgumentsList'                       *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeFormalArgumentsList::cRootList::cRootList (void):
mFirstItem (NULL),
mLastItem (NULL),
mListLength (0),
mCountReference (1) {
}

//---------------------------------------------------------------------------*

GGS_typeFormalArgumentsList::cRootList::~cRootList (void) {
  while (mFirstItem != NULL) {
    element_type * p = mFirstItem->nextObject () ;
    macroMyDelete (mFirstItem, element_type) ;
    mFirstItem = p ;
  }
}

//---------------------------------------------------------------------------*

GGS_typeFormalArgumentsList::GGS_typeFormalArgumentsList (void) { // Default Constructor
  mRoot = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeFormalArgumentsList::~GGS_typeFormalArgumentsList (void) {
  drop_operation () ;
}

//---------------------------------------------------------------------------*

GGS_typeFormalArgumentsList::
GGS_typeFormalArgumentsList (const GGS_typeFormalArgumentsList & inSource) {
  mRoot = inSource.mRoot ;
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    mRoot->mCountReference ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeFormalArgumentsList::
operator = (const GGS_typeFormalArgumentsList & inSource) {
  if (this != & inSource) {
    drop_operation () ;
    mRoot = inSource.mRoot ;
    if (mRoot != NULL) {
      macroValidPointer (mRoot) ;
      mRoot->mCountReference ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeFormalArgumentsList::element_type * GGS_typeFormalArgumentsList::
firstObject (void) const {
  return (mRoot == NULL) ? NULL : mRoot->mFirstItem ;
}

//---------------------------------------------------------------------------*

void GGS_typeFormalArgumentsList::
internalAppendItem (const GGS_luint & argument_0,
                    const GGS_luint & argument_1,
                    const GGS_luint & argument_2,
                    const GGS_luint & argument_3) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2,
                                argument_3)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mRoot->mLastItem == NULL) {
      mRoot->mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mRoot->mLastItem) ;
      mRoot->mLastItem->mNextItem = nouvelElement ;
    }
    mRoot->mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mRoot->mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeFormalArgumentsList::
addAssign_operation (const GGS_luint & argument_0,
                                const GGS_luint & argument_1,
                                const GGS_luint & argument_2,
                                const GGS_luint & argument_3) {
  if (isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0,
                                argument_1,
                                argument_2,
                                argument_3) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeFormalArgumentsList::
insulateList (void) {
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    if (mRoot->mCountReference > 1) {
      element_type * p = mRoot->mFirstItem ;
      mRoot->mCountReference -- ;
      mRoot = NULL ;
      macroMyNew (mRoot, cRootList) ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->mVariableIndex,
                                p->mVariableBitSize,
                                p->mLowBound,
                                p->mHighBound) ;
        p = p->mNextItem ;
      }
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeFormalArgumentsList  GGS_typeFormalArgumentsList::
constructor_emptyList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeFormalArgumentsList result ;
  macroMyNew (result.mRoot, cRootList) ;
  return result ;
}

//---------------------------------------------------------------------------*

sint32 GGS_typeFormalArgumentsList::
count (void) const {
  return (mRoot == NULL) ? 0 : mRoot->mListLength ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeFormalArgumentsList::
reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<list @typeFormalArgumentsList" ;
  if (isBuilt ()) {
    s << " " << mRoot->mListLength << " object" << ((mRoot->mListLength > 1) ? "s " : " ") ;
    element_type * p = mRoot->mFirstItem ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForListDescription (_inLexique, s COMMA_THERE) ;
      p = p->mNextItem ;
    }
  }else{
    s << "not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

GGS_uint GGS_typeFormalArgumentsList::
reader_length (C_Lexique & /* inLexique */
               COMMA_UNUSED_LOCATION_ARGS) const {
  return GGS_uint (mRoot != NULL,
                   (mRoot == NULL) ? 0 : (uint32) mRoot->mListLength) ;
}

//---------------------------------------------------------------------------*

void GGS_typeFormalArgumentsList::
drop_operation (void) {
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    if (mRoot->mCountReference == 1) {
      macroMyDelete (mRoot, cRootList) ;
    }else{
      mRoot->mCountReference -- ;
      mRoot = NULL ;
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@typeActualArgumentsList'                 *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeActualArgumentsList::
elementOf_GGS_typeActualArgumentsList (const GGS_luint & argument_0,
                                const GGS_luint & argument_1,
                                const GGS_luint & argument_2,
                                const GGS_luint & argument_3,
                                const GGS_location & argument_4):
mNextItem (NULL),
mVariableIndex (argument_0),
mVariableBitSize (argument_1),
mLowBound (argument_2),
mHighBound (argument_3),
mErrorLocation (argument_4) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeActualArgumentsList::
appendForListDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "[" ;
  ioString << mVariableIndex.reader_description  (_inLexique COMMA_THERE) ;
  ioString << mVariableBitSize.reader_description  (_inLexique COMMA_THERE) ;
  ioString << mLowBound.reader_description  (_inLexique COMMA_THERE) ;
  ioString << mHighBound.reader_description  (_inLexique COMMA_THERE) ;
  ioString << mErrorLocation.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     List '@typeActualArgumentsList'                       *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeActualArgumentsList::cRootList::cRootList (void):
mFirstItem (NULL),
mLastItem (NULL),
mListLength (0),
mCountReference (1) {
}

//---------------------------------------------------------------------------*

GGS_typeActualArgumentsList::cRootList::~cRootList (void) {
  while (mFirstItem != NULL) {
    element_type * p = mFirstItem->nextObject () ;
    macroMyDelete (mFirstItem, element_type) ;
    mFirstItem = p ;
  }
}

//---------------------------------------------------------------------------*

GGS_typeActualArgumentsList::GGS_typeActualArgumentsList (void) { // Default Constructor
  mRoot = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeActualArgumentsList::~GGS_typeActualArgumentsList (void) {
  drop_operation () ;
}

//---------------------------------------------------------------------------*

GGS_typeActualArgumentsList::
GGS_typeActualArgumentsList (const GGS_typeActualArgumentsList & inSource) {
  mRoot = inSource.mRoot ;
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    mRoot->mCountReference ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeActualArgumentsList::
operator = (const GGS_typeActualArgumentsList & inSource) {
  if (this != & inSource) {
    drop_operation () ;
    mRoot = inSource.mRoot ;
    if (mRoot != NULL) {
      macroValidPointer (mRoot) ;
      mRoot->mCountReference ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeActualArgumentsList::element_type * GGS_typeActualArgumentsList::
firstObject (void) const {
  return (mRoot == NULL) ? NULL : mRoot->mFirstItem ;
}

//---------------------------------------------------------------------------*

void GGS_typeActualArgumentsList::
internalAppendItem (const GGS_luint & argument_0,
                    const GGS_luint & argument_1,
                    const GGS_luint & argument_2,
                    const GGS_luint & argument_3,
                    const GGS_location & argument_4) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mRoot->mLastItem == NULL) {
      mRoot->mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mRoot->mLastItem) ;
      mRoot->mLastItem->mNextItem = nouvelElement ;
    }
    mRoot->mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mRoot->mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeActualArgumentsList::
addAssign_operation (const GGS_luint & argument_0,
                                const GGS_luint & argument_1,
                                const GGS_luint & argument_2,
                                const GGS_luint & argument_3,
                                const GGS_location & argument_4) {
  if (isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeActualArgumentsList::
insulateList (void) {
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    if (mRoot->mCountReference > 1) {
      element_type * p = mRoot->mFirstItem ;
      mRoot->mCountReference -- ;
      mRoot = NULL ;
      macroMyNew (mRoot, cRootList) ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->mVariableIndex,
                                p->mVariableBitSize,
                                p->mLowBound,
                                p->mHighBound,
                                p->mErrorLocation) ;
        p = p->mNextItem ;
      }
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeActualArgumentsList  GGS_typeActualArgumentsList::
constructor_emptyList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeActualArgumentsList result ;
  macroMyNew (result.mRoot, cRootList) ;
  return result ;
}

//---------------------------------------------------------------------------*

sint32 GGS_typeActualArgumentsList::
count (void) const {
  return (mRoot == NULL) ? 0 : mRoot->mListLength ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeActualArgumentsList::
reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<list @typeActualArgumentsList" ;
  if (isBuilt ()) {
    s << " " << mRoot->mListLength << " object" << ((mRoot->mListLength > 1) ? "s " : " ") ;
    element_type * p = mRoot->mFirstItem ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForListDescription (_inLexique, s COMMA_THERE) ;
      p = p->mNextItem ;
    }
  }else{
    s << "not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

GGS_uint GGS_typeActualArgumentsList::
reader_length (C_Lexique & /* inLexique */
               COMMA_UNUSED_LOCATION_ARGS) const {
  return GGS_uint (mRoot != NULL,
                   (mRoot == NULL) ? 0 : (uint32) mRoot->mListLength) ;
}

//---------------------------------------------------------------------------*

void GGS_typeActualArgumentsList::
drop_operation (void) {
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    if (mRoot->mCountReference == 1) {
      macroMyDelete (mRoot, cRootList) ;
    }else{
      mRoot->mCountReference -- ;
      mRoot = NULL ;
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//               abstract class 'cPtr_typeVariableDescriptor'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeVariableDescriptor::
cPtr_typeVariableDescriptor (LOCATION_ARGS)
:C_GGS_Object (THERE) {
}

//---------------------------------------------------------------------------*

void cPtr_typeVariableDescriptor::
appendForDescription (C_Lexique & /* _inLexique */,
                      C_String & ioString
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeVariableDescriptor:" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeVariableDescriptor
::static_string_message_variableDescriptorErrorMessage (void) {
  return "any variable" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeVariableDescriptor::
message_variableDescriptorErrorMessage (void) const {
  return "any variable" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_typeVariableDescriptor'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeVariableDescriptor::
GGS_typeVariableDescriptor (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeVariableDescriptor::
GGS_typeVariableDescriptor (const GGS_typeVariableDescriptor & inOperand) {
  mPointer = (cPtr_typeVariableDescriptor *) NULL ;
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeVariableDescriptor::
~GGS_typeVariableDescriptor (void) {
  macroDetachPointer (mPointer, cPtr_typeVariableDescriptor) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariableDescriptor::
operator = (const GGS_typeVariableDescriptor & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeVariableDescriptor * GGS_typeVariableDescriptor::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return mPointer ;  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_typeVariableDescriptor::
reader_variableDescriptorErrorMessage (C_Lexique & /* _inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  return GGS_string (mPointer != NULL, C_String ((mPointer == NULL) ? "" : mPointer->message_variableDescriptorErrorMessage ())) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariableDescriptor::
drop_operation (void) {
  macroDetachPointer (mPointer, cPtr_typeVariableDescriptor) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeVariableDescriptor::
reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<class @typeVariableDescriptor" ;
  if (isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'typeDirectVariable'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeDirectVariable::cPtr_typeDirectVariable (const GGS_luint & argument_0,
                                const GGS_luint & argument_1,
                                const GGS_luint & argument_2,
                                const GGS_luint & argument_3 COMMA_LOCATION_ARGS)
:cPtr_typeVariableDescriptor (THERE),
mIndex (argument_0),
mBitSize (argument_1),
mLowBound (argument_2),
mHighBound (argument_3) {
}


const char * cPtr_typeDirectVariable::message_variableDescriptorErrorMessage (void) const {
  return "a direct domain variable" ;
}

const char * cPtr_typeDirectVariable::static_string_message_variableDescriptorErrorMessage (void) {
  return "a direct domain variable" ;
}

//---------------------------------------------------------------------------*

void cPtr_typeDirectVariable::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeDirectVariable:"
           << mIndex.reader_description  (_inLexique COMMA_THERE)
           << mBitSize.reader_description  (_inLexique COMMA_THERE)
           << mLowBound.reader_description  (_inLexique COMMA_THERE)
           << mHighBound.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeDirectVariable'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeDirectVariable::
GGS_typeDirectVariable (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeDirectVariable GGS_typeDirectVariable::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_luint & argument_0,
                 const GGS_luint & argument_1,
                 const GGS_luint & argument_2,
                 const GGS_luint & argument_3 COMMA_LOCATION_ARGS) {
  cPtr_typeDirectVariable * _ptr = (cPtr_typeDirectVariable *) NULL ;
  macroMyNew (_ptr, cPtr_typeDirectVariable (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  GGS_typeDirectVariable result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeDirectVariable * GGS_typeDirectVariable::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeDirectVariable *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeDirectVariable *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_typeDirectVariable::
reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<class @typeDirectVariable" ;
  if (isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class map 'typeTableVariablesBool'                     *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeTableVariablesBool::
elementOf_GGS_typeTableVariablesBool (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_typeTableVariablesBool & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeTableVariablesBool::
appendForMapDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "["
           << mKey.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "->" ;
  ioString << mInfo.mVariableDescriptor.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_typeTableVariablesBool::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_typeTableVariablesBool *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_typeTableVariablesBool * info = (e_typeTableVariablesBool *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_typeTableVariablesBool GGS_typeTableVariablesBool::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeTableVariablesBool result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableVariablesBool::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableVariablesBool::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_typeVariableDescriptor &  inParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  sint32 index = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_typeTableVariablesBool info  ;
    info.mVariableDescriptor = inParameter0 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
    if (index < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTableVariablesBool::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_typeVariableDescriptor   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop_operation () ;
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mVariableDescriptor ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTableVariablesBool::method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_typeVariableDescriptor   & outParameter0 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 "the '%K' variable is not declared",
                 inKey,
                 outParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableVariablesBool::
method_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_typeVariableDescriptor & inParameter0 COMMA_LOCATION_ARGS) {
  insertElement (_inLexique,
                 "the '%K' variable has been already declared",
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_typeTableVariablesBool GGS_typeTableVariablesBool::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_typeTableVariablesBool & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeTableVariablesBool result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mNextIndex = inMapToOverride.mSharedMapRoot->mNextIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeTableVariablesBool GGS_typeTableVariablesBool::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeTableVariablesBool result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeTableVariablesBool::reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<map @typeTableVariablesBool " ;
  if (isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, s COMMA_THERE) ;
      p = p->nextObject () ;
    }
  }else{
    s << "not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'typeRecordVariable'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeRecordVariable::cPtr_typeRecordVariable (const GGS_typeTableVariablesBool & argument_0 COMMA_LOCATION_ARGS)
:cPtr_typeVariableDescriptor (THERE),
mMap (argument_0) {
}


const char * cPtr_typeRecordVariable::message_variableDescriptorErrorMessage (void) const {
  return "a record domain variable" ;
}

const char * cPtr_typeRecordVariable::static_string_message_variableDescriptorErrorMessage (void) {
  return "a record domain variable" ;
}

//---------------------------------------------------------------------------*

void cPtr_typeRecordVariable::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeRecordVariable:"
           << mMap.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeRecordVariable'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeRecordVariable::
GGS_typeRecordVariable (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeRecordVariable GGS_typeRecordVariable::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_typeTableVariablesBool & argument_0 COMMA_LOCATION_ARGS) {
  cPtr_typeRecordVariable * _ptr = (cPtr_typeRecordVariable *) NULL ;
  macroMyNew (_ptr, cPtr_typeRecordVariable (argument_0 COMMA_THERE)) ;
  GGS_typeRecordVariable result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeRecordVariable * GGS_typeRecordVariable::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeRecordVariable *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeRecordVariable *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_typeRecordVariable::
reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<class @typeRecordVariable" ;
  if (isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class map 'typeTableFormules'                        *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeTableFormules::
elementOf_GGS_typeTableFormules (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_typeTableFormules & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeTableFormules::
appendForMapDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "["
           << mKey.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "->" ;
  ioString << mInfo.aListeArgsFormelsBool.reader_description  (_inLexique COMMA_THERE) ;
  ioString << mInfo.aBDD.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_typeTableFormules::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_typeTableFormules *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_typeTableFormules * info = (e_typeTableFormules *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_typeTableFormules GGS_typeTableFormules::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeTableFormules result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableFormules::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableFormules::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_typeFormalArgumentsList &  inParameter0,
               const GGS_bdd&  inParameter1,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  sint32 index = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inParameter1.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_typeTableFormules info  ;
    info.aListeArgsFormelsBool = inParameter0 ;
    info.aBDD = inParameter1 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
    if (index < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTableFormules::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_typeFormalArgumentsList   & outParameter0,
               GGS_bdd  & outParameter1,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop_operation () ;
    outParameter1.drop_operation () ;
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.aListeArgsFormelsBool ;
    outParameter1 = node->mInfo.aBDD ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTableFormules::method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_typeFormalArgumentsList   & outParameter0,
                                GGS_bdd  & outParameter1 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 "the '#%K' formula is not defined",
                 inKey,
                 outParameter0,
                 outParameter1,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableFormules::method_searchKeyGetIndex (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                GGS_typeFormalArgumentsList   & outParameter0,
                                GGS_bdd  & outParameter1 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 "the '#%K' formula is not defined",
                 inKey,
                 outParameter0,
                 outParameter1,
                 & outIndex
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableFormules::
method_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_typeFormalArgumentsList & inParameter0,
                                const GGS_bdd& inParameter1 COMMA_LOCATION_ARGS) {
  insertElement (_inLexique,
                 "the '#%K' formula is already defined",
                 inKey,
                 inParameter0,
                 inParameter1,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableFormules::
method_insertKeyGetIndex (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_typeFormalArgumentsList & inParameter0,
                                const GGS_bdd& inParameter1 COMMA_LOCATION_ARGS) {
  insertElement (_inLexique,
                 "the '#%K' formula is already defined",
                 inKey,
                 inParameter0,
                 inParameter1,
                 & outIndex
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_typeTableFormules GGS_typeTableFormules::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_typeTableFormules & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeTableFormules result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mNextIndex = inMapToOverride.mSharedMapRoot->mNextIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeTableFormules GGS_typeTableFormules::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeTableFormules result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeTableFormules::reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<map @typeTableFormules " ;
  if (isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, s COMMA_THERE) ;
      p = p->nextObject () ;
    }
  }else{
    s << "not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    abstract class 'cPtr_typeFormule'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeFormule::
cPtr_typeFormule (LOCATION_ARGS)
:C_GGS_Object (THERE) {
}

//---------------------------------------------------------------------------*

void cPtr_typeFormule::
appendForDescription (C_Lexique & /* _inLexique */,
                      C_String & ioString
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeFormule:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_typeFormule'                       *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeFormule::
GGS_typeFormule (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeFormule::
GGS_typeFormule (const GGS_typeFormule & inOperand) {
  mPointer = (cPtr_typeFormule *) NULL ;
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeFormule::
~GGS_typeFormule (void) {
  macroDetachPointer (mPointer, cPtr_typeFormule) ;
}

//---------------------------------------------------------------------------*

void GGS_typeFormule::
operator = (const GGS_typeFormule & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeFormule * GGS_typeFormule::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return mPointer ;  }
#endif

//---------------------------------------------------------------------------*

void GGS_typeFormule::
drop_operation (void) {
  macroDetachPointer (mPointer, cPtr_typeFormule) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeFormule::
reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<class @typeFormule" ;
  if (isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'typeFormuleTrue'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeFormuleTrue::cPtr_typeFormuleTrue (LOCATION_ARGS)
:cPtr_typeFormule (THERE) {
}

//---------------------------------------------------------------------------*

void cPtr_typeFormuleTrue::
appendForDescription (C_Lexique & /* _inLexique */,
                      C_String & ioString
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeFormuleTrue:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeFormuleTrue'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeFormuleTrue::
GGS_typeFormuleTrue (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeFormuleTrue GGS_typeFormuleTrue::
constructor_new (C_Lexique & /* inLexique */ COMMA_LOCATION_ARGS) {
  cPtr_typeFormuleTrue * _ptr = (cPtr_typeFormuleTrue *) NULL ;
  macroMyNew (_ptr, cPtr_typeFormuleTrue (THERE)) ;
  GGS_typeFormuleTrue result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeFormuleTrue * GGS_typeFormuleTrue::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFormuleTrue *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeFormuleTrue *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_typeFormuleTrue::
reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<class @typeFormuleTrue" ;
  if (isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'typeFormuleFalse'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeFormuleFalse::cPtr_typeFormuleFalse (LOCATION_ARGS)
:cPtr_typeFormule (THERE) {
}

//---------------------------------------------------------------------------*

void cPtr_typeFormuleFalse::
appendForDescription (C_Lexique & /* _inLexique */,
                      C_String & ioString
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeFormuleFalse:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeFormuleFalse'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeFormuleFalse::
GGS_typeFormuleFalse (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeFormuleFalse GGS_typeFormuleFalse::
constructor_new (C_Lexique & /* inLexique */ COMMA_LOCATION_ARGS) {
  cPtr_typeFormuleFalse * _ptr = (cPtr_typeFormuleFalse *) NULL ;
  macroMyNew (_ptr, cPtr_typeFormuleFalse (THERE)) ;
  GGS_typeFormuleFalse result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeFormuleFalse * GGS_typeFormuleFalse::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFormuleFalse *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeFormuleFalse *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_typeFormuleFalse::
reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<class @typeFormuleFalse" ;
  if (isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'typeFormuleVar'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeFormuleVar::cPtr_typeFormuleVar (const GGS_luint & argument_0,
                                const GGS_luint & argument_1,
                                const GGS_luint & argument_2 COMMA_LOCATION_ARGS)
:cPtr_typeFormule (THERE),
mNumeroVariable (argument_0),
mLowBound (argument_1),
mHighBound (argument_2) {
}

//---------------------------------------------------------------------------*

void cPtr_typeFormuleVar::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeFormuleVar:"
           << mNumeroVariable.reader_description  (_inLexique COMMA_THERE)
           << mLowBound.reader_description  (_inLexique COMMA_THERE)
           << mHighBound.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeFormuleVar'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeFormuleVar::
GGS_typeFormuleVar (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeFormuleVar GGS_typeFormuleVar::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_luint & argument_0,
                 const GGS_luint & argument_1,
                 const GGS_luint & argument_2 COMMA_LOCATION_ARGS) {
  cPtr_typeFormuleVar * _ptr = (cPtr_typeFormuleVar *) NULL ;
  macroMyNew (_ptr, cPtr_typeFormuleVar (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  GGS_typeFormuleVar result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeFormuleVar * GGS_typeFormuleVar::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFormuleVar *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeFormuleVar *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_typeFormuleVar::
reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<class @typeFormuleVar" ;
  if (isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'typeFormuleFor'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeFormuleFor::cPtr_typeFormuleFor (const GGS_luint & argument_0,
                                const GGS_typeActualArgumentsList & argument_1,
                                const GGS_bdd& argument_2,
                                const GGS_lbool & argument_3 COMMA_LOCATION_ARGS)
:cPtr_typeFormule (THERE),
mNumeroFormule (argument_0),
mListeArgsBool (argument_1),
mFormuleTraduite (argument_2),
mEstFormuleCourante (argument_3) {
}

//---------------------------------------------------------------------------*

void cPtr_typeFormuleFor::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeFormuleFor:"
           << mNumeroFormule.reader_description  (_inLexique COMMA_THERE)
           << mListeArgsBool.reader_description  (_inLexique COMMA_THERE)
           << mFormuleTraduite.reader_description  (_inLexique COMMA_THERE)
           << mEstFormuleCourante.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeFormuleFor'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeFormuleFor::
GGS_typeFormuleFor (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeFormuleFor GGS_typeFormuleFor::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_luint & argument_0,
                 const GGS_typeActualArgumentsList & argument_1,
                 const GGS_bdd& argument_2,
                 const GGS_lbool & argument_3 COMMA_LOCATION_ARGS) {
  cPtr_typeFormuleFor * _ptr = (cPtr_typeFormuleFor *) NULL ;
  macroMyNew (_ptr, cPtr_typeFormuleFor (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  GGS_typeFormuleFor result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeFormuleFor * GGS_typeFormuleFor::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFormuleFor *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeFormuleFor *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_typeFormuleFor::
reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<class @typeFormuleFor" ;
  if (isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'typeFormuleNon'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeFormuleNon::cPtr_typeFormuleNon (const GGS_typeFormule & argument_0 COMMA_LOCATION_ARGS)
:cPtr_typeFormule (THERE),
mOperand (argument_0) {
}

//---------------------------------------------------------------------------*

void cPtr_typeFormuleNon::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeFormuleNon:"
           << mOperand.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeFormuleNon'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeFormuleNon::
GGS_typeFormuleNon (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeFormuleNon GGS_typeFormuleNon::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_typeFormule & argument_0 COMMA_LOCATION_ARGS) {
  cPtr_typeFormuleNon * _ptr = (cPtr_typeFormuleNon *) NULL ;
  macroMyNew (_ptr, cPtr_typeFormuleNon (argument_0 COMMA_THERE)) ;
  GGS_typeFormuleNon result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeFormuleNon * GGS_typeFormuleNon::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFormuleNon *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeFormuleNon *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_typeFormuleNon::
reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<class @typeFormuleNon" ;
  if (isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'typeFormuleEt'                            *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeFormuleEt::cPtr_typeFormuleEt (const GGS_typeFormule & argument_0,
                                const GGS_typeFormule & argument_1 COMMA_LOCATION_ARGS)
:cPtr_typeFormule (THERE),
mOperand1 (argument_0),
mOperand2 (argument_1) {
}

//---------------------------------------------------------------------------*

void cPtr_typeFormuleEt::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeFormuleEt:"
           << mOperand1.reader_description  (_inLexique COMMA_THERE)
           << mOperand2.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_typeFormuleEt'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeFormuleEt::
GGS_typeFormuleEt (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeFormuleEt GGS_typeFormuleEt::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_typeFormule & argument_0,
                 const GGS_typeFormule & argument_1 COMMA_LOCATION_ARGS) {
  cPtr_typeFormuleEt * _ptr = (cPtr_typeFormuleEt *) NULL ;
  macroMyNew (_ptr, cPtr_typeFormuleEt (argument_0,
                                argument_1 COMMA_THERE)) ;
  GGS_typeFormuleEt result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeFormuleEt * GGS_typeFormuleEt::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFormuleEt *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeFormuleEt *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_typeFormuleEt::
reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<class @typeFormuleEt" ;
  if (isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'typeFormuleIte'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeFormuleIte::cPtr_typeFormuleIte (const GGS_typeFormule & argument_0,
                                const GGS_typeFormule & argument_1,
                                const GGS_typeFormule & argument_2 COMMA_LOCATION_ARGS)
:cPtr_typeFormule (THERE),
mOperand1 (argument_0),
mOperand2 (argument_1),
mOperand3 (argument_2) {
}

//---------------------------------------------------------------------------*

void cPtr_typeFormuleIte::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeFormuleIte:"
           << mOperand1.reader_description  (_inLexique COMMA_THERE)
           << mOperand2.reader_description  (_inLexique COMMA_THERE)
           << mOperand3.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeFormuleIte'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeFormuleIte::
GGS_typeFormuleIte (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeFormuleIte GGS_typeFormuleIte::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_typeFormule & argument_0,
                 const GGS_typeFormule & argument_1,
                 const GGS_typeFormule & argument_2 COMMA_LOCATION_ARGS) {
  cPtr_typeFormuleIte * _ptr = (cPtr_typeFormuleIte *) NULL ;
  macroMyNew (_ptr, cPtr_typeFormuleIte (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  GGS_typeFormuleIte result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeFormuleIte * GGS_typeFormuleIte::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFormuleIte *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeFormuleIte *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_typeFormuleIte::
reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<class @typeFormuleIte" ;
  if (isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'typeFormuleOu'                            *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeFormuleOu::cPtr_typeFormuleOu (const GGS_typeFormule & argument_0,
                                const GGS_typeFormule & argument_1 COMMA_LOCATION_ARGS)
:cPtr_typeFormule (THERE),
mOperand1 (argument_0),
mOperand2 (argument_1) {
}

//---------------------------------------------------------------------------*

void cPtr_typeFormuleOu::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeFormuleOu:"
           << mOperand1.reader_description  (_inLexique COMMA_THERE)
           << mOperand2.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_typeFormuleOu'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeFormuleOu::
GGS_typeFormuleOu (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeFormuleOu GGS_typeFormuleOu::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_typeFormule & argument_0,
                 const GGS_typeFormule & argument_1 COMMA_LOCATION_ARGS) {
  cPtr_typeFormuleOu * _ptr = (cPtr_typeFormuleOu *) NULL ;
  macroMyNew (_ptr, cPtr_typeFormuleOu (argument_0,
                                argument_1 COMMA_THERE)) ;
  GGS_typeFormuleOu result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeFormuleOu * GGS_typeFormuleOu::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFormuleOu *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeFormuleOu *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_typeFormuleOu::
reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<class @typeFormuleOu" ;
  if (isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'typeFormuleImplique'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeFormuleImplique::cPtr_typeFormuleImplique (const GGS_typeFormule & argument_0,
                                const GGS_typeFormule & argument_1 COMMA_LOCATION_ARGS)
:cPtr_typeFormule (THERE),
mOperand1 (argument_0),
mOperand2 (argument_1) {
}

//---------------------------------------------------------------------------*

void cPtr_typeFormuleImplique::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeFormuleImplique:"
           << mOperand1.reader_description  (_inLexique COMMA_THERE)
           << mOperand2.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeFormuleImplique'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeFormuleImplique::
GGS_typeFormuleImplique (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeFormuleImplique GGS_typeFormuleImplique::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_typeFormule & argument_0,
                 const GGS_typeFormule & argument_1 COMMA_LOCATION_ARGS) {
  cPtr_typeFormuleImplique * _ptr = (cPtr_typeFormuleImplique *) NULL ;
  macroMyNew (_ptr, cPtr_typeFormuleImplique (argument_0,
                                argument_1 COMMA_THERE)) ;
  GGS_typeFormuleImplique result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeFormuleImplique * GGS_typeFormuleImplique::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFormuleImplique *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeFormuleImplique *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_typeFormuleImplique::
reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<class @typeFormuleImplique" ;
  if (isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'typeComparaisonFormules'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeComparaisonFormules::cPtr_typeComparaisonFormules (const GGS_luint & argument_0,
                                const GGS_typeFormule & argument_1,
                                const GGS_typeFormule & argument_2 COMMA_LOCATION_ARGS)
:cPtr_typeFormule (THERE),
mComparaison (argument_0),
mOperand1 (argument_1),
mOperand2 (argument_2) {
}

//---------------------------------------------------------------------------*

void cPtr_typeComparaisonFormules::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeComparaisonFormules:"
           << mComparaison.reader_description  (_inLexique COMMA_THERE)
           << mOperand1.reader_description  (_inLexique COMMA_THERE)
           << mOperand2.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_typeComparaisonFormules'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeComparaisonFormules::
GGS_typeComparaisonFormules (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeComparaisonFormules GGS_typeComparaisonFormules::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_luint & argument_0,
                 const GGS_typeFormule & argument_1,
                 const GGS_typeFormule & argument_2 COMMA_LOCATION_ARGS) {
  cPtr_typeComparaisonFormules * _ptr = (cPtr_typeComparaisonFormules *) NULL ;
  macroMyNew (_ptr, cPtr_typeComparaisonFormules (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  GGS_typeComparaisonFormules result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeComparaisonFormules * GGS_typeComparaisonFormules::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeComparaisonFormules *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeComparaisonFormules *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_typeComparaisonFormules::
reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<class @typeComparaisonFormules" ;
  if (isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'typeFormuleExist'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeFormuleExist::cPtr_typeFormuleExist (const GGS_typeFormalArgumentsList & argument_0,
                                const GGS_typeFormule & argument_1,
                                const GGS_bdd& argument_2 COMMA_LOCATION_ARGS)
:cPtr_typeFormule (THERE),
mListeArgsBooleens (argument_0),
mOperand (argument_1),
mContraints (argument_2) {
}

//---------------------------------------------------------------------------*

void cPtr_typeFormuleExist::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeFormuleExist:"
           << mListeArgsBooleens.reader_description  (_inLexique COMMA_THERE)
           << mOperand.reader_description  (_inLexique COMMA_THERE)
           << mContraints.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeFormuleExist'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeFormuleExist::
GGS_typeFormuleExist (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeFormuleExist GGS_typeFormuleExist::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_typeFormalArgumentsList & argument_0,
                 const GGS_typeFormule & argument_1,
                 const GGS_bdd& argument_2 COMMA_LOCATION_ARGS) {
  cPtr_typeFormuleExist * _ptr = (cPtr_typeFormuleExist *) NULL ;
  macroMyNew (_ptr, cPtr_typeFormuleExist (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  GGS_typeFormuleExist result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeFormuleExist * GGS_typeFormuleExist::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFormuleExist *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeFormuleExist *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_typeFormuleExist::
reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<class @typeFormuleExist" ;
  if (isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'typeFormuleComparaisonValeur'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeFormuleComparaisonValeur::cPtr_typeFormuleComparaisonValeur (const GGS_luint & argument_0,
                                const GGS_luint & argument_1,
                                const GGS_luint & argument_2,
                                const GGS_luint & argument_3,
                                const GGS_luint & argument_4,
                                const GGS_luint & argument_5 COMMA_LOCATION_ARGS)
:cPtr_typeFormule (THERE),
mIndiceBDD (argument_0),
mDimension (argument_1),
mLowBound (argument_2),
mHighBound (argument_3),
mComparaison (argument_4),
mValeur (argument_5) {
}

//---------------------------------------------------------------------------*

void cPtr_typeFormuleComparaisonValeur::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeFormuleComparaisonValeur:"
           << mIndiceBDD.reader_description  (_inLexique COMMA_THERE)
           << mDimension.reader_description  (_inLexique COMMA_THERE)
           << mLowBound.reader_description  (_inLexique COMMA_THERE)
           << mHighBound.reader_description  (_inLexique COMMA_THERE)
           << mComparaison.reader_description  (_inLexique COMMA_THERE)
           << mValeur.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_typeFormuleComparaisonValeur'               *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeFormuleComparaisonValeur::
GGS_typeFormuleComparaisonValeur (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeFormuleComparaisonValeur GGS_typeFormuleComparaisonValeur::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_luint & argument_0,
                 const GGS_luint & argument_1,
                 const GGS_luint & argument_2,
                 const GGS_luint & argument_3,
                 const GGS_luint & argument_4,
                 const GGS_luint & argument_5 COMMA_LOCATION_ARGS) {
  cPtr_typeFormuleComparaisonValeur * _ptr = (cPtr_typeFormuleComparaisonValeur *) NULL ;
  macroMyNew (_ptr, cPtr_typeFormuleComparaisonValeur (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5 COMMA_THERE)) ;
  GGS_typeFormuleComparaisonValeur result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeFormuleComparaisonValeur * GGS_typeFormuleComparaisonValeur::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFormuleComparaisonValeur *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeFormuleComparaisonValeur *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_typeFormuleComparaisonValeur::
reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<class @typeFormuleComparaisonValeur" ;
  if (isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'typeFormuleComparaisonVariable'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeFormuleComparaisonVariable::cPtr_typeFormuleComparaisonVariable (const GGS_luint & argument_0,
                                const GGS_luint & argument_1,
                                const GGS_luint & argument_2,
                                const GGS_luint & argument_3,
                                const GGS_luint & argument_4,
                                const GGS_luint & argument_5,
                                const GGS_luint & argument_6,
                                const GGS_luint & argument_7 COMMA_LOCATION_ARGS)
:cPtr_typeFormule (THERE),
mIndiceBDDgauche (argument_0),
mDimension (argument_1),
mLeftLowBound (argument_2),
mLeftHighBound (argument_3),
mComparaison (argument_4),
mIndiceBDDdroite (argument_5),
mRightLowBound (argument_6),
mRightHighBound (argument_7) {
}

//---------------------------------------------------------------------------*

void cPtr_typeFormuleComparaisonVariable::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeFormuleComparaisonVariable:"
           << mIndiceBDDgauche.reader_description  (_inLexique COMMA_THERE)
           << mDimension.reader_description  (_inLexique COMMA_THERE)
           << mLeftLowBound.reader_description  (_inLexique COMMA_THERE)
           << mLeftHighBound.reader_description  (_inLexique COMMA_THERE)
           << mComparaison.reader_description  (_inLexique COMMA_THERE)
           << mIndiceBDDdroite.reader_description  (_inLexique COMMA_THERE)
           << mRightLowBound.reader_description  (_inLexique COMMA_THERE)
           << mRightHighBound.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            GALGAS class 'GGS_typeFormuleComparaisonVariable'              *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeFormuleComparaisonVariable::
GGS_typeFormuleComparaisonVariable (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeFormuleComparaisonVariable GGS_typeFormuleComparaisonVariable::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_luint & argument_0,
                 const GGS_luint & argument_1,
                 const GGS_luint & argument_2,
                 const GGS_luint & argument_3,
                 const GGS_luint & argument_4,
                 const GGS_luint & argument_5,
                 const GGS_luint & argument_6,
                 const GGS_luint & argument_7 COMMA_LOCATION_ARGS) {
  cPtr_typeFormuleComparaisonVariable * _ptr = (cPtr_typeFormuleComparaisonVariable *) NULL ;
  macroMyNew (_ptr, cPtr_typeFormuleComparaisonVariable (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6,
                                argument_7 COMMA_THERE)) ;
  GGS_typeFormuleComparaisonVariable result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeFormuleComparaisonVariable * GGS_typeFormuleComparaisonVariable::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFormuleComparaisonVariable *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeFormuleComparaisonVariable *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_typeFormuleComparaisonVariable::
reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<class @typeFormuleComparaisonVariable" ;
  if (isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     abstract class 'cPtr_typeCalcul'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeCalcul::
cPtr_typeCalcul (LOCATION_ARGS)
:C_GGS_Object (THERE) {
}

//---------------------------------------------------------------------------*

void cPtr_typeCalcul::
appendForDescription (C_Lexique & /* _inLexique */,
                      C_String & ioString
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeCalcul:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_typeCalcul'                        *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeCalcul::
GGS_typeCalcul (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeCalcul::
GGS_typeCalcul (const GGS_typeCalcul & inOperand) {
  mPointer = (cPtr_typeCalcul *) NULL ;
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeCalcul::
~GGS_typeCalcul (void) {
  macroDetachPointer (mPointer, cPtr_typeCalcul) ;
}

//---------------------------------------------------------------------------*

void GGS_typeCalcul::
operator = (const GGS_typeCalcul & inSource) {
  macroAttachPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeCalcul * GGS_typeCalcul::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return mPointer ;  }
#endif

//---------------------------------------------------------------------------*

void GGS_typeCalcul::
drop_operation (void) {
  macroDetachPointer (mPointer, cPtr_typeCalcul) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeCalcul::
reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<class @typeCalcul" ;
  if (isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'typeCalculSimple'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeCalculSimple::cPtr_typeCalculSimple (const GGS_luint & argument_0,
                                const GGS_typeFormule & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_typeTableVariablesBool & argument_3,
                                const GGS_luint & argument_4 COMMA_LOCATION_ARGS)
:cPtr_typeCalcul (THERE),
mNumeroFormule (argument_0),
mFormule (argument_1),
mNomFormule (argument_2),
mTableVariablesBool (argument_3),
mAfficher (argument_4) {
}

//---------------------------------------------------------------------------*

void cPtr_typeCalculSimple::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeCalculSimple:"
           << mNumeroFormule.reader_description  (_inLexique COMMA_THERE)
           << mFormule.reader_description  (_inLexique COMMA_THERE)
           << mNomFormule.reader_description  (_inLexique COMMA_THERE)
           << mTableVariablesBool.reader_description  (_inLexique COMMA_THERE)
           << mAfficher.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeCalculSimple'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeCalculSimple::
GGS_typeCalculSimple (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeCalculSimple GGS_typeCalculSimple::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_luint & argument_0,
                 const GGS_typeFormule & argument_1,
                 const GGS_lstring & argument_2,
                 const GGS_typeTableVariablesBool & argument_3,
                 const GGS_luint & argument_4 COMMA_LOCATION_ARGS) {
  cPtr_typeCalculSimple * _ptr = (cPtr_typeCalculSimple *) NULL ;
  macroMyNew (_ptr, cPtr_typeCalculSimple (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4 COMMA_THERE)) ;
  GGS_typeCalculSimple result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeCalculSimple * GGS_typeCalculSimple::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeCalculSimple *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeCalculSimple *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_typeCalculSimple::
reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<class @typeCalculSimple" ;
  if (isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                           class 'typeUse_AND'                             *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeUse_AND::cPtr_typeUse_AND (LOCATION_ARGS)
:cPtr_typeCalcul (THERE) {
}

//---------------------------------------------------------------------------*

void cPtr_typeUse_AND::
appendForDescription (C_Lexique & /* _inLexique */,
                      C_String & ioString
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeUse_AND:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_typeUse_AND'                       *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeUse_AND::
GGS_typeUse_AND (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeUse_AND GGS_typeUse_AND::
constructor_new (C_Lexique & /* inLexique */ COMMA_LOCATION_ARGS) {
  cPtr_typeUse_AND * _ptr = (cPtr_typeUse_AND *) NULL ;
  macroMyNew (_ptr, cPtr_typeUse_AND (THERE)) ;
  GGS_typeUse_AND result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeUse_AND * GGS_typeUse_AND::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeUse_AND *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeUse_AND *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_typeUse_AND::
reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<class @typeUse_AND" ;
  if (isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                           class 'typeUse_ITE'                             *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeUse_ITE::cPtr_typeUse_ITE (LOCATION_ARGS)
:cPtr_typeCalcul (THERE) {
}

//---------------------------------------------------------------------------*

void cPtr_typeUse_ITE::
appendForDescription (C_Lexique & /* _inLexique */,
                      C_String & ioString
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeUse_ITE:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_typeUse_ITE'                       *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeUse_ITE::
GGS_typeUse_ITE (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeUse_ITE GGS_typeUse_ITE::
constructor_new (C_Lexique & /* inLexique */ COMMA_LOCATION_ARGS) {
  cPtr_typeUse_ITE * _ptr = (cPtr_typeUse_ITE *) NULL ;
  macroMyNew (_ptr, cPtr_typeUse_ITE (THERE)) ;
  GGS_typeUse_ITE result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeUse_ITE * GGS_typeUse_ITE::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeUse_ITE *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeUse_ITE *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_typeUse_ITE::
reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<class @typeUse_ITE" ;
  if (isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'typeUse_AND_ITE'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeUse_AND_ITE::cPtr_typeUse_AND_ITE (LOCATION_ARGS)
:cPtr_typeCalcul (THERE) {
}

//---------------------------------------------------------------------------*

void cPtr_typeUse_AND_ITE::
appendForDescription (C_Lexique & /* _inLexique */,
                      C_String & ioString
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeUse_AND_ITE:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeUse_AND_ITE'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeUse_AND_ITE::
GGS_typeUse_AND_ITE (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeUse_AND_ITE GGS_typeUse_AND_ITE::
constructor_new (C_Lexique & /* inLexique */ COMMA_LOCATION_ARGS) {
  cPtr_typeUse_AND_ITE * _ptr = (cPtr_typeUse_AND_ITE *) NULL ;
  macroMyNew (_ptr, cPtr_typeUse_AND_ITE (THERE)) ;
  GGS_typeUse_AND_ITE result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeUse_AND_ITE * GGS_typeUse_AND_ITE::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeUse_AND_ITE *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeUse_AND_ITE *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_typeUse_AND_ITE::
reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<class @typeUse_AND_ITE" ;
  if (isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'typeDimensionnerANDCache'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeDimensionnerANDCache::cPtr_typeDimensionnerANDCache (const GGS_luint & argument_0 COMMA_LOCATION_ARGS)
:cPtr_typeCalcul (THERE),
mDimensionCache (argument_0) {
}

//---------------------------------------------------------------------------*

void cPtr_typeDimensionnerANDCache::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeDimensionnerANDCache:"
           << mDimensionCache.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeDimensionnerANDCache'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeDimensionnerANDCache::
GGS_typeDimensionnerANDCache (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeDimensionnerANDCache GGS_typeDimensionnerANDCache::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_luint & argument_0 COMMA_LOCATION_ARGS) {
  cPtr_typeDimensionnerANDCache * _ptr = (cPtr_typeDimensionnerANDCache *) NULL ;
  macroMyNew (_ptr, cPtr_typeDimensionnerANDCache (argument_0 COMMA_THERE)) ;
  GGS_typeDimensionnerANDCache result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeDimensionnerANDCache * GGS_typeDimensionnerANDCache::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeDimensionnerANDCache *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeDimensionnerANDCache *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_typeDimensionnerANDCache::
reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<class @typeDimensionnerANDCache" ;
  if (isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'typeDimensionnerITECache'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeDimensionnerITECache::cPtr_typeDimensionnerITECache (const GGS_luint & argument_0 COMMA_LOCATION_ARGS)
:cPtr_typeCalcul (THERE),
mDimensionCache (argument_0) {
}

//---------------------------------------------------------------------------*

void cPtr_typeDimensionnerITECache::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeDimensionnerITECache:"
           << mDimensionCache.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeDimensionnerITECache'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeDimensionnerITECache::
GGS_typeDimensionnerITECache (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeDimensionnerITECache GGS_typeDimensionnerITECache::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_luint & argument_0 COMMA_LOCATION_ARGS) {
  cPtr_typeDimensionnerITECache * _ptr = (cPtr_typeDimensionnerITECache *) NULL ;
  macroMyNew (_ptr, cPtr_typeDimensionnerITECache (argument_0 COMMA_THERE)) ;
  GGS_typeDimensionnerITECache result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeDimensionnerITECache * GGS_typeDimensionnerITECache::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeDimensionnerITECache *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeDimensionnerITECache *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_typeDimensionnerITECache::
reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<class @typeDimensionnerITECache" ;
  if (isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'typeDimensionnerTable'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeDimensionnerTable::cPtr_typeDimensionnerTable (const GGS_luint & argument_0 COMMA_LOCATION_ARGS)
:cPtr_typeCalcul (THERE),
mDimensionTable (argument_0) {
}

//---------------------------------------------------------------------------*

void cPtr_typeDimensionnerTable::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeDimensionnerTable:"
           << mDimensionTable.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeDimensionnerTable'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeDimensionnerTable::
GGS_typeDimensionnerTable (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeDimensionnerTable GGS_typeDimensionnerTable::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_luint & argument_0 COMMA_LOCATION_ARGS) {
  cPtr_typeDimensionnerTable * _ptr = (cPtr_typeDimensionnerTable *) NULL ;
  macroMyNew (_ptr, cPtr_typeDimensionnerTable (argument_0 COMMA_THERE)) ;
  GGS_typeDimensionnerTable result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeDimensionnerTable * GGS_typeDimensionnerTable::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeDimensionnerTable *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeDimensionnerTable *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_typeDimensionnerTable::
reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<class @typeDimensionnerTable" ;
  if (isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'typeAfficherBilan'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeAfficherBilan::cPtr_typeAfficherBilan (LOCATION_ARGS)
:cPtr_typeCalcul (THERE) {
}

//---------------------------------------------------------------------------*

void cPtr_typeAfficherBilan::
appendForDescription (C_Lexique & /* _inLexique */,
                      C_String & ioString
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeAfficherBilan:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeAfficherBilan'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeAfficherBilan::
GGS_typeAfficherBilan (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeAfficherBilan GGS_typeAfficherBilan::
constructor_new (C_Lexique & /* inLexique */ COMMA_LOCATION_ARGS) {
  cPtr_typeAfficherBilan * _ptr = (cPtr_typeAfficherBilan *) NULL ;
  macroMyNew (_ptr, cPtr_typeAfficherBilan (THERE)) ;
  GGS_typeAfficherBilan result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeAfficherBilan * GGS_typeAfficherBilan::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeAfficherBilan *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeAfficherBilan *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_typeAfficherBilan::
reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<class @typeAfficherBilan" ;
  if (isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'typeCalculIteratif'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeCalculIteratif::cPtr_typeCalculIteratif (const GGS_luint & argument_0,
                                const GGS_typeFormule & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_typeTableVariablesBool & argument_3,
                                const GGS_lbool & argument_4,
                                const GGS_luint & argument_5 COMMA_LOCATION_ARGS)
:cPtr_typeCalcul (THERE),
mNumeroFormule (argument_0),
mFormule (argument_1),
mNomFormule (argument_2),
mTableVariablesBool (argument_3),
mSigne (argument_4),
mAfficher (argument_5) {
}

//---------------------------------------------------------------------------*

void cPtr_typeCalculIteratif::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeCalculIteratif:"
           << mNumeroFormule.reader_description  (_inLexique COMMA_THERE)
           << mFormule.reader_description  (_inLexique COMMA_THERE)
           << mNomFormule.reader_description  (_inLexique COMMA_THERE)
           << mTableVariablesBool.reader_description  (_inLexique COMMA_THERE)
           << mSigne.reader_description  (_inLexique COMMA_THERE)
           << mAfficher.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeCalculIteratif'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeCalculIteratif::
GGS_typeCalculIteratif (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeCalculIteratif GGS_typeCalculIteratif::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_luint & argument_0,
                 const GGS_typeFormule & argument_1,
                 const GGS_lstring & argument_2,
                 const GGS_typeTableVariablesBool & argument_3,
                 const GGS_lbool & argument_4,
                 const GGS_luint & argument_5 COMMA_LOCATION_ARGS) {
  cPtr_typeCalculIteratif * _ptr = (cPtr_typeCalculIteratif *) NULL ;
  macroMyNew (_ptr, cPtr_typeCalculIteratif (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5 COMMA_THERE)) ;
  GGS_typeCalculIteratif result ;
  macroAttachPointer (result.mPointer, _ptr) ;
  return result ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeCalculIteratif * GGS_typeCalculIteratif::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeCalculIteratif *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeCalculIteratif *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_typeCalculIteratif::
reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<class @typeCalculIteratif" ;
  if (isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   Element of list '@typeListeCalculs'                     *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeListeCalculs::
elementOf_GGS_typeListeCalculs (const GGS_typeCalcul & argument_0):
mNextItem (NULL),
mCalcul (argument_0) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeListeCalculs::
appendForListDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "[" ;
  ioString << mCalcul.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         List '@typeListeCalculs'                          *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeListeCalculs::cRootList::cRootList (void):
mFirstItem (NULL),
mLastItem (NULL),
mListLength (0),
mCountReference (1) {
}

//---------------------------------------------------------------------------*

GGS_typeListeCalculs::cRootList::~cRootList (void) {
  while (mFirstItem != NULL) {
    element_type * p = mFirstItem->nextObject () ;
    macroMyDelete (mFirstItem, element_type) ;
    mFirstItem = p ;
  }
}

//---------------------------------------------------------------------------*

GGS_typeListeCalculs::GGS_typeListeCalculs (void) { // Default Constructor
  mRoot = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeListeCalculs::~GGS_typeListeCalculs (void) {
  drop_operation () ;
}

//---------------------------------------------------------------------------*

GGS_typeListeCalculs::
GGS_typeListeCalculs (const GGS_typeListeCalculs & inSource) {
  mRoot = inSource.mRoot ;
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    mRoot->mCountReference ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeCalculs::
operator = (const GGS_typeListeCalculs & inSource) {
  if (this != & inSource) {
    drop_operation () ;
    mRoot = inSource.mRoot ;
    if (mRoot != NULL) {
      macroValidPointer (mRoot) ;
      mRoot->mCountReference ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeListeCalculs::element_type * GGS_typeListeCalculs::
firstObject (void) const {
  return (mRoot == NULL) ? NULL : mRoot->mFirstItem ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeCalculs::
internalAppendItem (const GGS_typeCalcul & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mRoot->mLastItem == NULL) {
      mRoot->mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mRoot->mLastItem) ;
      mRoot->mLastItem->mNextItem = nouvelElement ;
    }
    mRoot->mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mRoot->mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeCalculs::
addAssign_operation (const GGS_typeCalcul & argument_0) {
  if (isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeCalculs::
insulateList (void) {
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    if (mRoot->mCountReference > 1) {
      element_type * p = mRoot->mFirstItem ;
      mRoot->mCountReference -- ;
      mRoot = NULL ;
      macroMyNew (mRoot, cRootList) ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->mCalcul) ;
        p = p->mNextItem ;
      }
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeListeCalculs  GGS_typeListeCalculs::
constructor_emptyList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeListeCalculs result ;
  macroMyNew (result.mRoot, cRootList) ;
  return result ;
}

//---------------------------------------------------------------------------*

sint32 GGS_typeListeCalculs::
count (void) const {
  return (mRoot == NULL) ? 0 : mRoot->mListLength ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeListeCalculs::
reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<list @typeListeCalculs" ;
  if (isBuilt ()) {
    s << " " << mRoot->mListLength << " object" << ((mRoot->mListLength > 1) ? "s " : " ") ;
    element_type * p = mRoot->mFirstItem ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForListDescription (_inLexique, s COMMA_THERE) ;
      p = p->mNextItem ;
    }
  }else{
    s << "not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

GGS_uint GGS_typeListeCalculs::
reader_length (C_Lexique & /* inLexique */
               COMMA_UNUSED_LOCATION_ARGS) const {
  return GGS_uint (mRoot != NULL,
                   (mRoot == NULL) ? 0 : (uint32) mRoot->mListLength) ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeCalculs::
drop_operation (void) {
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    if (mRoot->mCountReference == 1) {
      macroMyDelete (mRoot, cRootList) ;
    }else{
      mRoot->mCountReference -- ;
      mRoot = NULL ;
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//         Implementation of routine "verifierNombreArgumentsBool"           *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_verifierNombreArgumentsBool (C_Lexique & _inLexique,
                                const GGS_typeFormalArgumentsList  & var_cas_t1,
                                const GGS_typeActualArgumentsList  & var_cas_t2,
                                const GGS_location  & var_cas_positionFinListe COMMA_UNUSED_LOCATION_ARGS) {
  if (((var_cas_t1.reader_length (_inLexique SOURCE_FILE_AT_LINE (257))) < (var_cas_t2.reader_length (_inLexique SOURCE_FILE_AT_LINE (257)))).isBuiltAndTrue ()) {
    var_cas_positionFinListe.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "too much actual arguments") SOURCE_FILE_AT_LINE (259)) ;
  }else if (((var_cas_t1.reader_length (_inLexique SOURCE_FILE_AT_LINE (259))) > (var_cas_t2.reader_length (_inLexique SOURCE_FILE_AT_LINE (259)))).isBuiltAndTrue ()) {
    var_cas_positionFinListe.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "one or more actual arguments missing") SOURCE_FILE_AT_LINE (261)) ;
  }
  GGS_typeFormalArgumentsList::element_type * operand_7746 = var_cas_t1.firstObject () ;
  GGS_typeActualArgumentsList::element_type * operand_7835 = var_cas_t2.firstObject () ;
  while ((operand_7746 != NULL)
      && (operand_7835 != NULL)) {
    macroValidPointer (operand_7746) ;
    macroValidPointer (operand_7835) ;
    if (((operand_7746->mVariableBitSize.reader_value (_inLexique SOURCE_FILE_AT_LINE (264))) == (operand_7835->mVariableBitSize.reader_value (_inLexique SOURCE_FILE_AT_LINE (264)))).isBuiltAndTrue ()) {
      if (((operand_7746->mLowBound.reader_value (_inLexique SOURCE_FILE_AT_LINE (265))) == (operand_7835->mLowBound.reader_value (_inLexique SOURCE_FILE_AT_LINE (265)))).isBuiltAndTrue ()) {
        if (((operand_7746->mHighBound.reader_value (_inLexique SOURCE_FILE_AT_LINE (266))) == (operand_7835->mHighBound.reader_value (_inLexique SOURCE_FILE_AT_LINE (266)))).isBuiltAndTrue ()) {
        }else{
          operand_7835->mErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "the actual high bound is different the formal one") SOURCE_FILE_AT_LINE (269)) ;
        }
      }else{
        operand_7835->mErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "the actual low bound is different the formal one") SOURCE_FILE_AT_LINE (272)) ;
      }
    }else{
      operand_7835->mErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "the actual dimension is different from the formal one") SOURCE_FILE_AT_LINE (275)) ;
    }
    operand_7746 = operand_7746->nextObject () ;
    operand_7835 = operand_7835->nextObject () ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//             Implementation of routine "buildFormalArgsList"               *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_buildFormalArgsList (C_Lexique & _inLexique,
                                const GGS_typeVariableDescriptor  & var_cas_inVariableDescriptor,
                                GGS_typeFormalArgumentsList  & var_cas_ioFormalArgsList,
                                const GGS_location  & var_cas_inErrorLocation COMMA_UNUSED_LOCATION_ARGS) {
  if (var_cas_inVariableDescriptor.isBuilt ()) {
    if (dynamic_cast <cPtr_typeDirectVariable *> (var_cas_inVariableDescriptor.getPtr ()) != NULL) {
      cPtr_typeDirectVariable * operand_8724 = dynamic_cast <cPtr_typeDirectVariable *> (var_cas_inVariableDescriptor.getPtr ()) ;
      macroValidPointer (operand_8724) ; 
      var_cas_ioFormalArgsList.addAssign_operation (operand_8724->mIndex, operand_8724->mBitSize, operand_8724->mLowBound, operand_8724->mHighBound) ;
    }else if (dynamic_cast <cPtr_typeRecordVariable *> (var_cas_inVariableDescriptor.getPtr ()) != NULL) {
      cPtr_typeRecordVariable * operand_8910 = dynamic_cast <cPtr_typeRecordVariable *> (var_cas_inVariableDescriptor.getPtr ()) ;
      macroValidPointer (operand_8910) ; 
      GGS_typeTableVariablesBool::element_type * operand_9007 = operand_8910->mMap.firstObject () ;
      while ((operand_9007 != NULL)) {
        macroValidPointer (operand_9007) ;
        ::routine_buildFormalArgsList (_inLexique,  operand_9007->mInfo.mVariableDescriptor,  var_cas_ioFormalArgsList,  var_cas_inErrorLocation SOURCE_FILE_AT_LINE (291)) ;
        operand_9007 = operand_9007->nextObject () ;
      }
    }else{ // Else part
      var_cas_inErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, ((GGS_string (true, "a variable was expected here ; I found ")) + (var_cas_inVariableDescriptor.reader_variableDescriptorErrorMessage (_inLexique SOURCE_FILE_AT_LINE (294)))) SOURCE_FILE_AT_LINE (295)) ;
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//             Implementation of routine "buildActualArgsList"               *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_buildActualArgsList (C_Lexique & _inLexique,
                                const GGS_typeTableVariablesBool  & var_cas_inDomainMap,
                                GGS_typeActualArgumentsList  & var_cas_ioActualArgsList,
                                const GGS_location  & var_cas_inErrorLocation COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeTableVariablesBool::element_type * operand_9582 = var_cas_inDomainMap.firstObject () ;
  while ((operand_9582 != NULL)) {
    macroValidPointer (operand_9582) ;
    if (operand_9582->mInfo.mVariableDescriptor.isBuilt ()) {
      if (dynamic_cast <cPtr_typeDirectVariable *> (operand_9582->mInfo.mVariableDescriptor.getPtr ()) != NULL) {
        cPtr_typeDirectVariable * operand_9691 = dynamic_cast <cPtr_typeDirectVariable *> (operand_9582->mInfo.mVariableDescriptor.getPtr ()) ;
        macroValidPointer (operand_9691) ; 
        var_cas_ioActualArgsList.addAssign_operation (operand_9691->mIndex, operand_9691->mBitSize, operand_9691->mLowBound, operand_9691->mHighBound, var_cas_inErrorLocation) ;
      }else if (dynamic_cast <cPtr_typeRecordVariable *> (operand_9582->mInfo.mVariableDescriptor.getPtr ()) != NULL) {
        cPtr_typeRecordVariable * operand_9898 = dynamic_cast <cPtr_typeRecordVariable *> (operand_9582->mInfo.mVariableDescriptor.getPtr ()) ;
        macroValidPointer (operand_9898) ; 
        ::routine_buildActualArgsList (_inLexique,  operand_9898->mMap,  var_cas_ioActualArgsList,  var_cas_inErrorLocation SOURCE_FILE_AT_LINE (310)) ;
      }else{ // Else part
        var_cas_inErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, ((GGS_string (true, "a variable was expected here ; I found ")) + (operand_9582->mInfo.mVariableDescriptor.reader_variableDescriptorErrorMessage (_inLexique SOURCE_FILE_AT_LINE (313)))) SOURCE_FILE_AT_LINE (314)) ;
      }
    }
    operand_9582 = operand_9582->nextObject () ;
  }
}

//---------------------------------------------------------------------------*

