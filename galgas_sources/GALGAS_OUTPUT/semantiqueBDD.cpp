//---------------------------------------------------------------------------*
//                                                                           *
//                         File 'semantiqueBDD.cpp'                          *
//         Generated by version GALGAS_BETA_VERSION (LL(1) grammar)          *
//                      april 23th, 2006, at 21h28'51"                       *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

#include "utilities/MF_MemoryControl.h"
#include "files/C_TextFileWrite.h"
#include "semantiqueBDD.h"

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  static const char gGGSsourceFile [] = "semantiqueBDD.ggs" ;
  #define SOURCE_FILE_AT_LINE(line) , gGGSsourceFile, line
#else
  #define SOURCE_FILE_AT_LINE(line) 
#endif


//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//                     abstract class 'cPtr_typeDomain'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeDomain::
cPtr_typeDomain (LOCATION_ARGS)
:C_GGS_Object (THERE) {
}

//---------------------------------------------------------------------------*

const char * cPtr_typeDomain
::static_string_message_messageDomainType (void) {
  return "any domain" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeDomain::
message_messageDomainType (void) const {
  return "any domain" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_typeDomain'                        *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeDomain::
GGS_typeDomain (void) {
  mPointer = (cPtr_typeDomain *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeDomain::
GGS_typeDomain (const GGS_typeDomain & inOperand) {
  mPointer = (cPtr_typeDomain *) NULL ;
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeDomain::
~GGS_typeDomain (void) {
  macroDetachPointer (mPointer, cPtr_typeDomain) ;
}

//---------------------------------------------------------------------------*

void GGS_typeDomain::
operator = (const GGS_typeDomain & inOperand) {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

void GGS_typeDomain::
operator = (cPtr_typeDomain * inSource) {
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

GGS_typeDomain::
GGS_typeDomain (cPtr_typeDomain * inSource) {
  mPointer = (cPtr_typeDomain *) NULL ;
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeDomain * GGS_typeDomain
::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_typeDomain::reader_messageDomainType (void) const {
  return GGS_string (mPointer != NULL, C_String ((mPointer == NULL) ? "" : mPointer->message_messageDomainType ())) ;
}

//---------------------------------------------------------------------------*

void GGS_typeDomain
::drop_operation (void) {
  macroDetachPointer (mPointer, cPtr_typeDomain) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeDomain
::reader_description (void) const {
  C_String s ;
  s << "<class @typeDomain" ;
  if (isBuilt ()) {
    mPointer->appendForDescription (s) ;
  }else{
    s << " not built" ;
  }
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'typeDirectDomain'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeDirectDomain::cPtr_typeDirectDomain (const GGS_luint & argument_0,
                                const GGS_luint & argument_1,
                                const GGS_luint & argument_2 COMMA_LOCATION_ARGS)
:cPtr_typeDomain (THERE),
mLowBound (argument_0),
mHighBound (argument_1),
mBitsCount (argument_2) {
}


const char * cPtr_typeDirectDomain::message_messageDomainType (void) const {
  return "an interval domain" ;
}

const char * cPtr_typeDirectDomain::static_string_message_messageDomainType (void) {
  return "an interval domain" ;
}

//---------------------------------------------------------------------------*

void cPtr_typeDirectDomain::appendForDescription (C_String & ioString) const {
  ioString << "->@typeDirectDomain:" ;
mLowBound.reader_description () ;
mHighBound.reader_description () ;
mBitsCount.reader_description () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeDirectDomain'                     *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeDirectDomain * GGS_typeDirectDomain::
    constructor_new (const GGS_luint & argument_0,
                                const GGS_luint & argument_1,
                                const GGS_luint & argument_2 COMMA_LOCATION_ARGS) {
    cPtr_typeDirectDomain * ptr_ = (cPtr_typeDirectDomain *) NULL ;
    macroMyNew (ptr_, cPtr_typeDirectDomain (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                        class map 'typeDomainMap'                          *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeDomainMap::
elementOf_GGS_typeDomainMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_typeDomainMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeDomainMap::
appendForMapDescription (C_String & ioString) const {
  ioString << "["
           << mKey.reader_description () ;
  ioString << "->" ;
  ioString << mInfo.mDomain.reader_description () ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_typeDomainMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_typeDomainMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_typeDomainMap * info = (e_typeDomainMap *) inInfo ;
  macroMyNew (p, element_type (inKey, count (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_typeDomainMap GGS_typeDomainMap::constructor_empty (UNUSED_LOCATION_ARGS) {
  GGS_typeDomainMap result ;
  macroMyNew (result.mReferenceCountPtr, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeDomainMap::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mRoot, extension, index, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_typeDomainMap::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_typeDomain &  inParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()) {
    insulateMap () ;
    e_typeDomainMap info  ;
    info.mDomain = inParameter0 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mRoot, extension, index, existingKeyLocation) ;
    if (index < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeDomainMap::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_typeDomain   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop_operation () ;
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mDomain ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeDomainMap::methode_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_typeDomain   & outParameter0 COMMA_LOCATION_ARGS) {
  searchElement (inLexique,
                 "the '%K' domain is not declared",
                 inKey,
                 outParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeDomainMap::
methode_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_typeDomain & inParameter0 COMMA_LOCATION_ARGS) {
  insertElement (_inLexique,
                 "the '%K' domain has been already declared",
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeDomainMap::reader_description (void) const {
  C_String s ;
  s << "<map @typeDomainMap " ;
  if (isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (s) ;
      p = p->nextObject () ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'typeRecordDomain'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeRecordDomain::cPtr_typeRecordDomain (const GGS_typeDomainMap & argument_0 COMMA_LOCATION_ARGS)
:cPtr_typeDomain (THERE),
mRecordMap (argument_0) {
}


const char * cPtr_typeRecordDomain::message_messageDomainType (void) const {
  return "a record domain" ;
}

const char * cPtr_typeRecordDomain::static_string_message_messageDomainType (void) {
  return "a record domain" ;
}

//---------------------------------------------------------------------------*

void cPtr_typeRecordDomain::appendForDescription (C_String & ioString) const {
  ioString << "->@typeRecordDomain:" ;
mRecordMap.reader_description () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeRecordDomain'                     *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeRecordDomain * GGS_typeRecordDomain::
    constructor_new (const GGS_typeDomainMap & argument_0 COMMA_LOCATION_ARGS) {
    cPtr_typeRecordDomain * ptr_ = (cPtr_typeRecordDomain *) NULL ;
    macroMyNew (ptr_, cPtr_typeRecordDomain (argument_0 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@typeFormalArgumentsList'                 *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeFormalArgumentsList::
elementOf_GGS_typeFormalArgumentsList (const GGS_luint & argument_0,
                                const GGS_luint & argument_1,
                                const GGS_luint & argument_2,
                                const GGS_luint & argument_3) {
  mNextItem = (elementOf_GGS_typeFormalArgumentsList *) NULL ;
  mVariableIndex = argument_0 ;
  mVariableBitSize = argument_1 ;
  mLowBound = argument_2 ;
  mHighBound = argument_3 ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeFormalArgumentsList::
appendForListDescription (C_String & ioString) const {
  ioString << "[" ;
  ioString << mVariableIndex.reader_description () ;
  ioString << mVariableBitSize.reader_description () ;
  ioString << mLowBound.reader_description () ;
  ioString << mHighBound.reader_description () ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     List '@typeFormalArgumentsList'                       *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeFormalArgumentsList
::GGS_typeFormalArgumentsList (void) { // Default Constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  GGS_typeFormalArgumentsList
::GGS_typeFormalArgumentsList (UNUSED_LOCATION_ARGS) {
    mFirstItem = (element_type *) NULL ;
    mLastItem = (element_type *) NULL ;
    mListLength = 0 ;
    mCountReference = (sint32 *) NULL ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_typeFormalArgumentsList::~GGS_typeFormalArgumentsList (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*

GGS_typeFormalArgumentsList::GGS_typeFormalArgumentsList (const GGS_typeFormalArgumentsList & source) { // Copy constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
  *this = source ;
}

//---------------------------------------------------------------------------*

void GGS_typeFormalArgumentsList
::operator = (const GGS_typeFormalArgumentsList & source) { // Assignment operator
  if (this != & source) {
    emptyList () ;
    mFirstItem = source.mFirstItem ;
    mLastItem = source.mLastItem ;
    mListLength = source.mListLength ;
    mCountReference = source.mCountReference ;
    if (mCountReference != NULL) {
      macroValidPointer (mCountReference) ;
      (*mCountReference) ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeFormalArgumentsList
::emptyList (void) {
  mListLength = 0 ;
  mLastItem = (element_type *) NULL ;
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) == 1) {
      macroMyDelete (mCountReference, sint32) ;
      while (mFirstItem != NULL) {
        macroValidPointer (mFirstItem) ;
        mLastItem = mFirstItem->mNextItem ;
        macroMyDelete (mFirstItem, element_type) ;
        mFirstItem = mLastItem ;
      }
    }else{
      mFirstItem = (element_type *) NULL ;
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeFormalArgumentsList::
internalAppendItem (const GGS_luint & argument_0,
                                const GGS_luint & argument_1,
                                const GGS_luint & argument_2,
                                const GGS_luint & argument_3) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2,
                                argument_3)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mLastItem == NULL) {
      mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mLastItem) ;
      mLastItem->mNextItem = nouvelElement ;
    }
    mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeFormalArgumentsList::
addAssign_operation (const GGS_luint & argument_0,
                                const GGS_luint & argument_1,
                                const GGS_luint & argument_2,
                                const GGS_luint & argument_3) {
  if (isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0,
                                argument_1,
                                argument_2,
                                argument_3) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeFormalArgumentsList::
insulateList (void) {
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) > 1) {
      element_type * p = mFirstItem ;
      mFirstItem = (element_type *)  NULL ;
      mLastItem = (element_type *)  NULL ;
      mListLength = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->mVariableIndex,
                                p->mVariableBitSize,
                                p->mLowBound,
                                p->mHighBound) ;
        p = p->mNextItem ;
      }
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
      macroMyNew (mCountReference, sint32 (1)) ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeFormalArgumentsList  GGS_typeFormalArgumentsList::
constructor_empty (UNUSED_LOCATION_ARGS) {
  GGS_typeFormalArgumentsList result ;
  macroMyNew (result.mCountReference, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeFormalArgumentsList::reader_description (void) const {
  C_String s ;
  s << "<list @typeFormalArgumentsList" ;
  if (isBuilt ()) {
    s << " " << mListLength << " object" << ((mListLength > 1) ? "s " : " ") ;
    element_type * p = mFirstItem ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForListDescription (s) ;
      p = p->mNextItem ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

void GGS_typeFormalArgumentsList
::drop_operation (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@typeActualArgumentsList'                 *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeActualArgumentsList::
elementOf_GGS_typeActualArgumentsList (const GGS_luint & argument_0,
                                const GGS_luint & argument_1,
                                const GGS_luint & argument_2,
                                const GGS_luint & argument_3,
                                const GGS_location & argument_4) {
  mNextItem = (elementOf_GGS_typeActualArgumentsList *) NULL ;
  mVariableIndex = argument_0 ;
  mVariableBitSize = argument_1 ;
  mLowBound = argument_2 ;
  mHighBound = argument_3 ;
  mErrorLocation = argument_4 ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeActualArgumentsList::
appendForListDescription (C_String & ioString) const {
  ioString << "[" ;
  ioString << mVariableIndex.reader_description () ;
  ioString << mVariableBitSize.reader_description () ;
  ioString << mLowBound.reader_description () ;
  ioString << mHighBound.reader_description () ;
  ioString << mErrorLocation.reader_description () ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     List '@typeActualArgumentsList'                       *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeActualArgumentsList
::GGS_typeActualArgumentsList (void) { // Default Constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  GGS_typeActualArgumentsList
::GGS_typeActualArgumentsList (UNUSED_LOCATION_ARGS) {
    mFirstItem = (element_type *) NULL ;
    mLastItem = (element_type *) NULL ;
    mListLength = 0 ;
    mCountReference = (sint32 *) NULL ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_typeActualArgumentsList::~GGS_typeActualArgumentsList (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*

GGS_typeActualArgumentsList::GGS_typeActualArgumentsList (const GGS_typeActualArgumentsList & source) { // Copy constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
  *this = source ;
}

//---------------------------------------------------------------------------*

void GGS_typeActualArgumentsList
::operator = (const GGS_typeActualArgumentsList & source) { // Assignment operator
  if (this != & source) {
    emptyList () ;
    mFirstItem = source.mFirstItem ;
    mLastItem = source.mLastItem ;
    mListLength = source.mListLength ;
    mCountReference = source.mCountReference ;
    if (mCountReference != NULL) {
      macroValidPointer (mCountReference) ;
      (*mCountReference) ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeActualArgumentsList
::emptyList (void) {
  mListLength = 0 ;
  mLastItem = (element_type *) NULL ;
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) == 1) {
      macroMyDelete (mCountReference, sint32) ;
      while (mFirstItem != NULL) {
        macroValidPointer (mFirstItem) ;
        mLastItem = mFirstItem->mNextItem ;
        macroMyDelete (mFirstItem, element_type) ;
        mFirstItem = mLastItem ;
      }
    }else{
      mFirstItem = (element_type *) NULL ;
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeActualArgumentsList::
internalAppendItem (const GGS_luint & argument_0,
                                const GGS_luint & argument_1,
                                const GGS_luint & argument_2,
                                const GGS_luint & argument_3,
                                const GGS_location & argument_4) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mLastItem == NULL) {
      mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mLastItem) ;
      mLastItem->mNextItem = nouvelElement ;
    }
    mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeActualArgumentsList::
addAssign_operation (const GGS_luint & argument_0,
                                const GGS_luint & argument_1,
                                const GGS_luint & argument_2,
                                const GGS_luint & argument_3,
                                const GGS_location & argument_4) {
  if (isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeActualArgumentsList::
insulateList (void) {
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) > 1) {
      element_type * p = mFirstItem ;
      mFirstItem = (element_type *)  NULL ;
      mLastItem = (element_type *)  NULL ;
      mListLength = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->mVariableIndex,
                                p->mVariableBitSize,
                                p->mLowBound,
                                p->mHighBound,
                                p->mErrorLocation) ;
        p = p->mNextItem ;
      }
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
      macroMyNew (mCountReference, sint32 (1)) ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeActualArgumentsList  GGS_typeActualArgumentsList::
constructor_empty (UNUSED_LOCATION_ARGS) {
  GGS_typeActualArgumentsList result ;
  macroMyNew (result.mCountReference, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeActualArgumentsList::reader_description (void) const {
  C_String s ;
  s << "<list @typeActualArgumentsList" ;
  if (isBuilt ()) {
    s << " " << mListLength << " object" << ((mListLength > 1) ? "s " : " ") ;
    element_type * p = mFirstItem ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForListDescription (s) ;
      p = p->mNextItem ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

void GGS_typeActualArgumentsList
::drop_operation (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               abstract class 'cPtr_typeVariableDescriptor'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeVariableDescriptor::
cPtr_typeVariableDescriptor (LOCATION_ARGS)
:C_GGS_Object (THERE) {
}

//---------------------------------------------------------------------------*

const char * cPtr_typeVariableDescriptor
::static_string_message_variableDescriptorErrorMessage (void) {
  return "any variable" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeVariableDescriptor::
message_variableDescriptorErrorMessage (void) const {
  return "any variable" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_typeVariableDescriptor'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeVariableDescriptor::
GGS_typeVariableDescriptor (void) {
  mPointer = (cPtr_typeVariableDescriptor *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeVariableDescriptor::
GGS_typeVariableDescriptor (const GGS_typeVariableDescriptor & inOperand) {
  mPointer = (cPtr_typeVariableDescriptor *) NULL ;
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeVariableDescriptor::
~GGS_typeVariableDescriptor (void) {
  macroDetachPointer (mPointer, cPtr_typeVariableDescriptor) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariableDescriptor::
operator = (const GGS_typeVariableDescriptor & inOperand) {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariableDescriptor::
operator = (cPtr_typeVariableDescriptor * inSource) {
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

GGS_typeVariableDescriptor::
GGS_typeVariableDescriptor (cPtr_typeVariableDescriptor * inSource) {
  mPointer = (cPtr_typeVariableDescriptor *) NULL ;
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeVariableDescriptor * GGS_typeVariableDescriptor
::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_typeVariableDescriptor::reader_variableDescriptorErrorMessage (void) const {
  return GGS_string (mPointer != NULL, C_String ((mPointer == NULL) ? "" : mPointer->message_variableDescriptorErrorMessage ())) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariableDescriptor
::drop_operation (void) {
  macroDetachPointer (mPointer, cPtr_typeVariableDescriptor) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeVariableDescriptor
::reader_description (void) const {
  C_String s ;
  s << "<class @typeVariableDescriptor" ;
  if (isBuilt ()) {
    mPointer->appendForDescription (s) ;
  }else{
    s << " not built" ;
  }
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'typeDirectVariable'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeDirectVariable::cPtr_typeDirectVariable (const GGS_luint & argument_0,
                                const GGS_luint & argument_1,
                                const GGS_luint & argument_2,
                                const GGS_luint & argument_3 COMMA_LOCATION_ARGS)
:cPtr_typeVariableDescriptor (THERE),
mIndex (argument_0),
mBitSize (argument_1),
mLowBound (argument_2),
mHighBound (argument_3) {
}


const char * cPtr_typeDirectVariable::message_variableDescriptorErrorMessage (void) const {
  return "a direct domain variable" ;
}

const char * cPtr_typeDirectVariable::static_string_message_variableDescriptorErrorMessage (void) {
  return "a direct domain variable" ;
}

//---------------------------------------------------------------------------*

void cPtr_typeDirectVariable::appendForDescription (C_String & ioString) const {
  ioString << "->@typeDirectVariable:" ;
mIndex.reader_description () ;
mBitSize.reader_description () ;
mLowBound.reader_description () ;
mHighBound.reader_description () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeDirectVariable'                    *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeDirectVariable * GGS_typeDirectVariable::
    constructor_new (const GGS_luint & argument_0,
                                const GGS_luint & argument_1,
                                const GGS_luint & argument_2,
                                const GGS_luint & argument_3 COMMA_LOCATION_ARGS) {
    cPtr_typeDirectVariable * ptr_ = (cPtr_typeDirectVariable *) NULL ;
    macroMyNew (ptr_, cPtr_typeDirectVariable (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//               class map element 'e_typeTableVariablesBool'                *
//                                                                           *
//---------------------------------------------------------------------------*

#include "cTableVariablesBDD.hh"

//---------------------------------------------------------------------------*

template class cTableVariablesBDD <e_typeTableVariablesBool> ;

//---------------------------------------------------------------------------*
//                                                                           *
//                       Map 'typeTableVariablesBool'                        *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeTableVariablesBool GGS_typeTableVariablesBool::constructor_empty (UNUSED_LOCATION_ARGS) {
  GGS_typeTableVariablesBool t ;
  t.build () ;
  return t ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableVariablesBool::methode_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_typeVariableDescriptor   & outParameter0 COMMA_LOCATION_ARGS) {
  GGS_typeTableVariablesBool::element_type * info = searchKey (inLexique, inKey, inKey, "the '%' variable is not declared" COMMA_THERE) ;
  if (info == NULL) {
    outParameter0.drop_operation () ;
  }else{
    outParameter0 = info->mInfo.mVariableDescriptor ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTableVariablesBool::methode_searchKeyGetIndex (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                GGS_typeVariableDescriptor   & outParameter0 COMMA_LOCATION_ARGS) {
  GGS_typeTableVariablesBool::element_type * info = searchKey (inLexique, inKey, inKey, "the '%' variable is not declared" COMMA_THERE) ;
  if (info == NULL) {
    outParameter0.drop_operation () ;
    outIndex.drop_operation () ;
  }else{
    outParameter0 = info->mInfo.mVariableDescriptor ;
    outIndex = GGS_luint (GGS_uint (true, (uint32) info->mEntryIndex), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTableVariablesBool::methode_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_typeVariableDescriptor &  inParameter0 COMMA_LOCATION_ARGS) {
  e_typeTableVariablesBool info ;
  info.mVariableDescriptor = inParameter0 ;
  insertKey (_inLexique, info, inKey, inKey, "the '%' variable has been already declared" COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableVariablesBool::methode_insertKeyGetIndex (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_typeVariableDescriptor &  inParameter0 COMMA_LOCATION_ARGS) {
  e_typeTableVariablesBool info ;
  info.mVariableDescriptor = inParameter0 ;
  const sint32 index = insertKey (_inLexique, info, inKey, inKey, "the '%' variable has been already declared" COMMA_THERE) ;
  outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeTableVariablesBool::reader_description (void) const {
  C_String s ;
  s << "<map @typeTableVariablesBool " ;
  if (isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s" : "") ;
  }else{
    s << "not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'typeRecordVariable'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeRecordVariable::cPtr_typeRecordVariable (const GGS_typeTableVariablesBool & argument_0 COMMA_LOCATION_ARGS)
:cPtr_typeVariableDescriptor (THERE),
mMap (argument_0) {
}


const char * cPtr_typeRecordVariable::message_variableDescriptorErrorMessage (void) const {
  return "a record domain variable" ;
}

const char * cPtr_typeRecordVariable::static_string_message_variableDescriptorErrorMessage (void) {
  return "a record domain variable" ;
}

//---------------------------------------------------------------------------*

void cPtr_typeRecordVariable::appendForDescription (C_String & ioString) const {
  ioString << "->@typeRecordVariable:" ;
mMap.reader_description () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeRecordVariable'                    *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeRecordVariable * GGS_typeRecordVariable::
    constructor_new (const GGS_typeTableVariablesBool & argument_0 COMMA_LOCATION_ARGS) {
    cPtr_typeRecordVariable * ptr_ = (cPtr_typeRecordVariable *) NULL ;
    macroMyNew (ptr_, cPtr_typeRecordVariable (argument_0 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                      class map 'typeTableFormules'                        *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeTableFormules::
elementOf_GGS_typeTableFormules (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_typeTableFormules & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeTableFormules::
appendForMapDescription (C_String & ioString) const {
  ioString << "["
           << mKey.reader_description () ;
  ioString << "->" ;
  ioString << mInfo.aListeArgsFormelsBool.reader_description () ;
  ioString << mInfo.aBDD.reader_description () ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_typeTableFormules::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_typeTableFormules *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_typeTableFormules * info = (e_typeTableFormules *) inInfo ;
  macroMyNew (p, element_type (inKey, count (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_typeTableFormules GGS_typeTableFormules::constructor_empty (UNUSED_LOCATION_ARGS) {
  GGS_typeTableFormules result ;
  macroMyNew (result.mReferenceCountPtr, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableFormules::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mRoot, extension, index, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableFormules::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_typeFormalArgumentsList &  inParameter0,
               const GGS_bdd&  inParameter1,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()) {
    insulateMap () ;
    e_typeTableFormules info  ;
    info.aListeArgsFormelsBool = inParameter0 ;
    info.aBDD = inParameter1 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mRoot, extension, index, existingKeyLocation) ;
    if (index < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTableFormules::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_typeFormalArgumentsList   & outParameter0,
               GGS_bdd  & outParameter1,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop_operation () ;
    outParameter1.drop_operation () ;
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.aListeArgsFormelsBool ;
    outParameter1 = node->mInfo.aBDD ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTableFormules::methode_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_typeFormalArgumentsList   & outParameter0,
                                GGS_bdd  & outParameter1 COMMA_LOCATION_ARGS) {
  searchElement (inLexique,
                 "the '#%K' formula is not defined",
                 inKey,
                 outParameter0,
                 outParameter1,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableFormules::methode_searchKeyGetIndex (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                GGS_typeFormalArgumentsList   & outParameter0,
                                GGS_bdd  & outParameter1 COMMA_LOCATION_ARGS) {
  searchElement (inLexique,
                 "the '#%K' formula is not defined",
                 inKey,
                 outParameter0,
                 outParameter1,
                 & outIndex
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableFormules::
methode_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_typeFormalArgumentsList & inParameter0,
                                const GGS_bdd& inParameter1 COMMA_LOCATION_ARGS) {
  insertElement (_inLexique,
                 "the '#%K' formula is already defined",
                 inKey,
                 inParameter0,
                 inParameter1,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableFormules::
methode_insertKeyGetIndex (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_typeFormalArgumentsList & inParameter0,
                                const GGS_bdd& inParameter1 COMMA_LOCATION_ARGS) {
  insertElement (_inLexique,
                 "the '#%K' formula is already defined",
                 inKey,
                 inParameter0,
                 inParameter1,
                 & outIndex
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeTableFormules::reader_description (void) const {
  C_String s ;
  s << "<map @typeTableFormules " ;
  if (isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (s) ;
      p = p->nextObject () ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    abstract class 'cPtr_typeFormule'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeFormule::
cPtr_typeFormule (LOCATION_ARGS)
:C_GGS_Object (THERE) {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_typeFormule'                       *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeFormule::
GGS_typeFormule (void) {
  mPointer = (cPtr_typeFormule *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeFormule::
GGS_typeFormule (const GGS_typeFormule & inOperand) {
  mPointer = (cPtr_typeFormule *) NULL ;
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeFormule::
~GGS_typeFormule (void) {
  macroDetachPointer (mPointer, cPtr_typeFormule) ;
}

//---------------------------------------------------------------------------*

void GGS_typeFormule::
operator = (const GGS_typeFormule & inOperand) {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

void GGS_typeFormule::
operator = (cPtr_typeFormule * inSource) {
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

GGS_typeFormule::
GGS_typeFormule (cPtr_typeFormule * inSource) {
  mPointer = (cPtr_typeFormule *) NULL ;
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeFormule * GGS_typeFormule
::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void GGS_typeFormule
::drop_operation (void) {
  macroDetachPointer (mPointer, cPtr_typeFormule) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeFormule
::reader_description (void) const {
  C_String s ;
  s << "<class @typeFormule" ;
  if (isBuilt ()) {
    mPointer->appendForDescription (s) ;
  }else{
    s << " not built" ;
  }
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'typeFormuleTrue'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeFormuleTrue::cPtr_typeFormuleTrue (LOCATION_ARGS)
:cPtr_typeFormule (THERE) {
}

//---------------------------------------------------------------------------*

void cPtr_typeFormuleTrue::appendForDescription (C_String & ioString) const {
  ioString << "->@typeFormuleTrue:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeFormuleTrue'                     *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeFormuleTrue * GGS_typeFormuleTrue::
    constructor_new (LOCATION_ARGS) {
    cPtr_typeFormuleTrue * ptr_ = (cPtr_typeFormuleTrue *) NULL ;
    macroMyNew (ptr_, cPtr_typeFormuleTrue (THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'typeFormuleFalse'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeFormuleFalse::cPtr_typeFormuleFalse (LOCATION_ARGS)
:cPtr_typeFormule (THERE) {
}

//---------------------------------------------------------------------------*

void cPtr_typeFormuleFalse::appendForDescription (C_String & ioString) const {
  ioString << "->@typeFormuleFalse:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeFormuleFalse'                     *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeFormuleFalse * GGS_typeFormuleFalse::
    constructor_new (LOCATION_ARGS) {
    cPtr_typeFormuleFalse * ptr_ = (cPtr_typeFormuleFalse *) NULL ;
    macroMyNew (ptr_, cPtr_typeFormuleFalse (THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'typeFormuleVar'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeFormuleVar::cPtr_typeFormuleVar (const GGS_luint & argument_0,
                                const GGS_luint & argument_1,
                                const GGS_luint & argument_2 COMMA_LOCATION_ARGS)
:cPtr_typeFormule (THERE),
mNumeroVariable (argument_0),
mLowBound (argument_1),
mHighBound (argument_2) {
}

//---------------------------------------------------------------------------*

void cPtr_typeFormuleVar::appendForDescription (C_String & ioString) const {
  ioString << "->@typeFormuleVar:" ;
mNumeroVariable.reader_description () ;
mLowBound.reader_description () ;
mHighBound.reader_description () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeFormuleVar'                      *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeFormuleVar * GGS_typeFormuleVar::
    constructor_new (const GGS_luint & argument_0,
                                const GGS_luint & argument_1,
                                const GGS_luint & argument_2 COMMA_LOCATION_ARGS) {
    cPtr_typeFormuleVar * ptr_ = (cPtr_typeFormuleVar *) NULL ;
    macroMyNew (ptr_, cPtr_typeFormuleVar (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'typeFormuleFor'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeFormuleFor::cPtr_typeFormuleFor (const GGS_luint & argument_0,
                                const GGS_typeActualArgumentsList & argument_1,
                                const GGS_bdd& argument_2,
                                const GGS_lbool & argument_3 COMMA_LOCATION_ARGS)
:cPtr_typeFormule (THERE),
mNumeroFormule (argument_0),
mListeArgsBool (argument_1),
mFormuleTraduite (argument_2),
mEstFormuleCourante (argument_3) {
}

//---------------------------------------------------------------------------*

void cPtr_typeFormuleFor::appendForDescription (C_String & ioString) const {
  ioString << "->@typeFormuleFor:" ;
mNumeroFormule.reader_description () ;
mListeArgsBool.reader_description () ;
mFormuleTraduite.reader_description () ;
mEstFormuleCourante.reader_description () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeFormuleFor'                      *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeFormuleFor * GGS_typeFormuleFor::
    constructor_new (const GGS_luint & argument_0,
                                const GGS_typeActualArgumentsList & argument_1,
                                const GGS_bdd& argument_2,
                                const GGS_lbool & argument_3 COMMA_LOCATION_ARGS) {
    cPtr_typeFormuleFor * ptr_ = (cPtr_typeFormuleFor *) NULL ;
    macroMyNew (ptr_, cPtr_typeFormuleFor (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'typeFormuleNon'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeFormuleNon::cPtr_typeFormuleNon (const GGS_typeFormule & argument_0 COMMA_LOCATION_ARGS)
:cPtr_typeFormule (THERE),
mOperand (argument_0) {
}

//---------------------------------------------------------------------------*

void cPtr_typeFormuleNon::appendForDescription (C_String & ioString) const {
  ioString << "->@typeFormuleNon:" ;
mOperand.reader_description () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeFormuleNon'                      *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeFormuleNon * GGS_typeFormuleNon::
    constructor_new (const GGS_typeFormule & argument_0 COMMA_LOCATION_ARGS) {
    cPtr_typeFormuleNon * ptr_ = (cPtr_typeFormuleNon *) NULL ;
    macroMyNew (ptr_, cPtr_typeFormuleNon (argument_0 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'typeFormuleEt'                            *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeFormuleEt::cPtr_typeFormuleEt (const GGS_typeFormule & argument_0,
                                const GGS_typeFormule & argument_1 COMMA_LOCATION_ARGS)
:cPtr_typeFormule (THERE),
mOperand1 (argument_0),
mOperand2 (argument_1) {
}

//---------------------------------------------------------------------------*

void cPtr_typeFormuleEt::appendForDescription (C_String & ioString) const {
  ioString << "->@typeFormuleEt:" ;
mOperand1.reader_description () ;
mOperand2.reader_description () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_typeFormuleEt'                      *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeFormuleEt * GGS_typeFormuleEt::
    constructor_new (const GGS_typeFormule & argument_0,
                                const GGS_typeFormule & argument_1 COMMA_LOCATION_ARGS) {
    cPtr_typeFormuleEt * ptr_ = (cPtr_typeFormuleEt *) NULL ;
    macroMyNew (ptr_, cPtr_typeFormuleEt (argument_0,
                                argument_1 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'typeFormuleIte'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeFormuleIte::cPtr_typeFormuleIte (const GGS_typeFormule & argument_0,
                                const GGS_typeFormule & argument_1,
                                const GGS_typeFormule & argument_2 COMMA_LOCATION_ARGS)
:cPtr_typeFormule (THERE),
mOperand1 (argument_0),
mOperand2 (argument_1),
mOperand3 (argument_2) {
}

//---------------------------------------------------------------------------*

void cPtr_typeFormuleIte::appendForDescription (C_String & ioString) const {
  ioString << "->@typeFormuleIte:" ;
mOperand1.reader_description () ;
mOperand2.reader_description () ;
mOperand3.reader_description () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeFormuleIte'                      *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeFormuleIte * GGS_typeFormuleIte::
    constructor_new (const GGS_typeFormule & argument_0,
                                const GGS_typeFormule & argument_1,
                                const GGS_typeFormule & argument_2 COMMA_LOCATION_ARGS) {
    cPtr_typeFormuleIte * ptr_ = (cPtr_typeFormuleIte *) NULL ;
    macroMyNew (ptr_, cPtr_typeFormuleIte (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'typeFormuleOu'                            *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeFormuleOu::cPtr_typeFormuleOu (const GGS_typeFormule & argument_0,
                                const GGS_typeFormule & argument_1 COMMA_LOCATION_ARGS)
:cPtr_typeFormule (THERE),
mOperand1 (argument_0),
mOperand2 (argument_1) {
}

//---------------------------------------------------------------------------*

void cPtr_typeFormuleOu::appendForDescription (C_String & ioString) const {
  ioString << "->@typeFormuleOu:" ;
mOperand1.reader_description () ;
mOperand2.reader_description () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_typeFormuleOu'                      *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeFormuleOu * GGS_typeFormuleOu::
    constructor_new (const GGS_typeFormule & argument_0,
                                const GGS_typeFormule & argument_1 COMMA_LOCATION_ARGS) {
    cPtr_typeFormuleOu * ptr_ = (cPtr_typeFormuleOu *) NULL ;
    macroMyNew (ptr_, cPtr_typeFormuleOu (argument_0,
                                argument_1 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'typeFormuleImplique'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeFormuleImplique::cPtr_typeFormuleImplique (const GGS_typeFormule & argument_0,
                                const GGS_typeFormule & argument_1 COMMA_LOCATION_ARGS)
:cPtr_typeFormule (THERE),
mOperand1 (argument_0),
mOperand2 (argument_1) {
}

//---------------------------------------------------------------------------*

void cPtr_typeFormuleImplique::appendForDescription (C_String & ioString) const {
  ioString << "->@typeFormuleImplique:" ;
mOperand1.reader_description () ;
mOperand2.reader_description () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeFormuleImplique'                   *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeFormuleImplique * GGS_typeFormuleImplique::
    constructor_new (const GGS_typeFormule & argument_0,
                                const GGS_typeFormule & argument_1 COMMA_LOCATION_ARGS) {
    cPtr_typeFormuleImplique * ptr_ = (cPtr_typeFormuleImplique *) NULL ;
    macroMyNew (ptr_, cPtr_typeFormuleImplique (argument_0,
                                argument_1 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'typeComparaisonFormules'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeComparaisonFormules::cPtr_typeComparaisonFormules (const GGS_luint & argument_0,
                                const GGS_typeFormule & argument_1,
                                const GGS_typeFormule & argument_2 COMMA_LOCATION_ARGS)
:cPtr_typeFormule (THERE),
mComparaison (argument_0),
mOperand1 (argument_1),
mOperand2 (argument_2) {
}

//---------------------------------------------------------------------------*

void cPtr_typeComparaisonFormules::appendForDescription (C_String & ioString) const {
  ioString << "->@typeComparaisonFormules:" ;
mComparaison.reader_description () ;
mOperand1.reader_description () ;
mOperand2.reader_description () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_typeComparaisonFormules'                 *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeComparaisonFormules * GGS_typeComparaisonFormules::
    constructor_new (const GGS_luint & argument_0,
                                const GGS_typeFormule & argument_1,
                                const GGS_typeFormule & argument_2 COMMA_LOCATION_ARGS) {
    cPtr_typeComparaisonFormules * ptr_ = (cPtr_typeComparaisonFormules *) NULL ;
    macroMyNew (ptr_, cPtr_typeComparaisonFormules (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'typeFormuleExist'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeFormuleExist::cPtr_typeFormuleExist (const GGS_typeFormalArgumentsList & argument_0,
                                const GGS_typeFormule & argument_1,
                                const GGS_bdd& argument_2 COMMA_LOCATION_ARGS)
:cPtr_typeFormule (THERE),
mListeArgsBooleens (argument_0),
mOperand (argument_1),
mContraints (argument_2) {
}

//---------------------------------------------------------------------------*

void cPtr_typeFormuleExist::appendForDescription (C_String & ioString) const {
  ioString << "->@typeFormuleExist:" ;
mListeArgsBooleens.reader_description () ;
mOperand.reader_description () ;
mContraints.reader_description () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeFormuleExist'                     *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeFormuleExist * GGS_typeFormuleExist::
    constructor_new (const GGS_typeFormalArgumentsList & argument_0,
                                const GGS_typeFormule & argument_1,
                                const GGS_bdd& argument_2 COMMA_LOCATION_ARGS) {
    cPtr_typeFormuleExist * ptr_ = (cPtr_typeFormuleExist *) NULL ;
    macroMyNew (ptr_, cPtr_typeFormuleExist (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'typeFormuleComparaisonValeur'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeFormuleComparaisonValeur::cPtr_typeFormuleComparaisonValeur (const GGS_luint & argument_0,
                                const GGS_luint & argument_1,
                                const GGS_luint & argument_2,
                                const GGS_luint & argument_3,
                                const GGS_luint & argument_4,
                                const GGS_luint & argument_5 COMMA_LOCATION_ARGS)
:cPtr_typeFormule (THERE),
mIndiceBDD (argument_0),
mDimension (argument_1),
mLowBound (argument_2),
mHighBound (argument_3),
mComparaison (argument_4),
mValeur (argument_5) {
}

//---------------------------------------------------------------------------*

void cPtr_typeFormuleComparaisonValeur::appendForDescription (C_String & ioString) const {
  ioString << "->@typeFormuleComparaisonValeur:" ;
mIndiceBDD.reader_description () ;
mDimension.reader_description () ;
mLowBound.reader_description () ;
mHighBound.reader_description () ;
mComparaison.reader_description () ;
mValeur.reader_description () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_typeFormuleComparaisonValeur'               *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeFormuleComparaisonValeur * GGS_typeFormuleComparaisonValeur::
    constructor_new (const GGS_luint & argument_0,
                                const GGS_luint & argument_1,
                                const GGS_luint & argument_2,
                                const GGS_luint & argument_3,
                                const GGS_luint & argument_4,
                                const GGS_luint & argument_5 COMMA_LOCATION_ARGS) {
    cPtr_typeFormuleComparaisonValeur * ptr_ = (cPtr_typeFormuleComparaisonValeur *) NULL ;
    macroMyNew (ptr_, cPtr_typeFormuleComparaisonValeur (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'typeFormuleComparaisonVariable'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeFormuleComparaisonVariable::cPtr_typeFormuleComparaisonVariable (const GGS_luint & argument_0,
                                const GGS_luint & argument_1,
                                const GGS_luint & argument_2,
                                const GGS_luint & argument_3,
                                const GGS_luint & argument_4,
                                const GGS_luint & argument_5,
                                const GGS_luint & argument_6,
                                const GGS_luint & argument_7 COMMA_LOCATION_ARGS)
:cPtr_typeFormule (THERE),
mIndiceBDDgauche (argument_0),
mDimension (argument_1),
mLeftLowBound (argument_2),
mLeftHighBound (argument_3),
mComparaison (argument_4),
mIndiceBDDdroite (argument_5),
mRightLowBound (argument_6),
mRightHighBound (argument_7) {
}

//---------------------------------------------------------------------------*

void cPtr_typeFormuleComparaisonVariable::appendForDescription (C_String & ioString) const {
  ioString << "->@typeFormuleComparaisonVariable:" ;
mIndiceBDDgauche.reader_description () ;
mDimension.reader_description () ;
mLeftLowBound.reader_description () ;
mLeftHighBound.reader_description () ;
mComparaison.reader_description () ;
mIndiceBDDdroite.reader_description () ;
mRightLowBound.reader_description () ;
mRightHighBound.reader_description () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            GALGAS class 'GGS_typeFormuleComparaisonVariable'              *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeFormuleComparaisonVariable * GGS_typeFormuleComparaisonVariable::
    constructor_new (const GGS_luint & argument_0,
                                const GGS_luint & argument_1,
                                const GGS_luint & argument_2,
                                const GGS_luint & argument_3,
                                const GGS_luint & argument_4,
                                const GGS_luint & argument_5,
                                const GGS_luint & argument_6,
                                const GGS_luint & argument_7 COMMA_LOCATION_ARGS) {
    cPtr_typeFormuleComparaisonVariable * ptr_ = (cPtr_typeFormuleComparaisonVariable *) NULL ;
    macroMyNew (ptr_, cPtr_typeFormuleComparaisonVariable (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6,
                                argument_7 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                     abstract class 'cPtr_typeCalcul'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeCalcul::
cPtr_typeCalcul (LOCATION_ARGS)
:C_GGS_Object (THERE) {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_typeCalcul'                        *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeCalcul::
GGS_typeCalcul (void) {
  mPointer = (cPtr_typeCalcul *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeCalcul::
GGS_typeCalcul (const GGS_typeCalcul & inOperand) {
  mPointer = (cPtr_typeCalcul *) NULL ;
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeCalcul::
~GGS_typeCalcul (void) {
  macroDetachPointer (mPointer, cPtr_typeCalcul) ;
}

//---------------------------------------------------------------------------*

void GGS_typeCalcul::
operator = (const GGS_typeCalcul & inOperand) {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

void GGS_typeCalcul::
operator = (cPtr_typeCalcul * inSource) {
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

GGS_typeCalcul::
GGS_typeCalcul (cPtr_typeCalcul * inSource) {
  mPointer = (cPtr_typeCalcul *) NULL ;
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeCalcul * GGS_typeCalcul
::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void GGS_typeCalcul
::drop_operation (void) {
  macroDetachPointer (mPointer, cPtr_typeCalcul) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeCalcul
::reader_description (void) const {
  C_String s ;
  s << "<class @typeCalcul" ;
  if (isBuilt ()) {
    mPointer->appendForDescription (s) ;
  }else{
    s << " not built" ;
  }
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'typeCalculSimple'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeCalculSimple::cPtr_typeCalculSimple (const GGS_luint & argument_0,
                                const GGS_typeFormule & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_typeTableVariablesBool & argument_3,
                                const GGS_luint & argument_4 COMMA_LOCATION_ARGS)
:cPtr_typeCalcul (THERE),
mNumeroFormule (argument_0),
mFormule (argument_1),
mNomFormule (argument_2),
mTableVariablesBool (argument_3),
mAfficher (argument_4) {
}

//---------------------------------------------------------------------------*

void cPtr_typeCalculSimple::appendForDescription (C_String & ioString) const {
  ioString << "->@typeCalculSimple:" ;
mNumeroFormule.reader_description () ;
mFormule.reader_description () ;
mNomFormule.reader_description () ;
mTableVariablesBool.reader_description () ;
mAfficher.reader_description () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeCalculSimple'                     *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeCalculSimple * GGS_typeCalculSimple::
    constructor_new (const GGS_luint & argument_0,
                                const GGS_typeFormule & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_typeTableVariablesBool & argument_3,
                                const GGS_luint & argument_4 COMMA_LOCATION_ARGS) {
    cPtr_typeCalculSimple * ptr_ = (cPtr_typeCalculSimple *) NULL ;
    macroMyNew (ptr_, cPtr_typeCalculSimple (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                           class 'typeUse_AND'                             *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeUse_AND::cPtr_typeUse_AND (LOCATION_ARGS)
:cPtr_typeCalcul (THERE) {
}

//---------------------------------------------------------------------------*

void cPtr_typeUse_AND::appendForDescription (C_String & ioString) const {
  ioString << "->@typeUse_AND:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_typeUse_AND'                       *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeUse_AND * GGS_typeUse_AND::
    constructor_new (LOCATION_ARGS) {
    cPtr_typeUse_AND * ptr_ = (cPtr_typeUse_AND *) NULL ;
    macroMyNew (ptr_, cPtr_typeUse_AND (THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                           class 'typeUse_ITE'                             *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeUse_ITE::cPtr_typeUse_ITE (LOCATION_ARGS)
:cPtr_typeCalcul (THERE) {
}

//---------------------------------------------------------------------------*

void cPtr_typeUse_ITE::appendForDescription (C_String & ioString) const {
  ioString << "->@typeUse_ITE:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_typeUse_ITE'                       *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeUse_ITE * GGS_typeUse_ITE::
    constructor_new (LOCATION_ARGS) {
    cPtr_typeUse_ITE * ptr_ = (cPtr_typeUse_ITE *) NULL ;
    macroMyNew (ptr_, cPtr_typeUse_ITE (THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'typeUse_AND_ITE'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeUse_AND_ITE::cPtr_typeUse_AND_ITE (LOCATION_ARGS)
:cPtr_typeCalcul (THERE) {
}

//---------------------------------------------------------------------------*

void cPtr_typeUse_AND_ITE::appendForDescription (C_String & ioString) const {
  ioString << "->@typeUse_AND_ITE:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeUse_AND_ITE'                     *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeUse_AND_ITE * GGS_typeUse_AND_ITE::
    constructor_new (LOCATION_ARGS) {
    cPtr_typeUse_AND_ITE * ptr_ = (cPtr_typeUse_AND_ITE *) NULL ;
    macroMyNew (ptr_, cPtr_typeUse_AND_ITE (THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'typeDimensionnerANDCache'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeDimensionnerANDCache::cPtr_typeDimensionnerANDCache (const GGS_luint & argument_0 COMMA_LOCATION_ARGS)
:cPtr_typeCalcul (THERE),
mDimensionCache (argument_0) {
}

//---------------------------------------------------------------------------*

void cPtr_typeDimensionnerANDCache::appendForDescription (C_String & ioString) const {
  ioString << "->@typeDimensionnerANDCache:" ;
mDimensionCache.reader_description () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeDimensionnerANDCache'                 *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeDimensionnerANDCache * GGS_typeDimensionnerANDCache::
    constructor_new (const GGS_luint & argument_0 COMMA_LOCATION_ARGS) {
    cPtr_typeDimensionnerANDCache * ptr_ = (cPtr_typeDimensionnerANDCache *) NULL ;
    macroMyNew (ptr_, cPtr_typeDimensionnerANDCache (argument_0 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'typeDimensionnerITECache'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeDimensionnerITECache::cPtr_typeDimensionnerITECache (const GGS_luint & argument_0 COMMA_LOCATION_ARGS)
:cPtr_typeCalcul (THERE),
mDimensionCache (argument_0) {
}

//---------------------------------------------------------------------------*

void cPtr_typeDimensionnerITECache::appendForDescription (C_String & ioString) const {
  ioString << "->@typeDimensionnerITECache:" ;
mDimensionCache.reader_description () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeDimensionnerITECache'                 *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeDimensionnerITECache * GGS_typeDimensionnerITECache::
    constructor_new (const GGS_luint & argument_0 COMMA_LOCATION_ARGS) {
    cPtr_typeDimensionnerITECache * ptr_ = (cPtr_typeDimensionnerITECache *) NULL ;
    macroMyNew (ptr_, cPtr_typeDimensionnerITECache (argument_0 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'typeDimensionnerTable'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeDimensionnerTable::cPtr_typeDimensionnerTable (const GGS_luint & argument_0 COMMA_LOCATION_ARGS)
:cPtr_typeCalcul (THERE),
mDimensionTable (argument_0) {
}

//---------------------------------------------------------------------------*

void cPtr_typeDimensionnerTable::appendForDescription (C_String & ioString) const {
  ioString << "->@typeDimensionnerTable:" ;
mDimensionTable.reader_description () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeDimensionnerTable'                  *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeDimensionnerTable * GGS_typeDimensionnerTable::
    constructor_new (const GGS_luint & argument_0 COMMA_LOCATION_ARGS) {
    cPtr_typeDimensionnerTable * ptr_ = (cPtr_typeDimensionnerTable *) NULL ;
    macroMyNew (ptr_, cPtr_typeDimensionnerTable (argument_0 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'typeAfficherBilan'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeAfficherBilan::cPtr_typeAfficherBilan (LOCATION_ARGS)
:cPtr_typeCalcul (THERE) {
}

//---------------------------------------------------------------------------*

void cPtr_typeAfficherBilan::appendForDescription (C_String & ioString) const {
  ioString << "->@typeAfficherBilan:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeAfficherBilan'                    *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeAfficherBilan * GGS_typeAfficherBilan::
    constructor_new (LOCATION_ARGS) {
    cPtr_typeAfficherBilan * ptr_ = (cPtr_typeAfficherBilan *) NULL ;
    macroMyNew (ptr_, cPtr_typeAfficherBilan (THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'typeCalculIteratif'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeCalculIteratif::cPtr_typeCalculIteratif (const GGS_luint & argument_0,
                                const GGS_typeFormule & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_typeTableVariablesBool & argument_3,
                                const GGS_lbool & argument_4,
                                const GGS_luint & argument_5 COMMA_LOCATION_ARGS)
:cPtr_typeCalcul (THERE),
mNumeroFormule (argument_0),
mFormule (argument_1),
mNomFormule (argument_2),
mTableVariablesBool (argument_3),
mSigne (argument_4),
mAfficher (argument_5) {
}

//---------------------------------------------------------------------------*

void cPtr_typeCalculIteratif::appendForDescription (C_String & ioString) const {
  ioString << "->@typeCalculIteratif:" ;
mNumeroFormule.reader_description () ;
mFormule.reader_description () ;
mNomFormule.reader_description () ;
mTableVariablesBool.reader_description () ;
mSigne.reader_description () ;
mAfficher.reader_description () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeCalculIteratif'                    *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeCalculIteratif * GGS_typeCalculIteratif::
    constructor_new (const GGS_luint & argument_0,
                                const GGS_typeFormule & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_typeTableVariablesBool & argument_3,
                                const GGS_lbool & argument_4,
                                const GGS_luint & argument_5 COMMA_LOCATION_ARGS) {
    cPtr_typeCalculIteratif * ptr_ = (cPtr_typeCalculIteratif *) NULL ;
    macroMyNew (ptr_, cPtr_typeCalculIteratif (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                   Element of list '@typeListeCalculs'                     *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeListeCalculs::
elementOf_GGS_typeListeCalculs (const GGS_typeCalcul & argument_0) {
  mNextItem = (elementOf_GGS_typeListeCalculs *) NULL ;
  mCalcul = argument_0 ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeListeCalculs::
appendForListDescription (C_String & ioString) const {
  ioString << "[" ;
  ioString << mCalcul.reader_description () ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         List '@typeListeCalculs'                          *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeListeCalculs
::GGS_typeListeCalculs (void) { // Default Constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  GGS_typeListeCalculs
::GGS_typeListeCalculs (UNUSED_LOCATION_ARGS) {
    mFirstItem = (element_type *) NULL ;
    mLastItem = (element_type *) NULL ;
    mListLength = 0 ;
    mCountReference = (sint32 *) NULL ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_typeListeCalculs::~GGS_typeListeCalculs (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*

GGS_typeListeCalculs::GGS_typeListeCalculs (const GGS_typeListeCalculs & source) { // Copy constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
  *this = source ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeCalculs
::operator = (const GGS_typeListeCalculs & source) { // Assignment operator
  if (this != & source) {
    emptyList () ;
    mFirstItem = source.mFirstItem ;
    mLastItem = source.mLastItem ;
    mListLength = source.mListLength ;
    mCountReference = source.mCountReference ;
    if (mCountReference != NULL) {
      macroValidPointer (mCountReference) ;
      (*mCountReference) ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeCalculs
::emptyList (void) {
  mListLength = 0 ;
  mLastItem = (element_type *) NULL ;
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) == 1) {
      macroMyDelete (mCountReference, sint32) ;
      while (mFirstItem != NULL) {
        macroValidPointer (mFirstItem) ;
        mLastItem = mFirstItem->mNextItem ;
        macroMyDelete (mFirstItem, element_type) ;
        mFirstItem = mLastItem ;
      }
    }else{
      mFirstItem = (element_type *) NULL ;
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeCalculs::
internalAppendItem (const GGS_typeCalcul & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mLastItem == NULL) {
      mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mLastItem) ;
      mLastItem->mNextItem = nouvelElement ;
    }
    mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeCalculs::
addAssign_operation (const GGS_typeCalcul & argument_0) {
  if (isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeCalculs::
insulateList (void) {
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) > 1) {
      element_type * p = mFirstItem ;
      mFirstItem = (element_type *)  NULL ;
      mLastItem = (element_type *)  NULL ;
      mListLength = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->mCalcul) ;
        p = p->mNextItem ;
      }
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
      macroMyNew (mCountReference, sint32 (1)) ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeListeCalculs  GGS_typeListeCalculs::
constructor_empty (UNUSED_LOCATION_ARGS) {
  GGS_typeListeCalculs result ;
  macroMyNew (result.mCountReference, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeListeCalculs::reader_description (void) const {
  C_String s ;
  s << "<list @typeListeCalculs" ;
  if (isBuilt ()) {
    s << " " << mListLength << " object" << ((mListLength > 1) ? "s " : " ") ;
    element_type * p = mFirstItem ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForListDescription (s) ;
      p = p->mNextItem ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

void GGS_typeListeCalculs
::drop_operation (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//         Implementation of routine "verifierNombreArgumentsBool"           *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_verifierNombreArgumentsBool (C_Lexique & _inLexique,
                                const GGS_typeFormalArgumentsList  & var_cas_t1,
                                const GGS_typeActualArgumentsList  & var_cas_t2,
                                const GGS_location  & var_cas_positionFinListe COMMA_UNUSED_LOCATION_ARGS) {
  if (((var_cas_t1.reader_length ()) < (var_cas_t2.reader_length ())).isBuiltAndTrue ()) {
      var_cas_positionFinListe.reader_location ().signalGGSSemanticError (_inLexique, GGS_string (true, "too much actual arguments") SOURCE_FILE_AT_LINE (266)) ;
  }else if (((var_cas_t1.reader_length ()) > (var_cas_t2.reader_length ())).isBuiltAndTrue ()) {
      var_cas_positionFinListe.reader_location ().signalGGSSemanticError (_inLexique, GGS_string (true, "one or more actual arguments missing") SOURCE_FILE_AT_LINE (268)) ;
  }
  GGS_typeFormalArgumentsList::element_type * operand_8048 = var_cas_t1.firstObject () ;
  GGS_typeActualArgumentsList::element_type * operand_8137 = var_cas_t2.firstObject () ;
  while ((operand_8048 != NULL)
      && (operand_8137 != NULL)) {
    macroValidPointer (operand_8048) ;
    macroValidPointer (operand_8137) ;
    if (((operand_8048->mVariableBitSize.reader_value ()) == (operand_8137->mVariableBitSize.reader_value ())).isBuiltAndTrue ()) {
      if (((operand_8048->mLowBound.reader_value ()) == (operand_8137->mLowBound.reader_value ())).isBuiltAndTrue ()) {
        if (((operand_8048->mHighBound.reader_value ()) == (operand_8137->mHighBound.reader_value ())).isBuiltAndTrue ()) {
        }else{
            operand_8137->mErrorLocation.reader_location ().signalGGSSemanticError (_inLexique, GGS_string (true, "the actual high bound is different the formal one") SOURCE_FILE_AT_LINE (276)) ;
        }
      }else{
          operand_8137->mErrorLocation.reader_location ().signalGGSSemanticError (_inLexique, GGS_string (true, "the actual low bound is different the formal one") SOURCE_FILE_AT_LINE (279)) ;
      }
    }else{
        operand_8137->mErrorLocation.reader_location ().signalGGSSemanticError (_inLexique, GGS_string (true, "the actual dimension is different from the formal one") SOURCE_FILE_AT_LINE (282)) ;
    }
    operand_8048 = operand_8048->nextObject () ;
    operand_8137 = operand_8137->nextObject () ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//             Implementation of routine "buildFormalArgsList"               *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_buildFormalArgsList (C_Lexique & _inLexique,
                                const GGS_typeVariableDescriptor  & var_cas_inVariableDescriptor,
                                GGS_typeFormalArgumentsList  & var_cas_ioFormalArgsList,
                                const GGS_location  & var_cas_inErrorLocation COMMA_UNUSED_LOCATION_ARGS) {
  if (var_cas_inVariableDescriptor.isBuilt ()) {
    if (dynamic_cast <cPtr_typeDirectVariable *> (var_cas_inVariableDescriptor.getPtr ()) != NULL) {
      cPtr_typeDirectVariable * operand_9026 = dynamic_cast <cPtr_typeDirectVariable *> (var_cas_inVariableDescriptor.getPtr ()) ;
      macroValidPointer (operand_9026) ; 
      var_cas_ioFormalArgsList.addAssign_operation (operand_9026->mIndex, operand_9026->mBitSize, operand_9026->mLowBound, operand_9026->mHighBound) ;
    }else if (dynamic_cast <cPtr_typeRecordVariable *> (var_cas_inVariableDescriptor.getPtr ()) != NULL) {
      cPtr_typeRecordVariable * operand_9212 = dynamic_cast <cPtr_typeRecordVariable *> (var_cas_inVariableDescriptor.getPtr ()) ;
      macroValidPointer (operand_9212) ; 
      GGS_typeTableVariablesBool::element_type * operand_9309 = operand_9212->mMap.firstObject () ;
      while ((operand_9309 != NULL)) {
        macroValidPointer (operand_9309) ;
        ::routine_buildFormalArgsList (_inLexique,  operand_9309->mInfo.mVariableDescriptor,  var_cas_ioFormalArgsList,  var_cas_inErrorLocation SOURCE_FILE_AT_LINE (299)) ;
        operand_9309 = operand_9309->nextObject () ;
      }
    }else{ // Else part
        var_cas_inErrorLocation.reader_location ().signalGGSSemanticError (_inLexique, ((GGS_string (true, "a variable was expected here ; I found ")) + (var_cas_inVariableDescriptor.reader_variableDescriptorErrorMessage ())) SOURCE_FILE_AT_LINE (302)) ;
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//             Implementation of routine "buildActualArgsList"               *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_buildActualArgsList (C_Lexique & _inLexique,
                                const GGS_typeTableVariablesBool  & var_cas_inDomainMap,
                                GGS_typeActualArgumentsList  & var_cas_ioActualArgsList,
                                const GGS_location  & var_cas_inErrorLocation COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeTableVariablesBool::element_type * operand_9884 = var_cas_inDomainMap.firstObject () ;
  while ((operand_9884 != NULL)) {
    macroValidPointer (operand_9884) ;
    if (operand_9884->mInfo.mVariableDescriptor.isBuilt ()) {
      if (dynamic_cast <cPtr_typeDirectVariable *> (operand_9884->mInfo.mVariableDescriptor.getPtr ()) != NULL) {
        cPtr_typeDirectVariable * operand_9993 = dynamic_cast <cPtr_typeDirectVariable *> (operand_9884->mInfo.mVariableDescriptor.getPtr ()) ;
        macroValidPointer (operand_9993) ; 
        var_cas_ioActualArgsList.addAssign_operation (operand_9993->mIndex, operand_9993->mBitSize, operand_9993->mLowBound, operand_9993->mHighBound, var_cas_inErrorLocation) ;
      }else if (dynamic_cast <cPtr_typeRecordVariable *> (operand_9884->mInfo.mVariableDescriptor.getPtr ()) != NULL) {
        cPtr_typeRecordVariable * operand_10200 = dynamic_cast <cPtr_typeRecordVariable *> (operand_9884->mInfo.mVariableDescriptor.getPtr ()) ;
        macroValidPointer (operand_10200) ; 
        ::routine_buildActualArgsList (_inLexique,  operand_10200->mMap,  var_cas_ioActualArgsList,  var_cas_inErrorLocation SOURCE_FILE_AT_LINE (318)) ;
      }else{ // Else part
          var_cas_inErrorLocation.reader_location ().signalGGSSemanticError (_inLexique, ((GGS_string (true, "a variable was expected here ; I found ")) + (operand_9884->mInfo.mVariableDescriptor.reader_variableDescriptorErrorMessage ())) SOURCE_FILE_AT_LINE (321)) ;
      }
    }
    operand_9884 = operand_9884->nextObject () ;
  }
}

//---------------------------------------------------------------------------*

