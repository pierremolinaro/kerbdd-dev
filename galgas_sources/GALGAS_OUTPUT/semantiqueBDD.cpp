//---------------------------------------------------------------------------*
//                                                                           *
//                         File 'semantiqueBDD.cpp'                          *
//         Generated by version GALGAS_BETA_VERSION (LL(1) grammar)          *
//                       may 12th, 2006, at 16h32'30"                        *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

#include "utilities/MF_MemoryControl.h"
#include "files/C_TextFileWrite.h"
#include "semantiqueBDD.h"

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  static const char gGGSsourceFile [] = "semantiqueBDD.ggs" ;
  #define SOURCE_FILE_AT_LINE(line) , gGGSsourceFile, line
#else
  #define SOURCE_FILE_AT_LINE(line) 
#endif


//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//                     abstract class 'cPtr_typeDomain'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeDomain::
cPtr_typeDomain (LOCATION_ARGS)
:C_GGS_Object (THERE) {
}

//---------------------------------------------------------------------------*

const char * cPtr_typeDomain
::static_string_message_messageDomainType (void) {
  return "any domain" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeDomain::
message_messageDomainType (void) const {
  return "any domain" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_typeDomain'                        *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeDomain::
GGS_typeDomain (void) {
  mPointer = (cPtr_typeDomain *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeDomain::
GGS_typeDomain (const GGS_typeDomain & inOperand) {
  mPointer = (cPtr_typeDomain *) NULL ;
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeDomain::
~GGS_typeDomain (void) {
  macroDetachPointer (mPointer, cPtr_typeDomain) ;
}

//---------------------------------------------------------------------------*

void GGS_typeDomain::
operator = (const GGS_typeDomain & inOperand) {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

void GGS_typeDomain::
operator = (cPtr_typeDomain * inSource) {
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

GGS_typeDomain::
GGS_typeDomain (cPtr_typeDomain * inSource) {
  mPointer = (cPtr_typeDomain *) NULL ;
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeDomain * GGS_typeDomain
::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_typeDomain::
reader_messageDomainType (C_Lexique & /* _inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  return GGS_string (mPointer != NULL, C_String ((mPointer == NULL) ? "" : mPointer->message_messageDomainType ())) ;
}

//---------------------------------------------------------------------------*

void GGS_typeDomain
::drop_operation (void) {
  macroDetachPointer (mPointer, cPtr_typeDomain) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeDomain
::reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<class @typeDomain" ;
  if (isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s COMMA_THERE) ;
  }else{
    s << " not built" ;
  }
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'typeDirectDomain'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeDirectDomain::cPtr_typeDirectDomain (const GGS_luint & argument_0,
                                const GGS_luint & argument_1,
                                const GGS_luint & argument_2 COMMA_LOCATION_ARGS)
:cPtr_typeDomain (THERE),
mLowBound (argument_0),
mHighBound (argument_1),
mBitsCount (argument_2) {
}


const char * cPtr_typeDirectDomain::message_messageDomainType (void) const {
  return "an interval domain" ;
}

const char * cPtr_typeDirectDomain::static_string_message_messageDomainType (void) {
  return "an interval domain" ;
}

//---------------------------------------------------------------------------*

void cPtr_typeDirectDomain::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@typeDirectDomain:" ;
mLowBound.reader_description  (_inLexique COMMA_THERE) ;
mHighBound.reader_description  (_inLexique COMMA_THERE) ;
mBitsCount.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeDirectDomain'                     *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeDirectDomain * GGS_typeDirectDomain::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_luint & argument_0,
                                const GGS_luint & argument_1,
                                const GGS_luint & argument_2 COMMA_LOCATION_ARGS) {
    cPtr_typeDirectDomain * ptr_ = (cPtr_typeDirectDomain *) NULL ;
    macroMyNew (ptr_, cPtr_typeDirectDomain (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                        class map 'typeDomainMap'                          *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeDomainMap::
elementOf_GGS_typeDomainMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_typeDomainMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeDomainMap::
appendForMapDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "["
           << mKey.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "->" ;
  ioString << mInfo.mDomain.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_typeDomainMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_typeDomainMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_typeDomainMap * info = (e_typeDomainMap *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_typeDomainMap GGS_typeDomainMap::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeDomainMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeDomainMap::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_typeDomainMap::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_typeDomain &  inParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()) {
    insulateMap () ;
    e_typeDomainMap info  ;
    info.mDomain = inParameter0 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
    if (index < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeDomainMap::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_typeDomain   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop_operation () ;
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mDomain ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeDomainMap::method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_typeDomain   & outParameter0 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 "the '%K' domain is not declared",
                 inKey,
                 outParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeDomainMap::
method_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_typeDomain & inParameter0 COMMA_LOCATION_ARGS) {
  insertElement (_inLexique,
                 "the '%K' domain has been already declared",
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_typeDomainMap GGS_typeDomainMap::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_typeDomainMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeDomainMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mNextIndex = inMapToOverride.mSharedMapRoot->mNextIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeDomainMap GGS_typeDomainMap::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeDomainMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeDomainMap::reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<map @typeDomainMap " ;
  if (isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, s COMMA_THERE) ;
      p = p->nextObject () ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'typeRecordDomain'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeRecordDomain::cPtr_typeRecordDomain (const GGS_typeDomainMap & argument_0 COMMA_LOCATION_ARGS)
:cPtr_typeDomain (THERE),
mRecordMap (argument_0) {
}


const char * cPtr_typeRecordDomain::message_messageDomainType (void) const {
  return "a record domain" ;
}

const char * cPtr_typeRecordDomain::static_string_message_messageDomainType (void) {
  return "a record domain" ;
}

//---------------------------------------------------------------------------*

void cPtr_typeRecordDomain::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@typeRecordDomain:" ;
mRecordMap.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeRecordDomain'                     *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeRecordDomain * GGS_typeRecordDomain::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_typeDomainMap & argument_0 COMMA_LOCATION_ARGS) {
    cPtr_typeRecordDomain * ptr_ = (cPtr_typeRecordDomain *) NULL ;
    macroMyNew (ptr_, cPtr_typeRecordDomain (argument_0 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@typeFormalArgumentsList'                 *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeFormalArgumentsList::
elementOf_GGS_typeFormalArgumentsList (const GGS_luint & argument_0,
                                const GGS_luint & argument_1,
                                const GGS_luint & argument_2,
                                const GGS_luint & argument_3):
mNextItem (NULL),
mVariableIndex (argument_0),
mVariableBitSize (argument_1),
mLowBound (argument_2),
mHighBound (argument_3) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeFormalArgumentsList::
appendForListDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "[" ;
  ioString << mVariableIndex.reader_description  (_inLexique COMMA_THERE) ;
  ioString << mVariableBitSize.reader_description  (_inLexique COMMA_THERE) ;
  ioString << mLowBound.reader_description  (_inLexique COMMA_THERE) ;
  ioString << mHighBound.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     List '@typeFormalArgumentsList'                       *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeFormalArgumentsList::cRootList::cRootList (void):
mFirstItem (NULL),
mLastItem (NULL),
mListLength (0),
mCountReference (1) {
}

//---------------------------------------------------------------------------*

GGS_typeFormalArgumentsList::cRootList::~cRootList (void) {
  while (mFirstItem != NULL) {
    element_type * p = mFirstItem->nextObject () ;
    macroMyDelete (mFirstItem, element_type) ;
    mFirstItem = p ;
  }
}

//---------------------------------------------------------------------------*

GGS_typeFormalArgumentsList::GGS_typeFormalArgumentsList (void) { // Default Constructor
  mRoot = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeFormalArgumentsList::~GGS_typeFormalArgumentsList (void) {
  drop_operation () ;
}

//---------------------------------------------------------------------------*

GGS_typeFormalArgumentsList::
GGS_typeFormalArgumentsList (const GGS_typeFormalArgumentsList & inSource) {
  mRoot = inSource.mRoot ;
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    mRoot->mCountReference ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeFormalArgumentsList::
operator = (const GGS_typeFormalArgumentsList & inSource) {
  if (this != & inSource) {
    drop_operation () ;
    mRoot = inSource.mRoot ;
    if (mRoot != NULL) {
      macroValidPointer (mRoot) ;
      mRoot->mCountReference ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeFormalArgumentsList::element_type * GGS_typeFormalArgumentsList::
firstObject (void) const {
  return (mRoot == NULL) ? NULL : mRoot->mFirstItem ;
}

//---------------------------------------------------------------------------*

void GGS_typeFormalArgumentsList::
internalAppendItem (const GGS_luint & argument_0,
                    const GGS_luint & argument_1,
                    const GGS_luint & argument_2,
                    const GGS_luint & argument_3) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2,
                                argument_3)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mRoot->mLastItem == NULL) {
      mRoot->mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mRoot->mLastItem) ;
      mRoot->mLastItem->mNextItem = nouvelElement ;
    }
    mRoot->mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mRoot->mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeFormalArgumentsList::
addAssign_operation (const GGS_luint & argument_0,
                                const GGS_luint & argument_1,
                                const GGS_luint & argument_2,
                                const GGS_luint & argument_3) {
  if (isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0,
                                argument_1,
                                argument_2,
                                argument_3) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeFormalArgumentsList::
insulateList (void) {
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    if (mRoot->mCountReference > 1) {
      element_type * p = mRoot->mFirstItem ;
      mRoot->mCountReference -- ;
      mRoot = NULL ;
      macroMyNew (mRoot, cRootList) ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->mVariableIndex,
                                p->mVariableBitSize,
                                p->mLowBound,
                                p->mHighBound) ;
        p = p->mNextItem ;
      }
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeFormalArgumentsList  GGS_typeFormalArgumentsList::
constructor_emptyList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeFormalArgumentsList result ;
  macroMyNew (result.mRoot, cRootList) ;
  return result ;
}

//---------------------------------------------------------------------------*

sint32 GGS_typeFormalArgumentsList::
count (void) const {
  return (mRoot == NULL) ? 0 : mRoot->mListLength ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeFormalArgumentsList::
reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<list @typeFormalArgumentsList" ;
  if (isBuilt ()) {
    s << " " << mRoot->mListLength << " object" << ((mRoot->mListLength > 1) ? "s " : " ") ;
    element_type * p = mRoot->mFirstItem ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForListDescription (_inLexique, s COMMA_THERE) ;
      p = p->mNextItem ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

GGS_uint GGS_typeFormalArgumentsList::
reader_length (C_Lexique & /* inLexique */
               COMMA_UNUSED_LOCATION_ARGS) const {
  return GGS_uint (mRoot != NULL,
                   (mRoot == NULL) ? 0 : (uint32) mRoot->mListLength) ;
}

//---------------------------------------------------------------------------*

void GGS_typeFormalArgumentsList::
drop_operation (void) {
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    if (mRoot->mCountReference == 1) {
      macroMyDelete (mRoot, cRootList) ;
    }else{
      mRoot->mCountReference -- ;
      mRoot = NULL ;
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@typeActualArgumentsList'                 *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeActualArgumentsList::
elementOf_GGS_typeActualArgumentsList (const GGS_luint & argument_0,
                                const GGS_luint & argument_1,
                                const GGS_luint & argument_2,
                                const GGS_luint & argument_3,
                                const GGS_location & argument_4):
mNextItem (NULL),
mVariableIndex (argument_0),
mVariableBitSize (argument_1),
mLowBound (argument_2),
mHighBound (argument_3),
mErrorLocation (argument_4) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeActualArgumentsList::
appendForListDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "[" ;
  ioString << mVariableIndex.reader_description  (_inLexique COMMA_THERE) ;
  ioString << mVariableBitSize.reader_description  (_inLexique COMMA_THERE) ;
  ioString << mLowBound.reader_description  (_inLexique COMMA_THERE) ;
  ioString << mHighBound.reader_description  (_inLexique COMMA_THERE) ;
  ioString << mErrorLocation.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     List '@typeActualArgumentsList'                       *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeActualArgumentsList::cRootList::cRootList (void):
mFirstItem (NULL),
mLastItem (NULL),
mListLength (0),
mCountReference (1) {
}

//---------------------------------------------------------------------------*

GGS_typeActualArgumentsList::cRootList::~cRootList (void) {
  while (mFirstItem != NULL) {
    element_type * p = mFirstItem->nextObject () ;
    macroMyDelete (mFirstItem, element_type) ;
    mFirstItem = p ;
  }
}

//---------------------------------------------------------------------------*

GGS_typeActualArgumentsList::GGS_typeActualArgumentsList (void) { // Default Constructor
  mRoot = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeActualArgumentsList::~GGS_typeActualArgumentsList (void) {
  drop_operation () ;
}

//---------------------------------------------------------------------------*

GGS_typeActualArgumentsList::
GGS_typeActualArgumentsList (const GGS_typeActualArgumentsList & inSource) {
  mRoot = inSource.mRoot ;
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    mRoot->mCountReference ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeActualArgumentsList::
operator = (const GGS_typeActualArgumentsList & inSource) {
  if (this != & inSource) {
    drop_operation () ;
    mRoot = inSource.mRoot ;
    if (mRoot != NULL) {
      macroValidPointer (mRoot) ;
      mRoot->mCountReference ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeActualArgumentsList::element_type * GGS_typeActualArgumentsList::
firstObject (void) const {
  return (mRoot == NULL) ? NULL : mRoot->mFirstItem ;
}

//---------------------------------------------------------------------------*

void GGS_typeActualArgumentsList::
internalAppendItem (const GGS_luint & argument_0,
                    const GGS_luint & argument_1,
                    const GGS_luint & argument_2,
                    const GGS_luint & argument_3,
                    const GGS_location & argument_4) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mRoot->mLastItem == NULL) {
      mRoot->mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mRoot->mLastItem) ;
      mRoot->mLastItem->mNextItem = nouvelElement ;
    }
    mRoot->mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mRoot->mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeActualArgumentsList::
addAssign_operation (const GGS_luint & argument_0,
                                const GGS_luint & argument_1,
                                const GGS_luint & argument_2,
                                const GGS_luint & argument_3,
                                const GGS_location & argument_4) {
  if (isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeActualArgumentsList::
insulateList (void) {
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    if (mRoot->mCountReference > 1) {
      element_type * p = mRoot->mFirstItem ;
      mRoot->mCountReference -- ;
      mRoot = NULL ;
      macroMyNew (mRoot, cRootList) ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->mVariableIndex,
                                p->mVariableBitSize,
                                p->mLowBound,
                                p->mHighBound,
                                p->mErrorLocation) ;
        p = p->mNextItem ;
      }
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeActualArgumentsList  GGS_typeActualArgumentsList::
constructor_emptyList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeActualArgumentsList result ;
  macroMyNew (result.mRoot, cRootList) ;
  return result ;
}

//---------------------------------------------------------------------------*

sint32 GGS_typeActualArgumentsList::
count (void) const {
  return (mRoot == NULL) ? 0 : mRoot->mListLength ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeActualArgumentsList::
reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<list @typeActualArgumentsList" ;
  if (isBuilt ()) {
    s << " " << mRoot->mListLength << " object" << ((mRoot->mListLength > 1) ? "s " : " ") ;
    element_type * p = mRoot->mFirstItem ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForListDescription (_inLexique, s COMMA_THERE) ;
      p = p->mNextItem ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

GGS_uint GGS_typeActualArgumentsList::
reader_length (C_Lexique & /* inLexique */
               COMMA_UNUSED_LOCATION_ARGS) const {
  return GGS_uint (mRoot != NULL,
                   (mRoot == NULL) ? 0 : (uint32) mRoot->mListLength) ;
}

//---------------------------------------------------------------------------*

void GGS_typeActualArgumentsList::
drop_operation (void) {
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    if (mRoot->mCountReference == 1) {
      macroMyDelete (mRoot, cRootList) ;
    }else{
      mRoot->mCountReference -- ;
      mRoot = NULL ;
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//               abstract class 'cPtr_typeVariableDescriptor'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeVariableDescriptor::
cPtr_typeVariableDescriptor (LOCATION_ARGS)
:C_GGS_Object (THERE) {
}

//---------------------------------------------------------------------------*

const char * cPtr_typeVariableDescriptor
::static_string_message_variableDescriptorErrorMessage (void) {
  return "any variable" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeVariableDescriptor::
message_variableDescriptorErrorMessage (void) const {
  return "any variable" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_typeVariableDescriptor'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeVariableDescriptor::
GGS_typeVariableDescriptor (void) {
  mPointer = (cPtr_typeVariableDescriptor *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeVariableDescriptor::
GGS_typeVariableDescriptor (const GGS_typeVariableDescriptor & inOperand) {
  mPointer = (cPtr_typeVariableDescriptor *) NULL ;
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeVariableDescriptor::
~GGS_typeVariableDescriptor (void) {
  macroDetachPointer (mPointer, cPtr_typeVariableDescriptor) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariableDescriptor::
operator = (const GGS_typeVariableDescriptor & inOperand) {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariableDescriptor::
operator = (cPtr_typeVariableDescriptor * inSource) {
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

GGS_typeVariableDescriptor::
GGS_typeVariableDescriptor (cPtr_typeVariableDescriptor * inSource) {
  mPointer = (cPtr_typeVariableDescriptor *) NULL ;
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeVariableDescriptor * GGS_typeVariableDescriptor
::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_typeVariableDescriptor::
reader_variableDescriptorErrorMessage (C_Lexique & /* _inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  return GGS_string (mPointer != NULL, C_String ((mPointer == NULL) ? "" : mPointer->message_variableDescriptorErrorMessage ())) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariableDescriptor
::drop_operation (void) {
  macroDetachPointer (mPointer, cPtr_typeVariableDescriptor) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeVariableDescriptor
::reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<class @typeVariableDescriptor" ;
  if (isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s COMMA_THERE) ;
  }else{
    s << " not built" ;
  }
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'typeDirectVariable'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeDirectVariable::cPtr_typeDirectVariable (const GGS_luint & argument_0,
                                const GGS_luint & argument_1,
                                const GGS_luint & argument_2,
                                const GGS_luint & argument_3 COMMA_LOCATION_ARGS)
:cPtr_typeVariableDescriptor (THERE),
mIndex (argument_0),
mBitSize (argument_1),
mLowBound (argument_2),
mHighBound (argument_3) {
}


const char * cPtr_typeDirectVariable::message_variableDescriptorErrorMessage (void) const {
  return "a direct domain variable" ;
}

const char * cPtr_typeDirectVariable::static_string_message_variableDescriptorErrorMessage (void) {
  return "a direct domain variable" ;
}

//---------------------------------------------------------------------------*

void cPtr_typeDirectVariable::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@typeDirectVariable:" ;
mIndex.reader_description  (_inLexique COMMA_THERE) ;
mBitSize.reader_description  (_inLexique COMMA_THERE) ;
mLowBound.reader_description  (_inLexique COMMA_THERE) ;
mHighBound.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeDirectVariable'                    *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeDirectVariable * GGS_typeDirectVariable::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_luint & argument_0,
                                const GGS_luint & argument_1,
                                const GGS_luint & argument_2,
                                const GGS_luint & argument_3 COMMA_LOCATION_ARGS) {
    cPtr_typeDirectVariable * ptr_ = (cPtr_typeDirectVariable *) NULL ;
    macroMyNew (ptr_, cPtr_typeDirectVariable (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                    class map 'typeTableVariablesBool'                     *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeTableVariablesBool::
elementOf_GGS_typeTableVariablesBool (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_typeTableVariablesBool & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeTableVariablesBool::
appendForMapDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "["
           << mKey.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "->" ;
  ioString << mInfo.mVariableDescriptor.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_typeTableVariablesBool::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_typeTableVariablesBool *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_typeTableVariablesBool * info = (e_typeTableVariablesBool *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_typeTableVariablesBool GGS_typeTableVariablesBool::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeTableVariablesBool result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableVariablesBool::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableVariablesBool::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_typeVariableDescriptor &  inParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()) {
    insulateMap () ;
    e_typeTableVariablesBool info  ;
    info.mVariableDescriptor = inParameter0 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
    if (index < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTableVariablesBool::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_typeVariableDescriptor   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop_operation () ;
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mVariableDescriptor ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTableVariablesBool::method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_typeVariableDescriptor   & outParameter0 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 "the '%K' variable is not declared",
                 inKey,
                 outParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableVariablesBool::
method_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_typeVariableDescriptor & inParameter0 COMMA_LOCATION_ARGS) {
  insertElement (_inLexique,
                 "the '%K' variable has been already declared",
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_typeTableVariablesBool GGS_typeTableVariablesBool::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_typeTableVariablesBool & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeTableVariablesBool result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mNextIndex = inMapToOverride.mSharedMapRoot->mNextIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeTableVariablesBool GGS_typeTableVariablesBool::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeTableVariablesBool result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeTableVariablesBool::reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<map @typeTableVariablesBool " ;
  if (isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, s COMMA_THERE) ;
      p = p->nextObject () ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'typeRecordVariable'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeRecordVariable::cPtr_typeRecordVariable (const GGS_typeTableVariablesBool & argument_0 COMMA_LOCATION_ARGS)
:cPtr_typeVariableDescriptor (THERE),
mMap (argument_0) {
}


const char * cPtr_typeRecordVariable::message_variableDescriptorErrorMessage (void) const {
  return "a record domain variable" ;
}

const char * cPtr_typeRecordVariable::static_string_message_variableDescriptorErrorMessage (void) {
  return "a record domain variable" ;
}

//---------------------------------------------------------------------------*

void cPtr_typeRecordVariable::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@typeRecordVariable:" ;
mMap.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeRecordVariable'                    *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeRecordVariable * GGS_typeRecordVariable::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_typeTableVariablesBool & argument_0 COMMA_LOCATION_ARGS) {
    cPtr_typeRecordVariable * ptr_ = (cPtr_typeRecordVariable *) NULL ;
    macroMyNew (ptr_, cPtr_typeRecordVariable (argument_0 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                      class map 'typeTableFormules'                        *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeTableFormules::
elementOf_GGS_typeTableFormules (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_typeTableFormules & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeTableFormules::
appendForMapDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "["
           << mKey.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "->" ;
  ioString << mInfo.aListeArgsFormelsBool.reader_description  (_inLexique COMMA_THERE) ;
  ioString << mInfo.aBDD.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_typeTableFormules::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_typeTableFormules *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_typeTableFormules * info = (e_typeTableFormules *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_typeTableFormules GGS_typeTableFormules::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeTableFormules result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableFormules::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableFormules::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_typeFormalArgumentsList &  inParameter0,
               const GGS_bdd&  inParameter1,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()) {
    insulateMap () ;
    e_typeTableFormules info  ;
    info.aListeArgsFormelsBool = inParameter0 ;
    info.aBDD = inParameter1 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->mRoot, extension, index, existingKeyLocation) ;
    if (index < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTableFormules::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_typeFormalArgumentsList   & outParameter0,
               GGS_bdd  & outParameter1,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop_operation () ;
    outParameter1.drop_operation () ;
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.aListeArgsFormelsBool ;
    outParameter1 = node->mInfo.aBDD ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTableFormules::method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_typeFormalArgumentsList   & outParameter0,
                                GGS_bdd  & outParameter1 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 "the '#%K' formula is not defined",
                 inKey,
                 outParameter0,
                 outParameter1,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableFormules::method_searchKeyGetIndex (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                GGS_typeFormalArgumentsList   & outParameter0,
                                GGS_bdd  & outParameter1 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 "the '#%K' formula is not defined",
                 inKey,
                 outParameter0,
                 outParameter1,
                 & outIndex
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableFormules::
method_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_typeFormalArgumentsList & inParameter0,
                                const GGS_bdd& inParameter1 COMMA_LOCATION_ARGS) {
  insertElement (_inLexique,
                 "the '#%K' formula is already defined",
                 inKey,
                 inParameter0,
                 inParameter1,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableFormules::
method_insertKeyGetIndex (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_typeFormalArgumentsList & inParameter0,
                                const GGS_bdd& inParameter1 COMMA_LOCATION_ARGS) {
  insertElement (_inLexique,
                 "the '#%K' formula is already defined",
                 inKey,
                 inParameter0,
                 inParameter1,
                 & outIndex
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_typeTableFormules GGS_typeTableFormules::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_typeTableFormules & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeTableFormules result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mNextIndex = inMapToOverride.mSharedMapRoot->mNextIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeTableFormules GGS_typeTableFormules::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeTableFormules result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeTableFormules::reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<map @typeTableFormules " ;
  if (isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, s COMMA_THERE) ;
      p = p->nextObject () ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    abstract class 'cPtr_typeFormule'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeFormule::
cPtr_typeFormule (LOCATION_ARGS)
:C_GGS_Object (THERE) {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_typeFormule'                       *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeFormule::
GGS_typeFormule (void) {
  mPointer = (cPtr_typeFormule *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeFormule::
GGS_typeFormule (const GGS_typeFormule & inOperand) {
  mPointer = (cPtr_typeFormule *) NULL ;
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeFormule::
~GGS_typeFormule (void) {
  macroDetachPointer (mPointer, cPtr_typeFormule) ;
}

//---------------------------------------------------------------------------*

void GGS_typeFormule::
operator = (const GGS_typeFormule & inOperand) {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

void GGS_typeFormule::
operator = (cPtr_typeFormule * inSource) {
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

GGS_typeFormule::
GGS_typeFormule (cPtr_typeFormule * inSource) {
  mPointer = (cPtr_typeFormule *) NULL ;
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeFormule * GGS_typeFormule
::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void GGS_typeFormule
::drop_operation (void) {
  macroDetachPointer (mPointer, cPtr_typeFormule) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeFormule
::reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<class @typeFormule" ;
  if (isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s COMMA_THERE) ;
  }else{
    s << " not built" ;
  }
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'typeFormuleTrue'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeFormuleTrue::cPtr_typeFormuleTrue (LOCATION_ARGS)
:cPtr_typeFormule (THERE) {
}

//---------------------------------------------------------------------------*

void cPtr_typeFormuleTrue::appendForDescription (C_Lexique & /* _inLexique */, C_String & ioString COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeFormuleTrue:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeFormuleTrue'                     *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeFormuleTrue * GGS_typeFormuleTrue::
constructor_new (C_Lexique & /* inLexique */ COMMA_LOCATION_ARGS) {
    cPtr_typeFormuleTrue * ptr_ = (cPtr_typeFormuleTrue *) NULL ;
    macroMyNew (ptr_, cPtr_typeFormuleTrue (THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'typeFormuleFalse'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeFormuleFalse::cPtr_typeFormuleFalse (LOCATION_ARGS)
:cPtr_typeFormule (THERE) {
}

//---------------------------------------------------------------------------*

void cPtr_typeFormuleFalse::appendForDescription (C_Lexique & /* _inLexique */, C_String & ioString COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeFormuleFalse:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeFormuleFalse'                     *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeFormuleFalse * GGS_typeFormuleFalse::
constructor_new (C_Lexique & /* inLexique */ COMMA_LOCATION_ARGS) {
    cPtr_typeFormuleFalse * ptr_ = (cPtr_typeFormuleFalse *) NULL ;
    macroMyNew (ptr_, cPtr_typeFormuleFalse (THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'typeFormuleVar'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeFormuleVar::cPtr_typeFormuleVar (const GGS_luint & argument_0,
                                const GGS_luint & argument_1,
                                const GGS_luint & argument_2 COMMA_LOCATION_ARGS)
:cPtr_typeFormule (THERE),
mNumeroVariable (argument_0),
mLowBound (argument_1),
mHighBound (argument_2) {
}

//---------------------------------------------------------------------------*

void cPtr_typeFormuleVar::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@typeFormuleVar:" ;
mNumeroVariable.reader_description  (_inLexique COMMA_THERE) ;
mLowBound.reader_description  (_inLexique COMMA_THERE) ;
mHighBound.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeFormuleVar'                      *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeFormuleVar * GGS_typeFormuleVar::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_luint & argument_0,
                                const GGS_luint & argument_1,
                                const GGS_luint & argument_2 COMMA_LOCATION_ARGS) {
    cPtr_typeFormuleVar * ptr_ = (cPtr_typeFormuleVar *) NULL ;
    macroMyNew (ptr_, cPtr_typeFormuleVar (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'typeFormuleFor'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeFormuleFor::cPtr_typeFormuleFor (const GGS_luint & argument_0,
                                const GGS_typeActualArgumentsList & argument_1,
                                const GGS_bdd& argument_2,
                                const GGS_lbool & argument_3 COMMA_LOCATION_ARGS)
:cPtr_typeFormule (THERE),
mNumeroFormule (argument_0),
mListeArgsBool (argument_1),
mFormuleTraduite (argument_2),
mEstFormuleCourante (argument_3) {
}

//---------------------------------------------------------------------------*

void cPtr_typeFormuleFor::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@typeFormuleFor:" ;
mNumeroFormule.reader_description  (_inLexique COMMA_THERE) ;
mListeArgsBool.reader_description  (_inLexique COMMA_THERE) ;
mFormuleTraduite.reader_description  (_inLexique COMMA_THERE) ;
mEstFormuleCourante.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeFormuleFor'                      *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeFormuleFor * GGS_typeFormuleFor::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_luint & argument_0,
                                const GGS_typeActualArgumentsList & argument_1,
                                const GGS_bdd& argument_2,
                                const GGS_lbool & argument_3 COMMA_LOCATION_ARGS) {
    cPtr_typeFormuleFor * ptr_ = (cPtr_typeFormuleFor *) NULL ;
    macroMyNew (ptr_, cPtr_typeFormuleFor (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'typeFormuleNon'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeFormuleNon::cPtr_typeFormuleNon (const GGS_typeFormule & argument_0 COMMA_LOCATION_ARGS)
:cPtr_typeFormule (THERE),
mOperand (argument_0) {
}

//---------------------------------------------------------------------------*

void cPtr_typeFormuleNon::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@typeFormuleNon:" ;
mOperand.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeFormuleNon'                      *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeFormuleNon * GGS_typeFormuleNon::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_typeFormule & argument_0 COMMA_LOCATION_ARGS) {
    cPtr_typeFormuleNon * ptr_ = (cPtr_typeFormuleNon *) NULL ;
    macroMyNew (ptr_, cPtr_typeFormuleNon (argument_0 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'typeFormuleEt'                            *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeFormuleEt::cPtr_typeFormuleEt (const GGS_typeFormule & argument_0,
                                const GGS_typeFormule & argument_1 COMMA_LOCATION_ARGS)
:cPtr_typeFormule (THERE),
mOperand1 (argument_0),
mOperand2 (argument_1) {
}

//---------------------------------------------------------------------------*

void cPtr_typeFormuleEt::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@typeFormuleEt:" ;
mOperand1.reader_description  (_inLexique COMMA_THERE) ;
mOperand2.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_typeFormuleEt'                      *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeFormuleEt * GGS_typeFormuleEt::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_typeFormule & argument_0,
                                const GGS_typeFormule & argument_1 COMMA_LOCATION_ARGS) {
    cPtr_typeFormuleEt * ptr_ = (cPtr_typeFormuleEt *) NULL ;
    macroMyNew (ptr_, cPtr_typeFormuleEt (argument_0,
                                argument_1 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'typeFormuleIte'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeFormuleIte::cPtr_typeFormuleIte (const GGS_typeFormule & argument_0,
                                const GGS_typeFormule & argument_1,
                                const GGS_typeFormule & argument_2 COMMA_LOCATION_ARGS)
:cPtr_typeFormule (THERE),
mOperand1 (argument_0),
mOperand2 (argument_1),
mOperand3 (argument_2) {
}

//---------------------------------------------------------------------------*

void cPtr_typeFormuleIte::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@typeFormuleIte:" ;
mOperand1.reader_description  (_inLexique COMMA_THERE) ;
mOperand2.reader_description  (_inLexique COMMA_THERE) ;
mOperand3.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeFormuleIte'                      *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeFormuleIte * GGS_typeFormuleIte::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_typeFormule & argument_0,
                                const GGS_typeFormule & argument_1,
                                const GGS_typeFormule & argument_2 COMMA_LOCATION_ARGS) {
    cPtr_typeFormuleIte * ptr_ = (cPtr_typeFormuleIte *) NULL ;
    macroMyNew (ptr_, cPtr_typeFormuleIte (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'typeFormuleOu'                            *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeFormuleOu::cPtr_typeFormuleOu (const GGS_typeFormule & argument_0,
                                const GGS_typeFormule & argument_1 COMMA_LOCATION_ARGS)
:cPtr_typeFormule (THERE),
mOperand1 (argument_0),
mOperand2 (argument_1) {
}

//---------------------------------------------------------------------------*

void cPtr_typeFormuleOu::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@typeFormuleOu:" ;
mOperand1.reader_description  (_inLexique COMMA_THERE) ;
mOperand2.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_typeFormuleOu'                      *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeFormuleOu * GGS_typeFormuleOu::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_typeFormule & argument_0,
                                const GGS_typeFormule & argument_1 COMMA_LOCATION_ARGS) {
    cPtr_typeFormuleOu * ptr_ = (cPtr_typeFormuleOu *) NULL ;
    macroMyNew (ptr_, cPtr_typeFormuleOu (argument_0,
                                argument_1 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'typeFormuleImplique'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeFormuleImplique::cPtr_typeFormuleImplique (const GGS_typeFormule & argument_0,
                                const GGS_typeFormule & argument_1 COMMA_LOCATION_ARGS)
:cPtr_typeFormule (THERE),
mOperand1 (argument_0),
mOperand2 (argument_1) {
}

//---------------------------------------------------------------------------*

void cPtr_typeFormuleImplique::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@typeFormuleImplique:" ;
mOperand1.reader_description  (_inLexique COMMA_THERE) ;
mOperand2.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeFormuleImplique'                   *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeFormuleImplique * GGS_typeFormuleImplique::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_typeFormule & argument_0,
                                const GGS_typeFormule & argument_1 COMMA_LOCATION_ARGS) {
    cPtr_typeFormuleImplique * ptr_ = (cPtr_typeFormuleImplique *) NULL ;
    macroMyNew (ptr_, cPtr_typeFormuleImplique (argument_0,
                                argument_1 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'typeComparaisonFormules'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeComparaisonFormules::cPtr_typeComparaisonFormules (const GGS_luint & argument_0,
                                const GGS_typeFormule & argument_1,
                                const GGS_typeFormule & argument_2 COMMA_LOCATION_ARGS)
:cPtr_typeFormule (THERE),
mComparaison (argument_0),
mOperand1 (argument_1),
mOperand2 (argument_2) {
}

//---------------------------------------------------------------------------*

void cPtr_typeComparaisonFormules::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@typeComparaisonFormules:" ;
mComparaison.reader_description  (_inLexique COMMA_THERE) ;
mOperand1.reader_description  (_inLexique COMMA_THERE) ;
mOperand2.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_typeComparaisonFormules'                 *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeComparaisonFormules * GGS_typeComparaisonFormules::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_luint & argument_0,
                                const GGS_typeFormule & argument_1,
                                const GGS_typeFormule & argument_2 COMMA_LOCATION_ARGS) {
    cPtr_typeComparaisonFormules * ptr_ = (cPtr_typeComparaisonFormules *) NULL ;
    macroMyNew (ptr_, cPtr_typeComparaisonFormules (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'typeFormuleExist'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeFormuleExist::cPtr_typeFormuleExist (const GGS_typeFormalArgumentsList & argument_0,
                                const GGS_typeFormule & argument_1,
                                const GGS_bdd& argument_2 COMMA_LOCATION_ARGS)
:cPtr_typeFormule (THERE),
mListeArgsBooleens (argument_0),
mOperand (argument_1),
mContraints (argument_2) {
}

//---------------------------------------------------------------------------*

void cPtr_typeFormuleExist::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@typeFormuleExist:" ;
mListeArgsBooleens.reader_description  (_inLexique COMMA_THERE) ;
mOperand.reader_description  (_inLexique COMMA_THERE) ;
mContraints.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeFormuleExist'                     *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeFormuleExist * GGS_typeFormuleExist::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_typeFormalArgumentsList & argument_0,
                                const GGS_typeFormule & argument_1,
                                const GGS_bdd& argument_2 COMMA_LOCATION_ARGS) {
    cPtr_typeFormuleExist * ptr_ = (cPtr_typeFormuleExist *) NULL ;
    macroMyNew (ptr_, cPtr_typeFormuleExist (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'typeFormuleComparaisonValeur'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeFormuleComparaisonValeur::cPtr_typeFormuleComparaisonValeur (const GGS_luint & argument_0,
                                const GGS_luint & argument_1,
                                const GGS_luint & argument_2,
                                const GGS_luint & argument_3,
                                const GGS_luint & argument_4,
                                const GGS_luint & argument_5 COMMA_LOCATION_ARGS)
:cPtr_typeFormule (THERE),
mIndiceBDD (argument_0),
mDimension (argument_1),
mLowBound (argument_2),
mHighBound (argument_3),
mComparaison (argument_4),
mValeur (argument_5) {
}

//---------------------------------------------------------------------------*

void cPtr_typeFormuleComparaisonValeur::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@typeFormuleComparaisonValeur:" ;
mIndiceBDD.reader_description  (_inLexique COMMA_THERE) ;
mDimension.reader_description  (_inLexique COMMA_THERE) ;
mLowBound.reader_description  (_inLexique COMMA_THERE) ;
mHighBound.reader_description  (_inLexique COMMA_THERE) ;
mComparaison.reader_description  (_inLexique COMMA_THERE) ;
mValeur.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_typeFormuleComparaisonValeur'               *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeFormuleComparaisonValeur * GGS_typeFormuleComparaisonValeur::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_luint & argument_0,
                                const GGS_luint & argument_1,
                                const GGS_luint & argument_2,
                                const GGS_luint & argument_3,
                                const GGS_luint & argument_4,
                                const GGS_luint & argument_5 COMMA_LOCATION_ARGS) {
    cPtr_typeFormuleComparaisonValeur * ptr_ = (cPtr_typeFormuleComparaisonValeur *) NULL ;
    macroMyNew (ptr_, cPtr_typeFormuleComparaisonValeur (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'typeFormuleComparaisonVariable'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeFormuleComparaisonVariable::cPtr_typeFormuleComparaisonVariable (const GGS_luint & argument_0,
                                const GGS_luint & argument_1,
                                const GGS_luint & argument_2,
                                const GGS_luint & argument_3,
                                const GGS_luint & argument_4,
                                const GGS_luint & argument_5,
                                const GGS_luint & argument_6,
                                const GGS_luint & argument_7 COMMA_LOCATION_ARGS)
:cPtr_typeFormule (THERE),
mIndiceBDDgauche (argument_0),
mDimension (argument_1),
mLeftLowBound (argument_2),
mLeftHighBound (argument_3),
mComparaison (argument_4),
mIndiceBDDdroite (argument_5),
mRightLowBound (argument_6),
mRightHighBound (argument_7) {
}

//---------------------------------------------------------------------------*

void cPtr_typeFormuleComparaisonVariable::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@typeFormuleComparaisonVariable:" ;
mIndiceBDDgauche.reader_description  (_inLexique COMMA_THERE) ;
mDimension.reader_description  (_inLexique COMMA_THERE) ;
mLeftLowBound.reader_description  (_inLexique COMMA_THERE) ;
mLeftHighBound.reader_description  (_inLexique COMMA_THERE) ;
mComparaison.reader_description  (_inLexique COMMA_THERE) ;
mIndiceBDDdroite.reader_description  (_inLexique COMMA_THERE) ;
mRightLowBound.reader_description  (_inLexique COMMA_THERE) ;
mRightHighBound.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            GALGAS class 'GGS_typeFormuleComparaisonVariable'              *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeFormuleComparaisonVariable * GGS_typeFormuleComparaisonVariable::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_luint & argument_0,
                                const GGS_luint & argument_1,
                                const GGS_luint & argument_2,
                                const GGS_luint & argument_3,
                                const GGS_luint & argument_4,
                                const GGS_luint & argument_5,
                                const GGS_luint & argument_6,
                                const GGS_luint & argument_7 COMMA_LOCATION_ARGS) {
    cPtr_typeFormuleComparaisonVariable * ptr_ = (cPtr_typeFormuleComparaisonVariable *) NULL ;
    macroMyNew (ptr_, cPtr_typeFormuleComparaisonVariable (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6,
                                argument_7 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                     abstract class 'cPtr_typeCalcul'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeCalcul::
cPtr_typeCalcul (LOCATION_ARGS)
:C_GGS_Object (THERE) {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_typeCalcul'                        *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeCalcul::
GGS_typeCalcul (void) {
  mPointer = (cPtr_typeCalcul *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeCalcul::
GGS_typeCalcul (const GGS_typeCalcul & inOperand) {
  mPointer = (cPtr_typeCalcul *) NULL ;
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeCalcul::
~GGS_typeCalcul (void) {
  macroDetachPointer (mPointer, cPtr_typeCalcul) ;
}

//---------------------------------------------------------------------------*

void GGS_typeCalcul::
operator = (const GGS_typeCalcul & inOperand) {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

void GGS_typeCalcul::
operator = (cPtr_typeCalcul * inSource) {
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

GGS_typeCalcul::
GGS_typeCalcul (cPtr_typeCalcul * inSource) {
  mPointer = (cPtr_typeCalcul *) NULL ;
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeCalcul * GGS_typeCalcul
::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void GGS_typeCalcul
::drop_operation (void) {
  macroDetachPointer (mPointer, cPtr_typeCalcul) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeCalcul
::reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<class @typeCalcul" ;
  if (isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s COMMA_THERE) ;
  }else{
    s << " not built" ;
  }
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'typeCalculSimple'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeCalculSimple::cPtr_typeCalculSimple (const GGS_luint & argument_0,
                                const GGS_typeFormule & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_typeTableVariablesBool & argument_3,
                                const GGS_luint & argument_4 COMMA_LOCATION_ARGS)
:cPtr_typeCalcul (THERE),
mNumeroFormule (argument_0),
mFormule (argument_1),
mNomFormule (argument_2),
mTableVariablesBool (argument_3),
mAfficher (argument_4) {
}

//---------------------------------------------------------------------------*

void cPtr_typeCalculSimple::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@typeCalculSimple:" ;
mNumeroFormule.reader_description  (_inLexique COMMA_THERE) ;
mFormule.reader_description  (_inLexique COMMA_THERE) ;
mNomFormule.reader_description  (_inLexique COMMA_THERE) ;
mTableVariablesBool.reader_description  (_inLexique COMMA_THERE) ;
mAfficher.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeCalculSimple'                     *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeCalculSimple * GGS_typeCalculSimple::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_luint & argument_0,
                                const GGS_typeFormule & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_typeTableVariablesBool & argument_3,
                                const GGS_luint & argument_4 COMMA_LOCATION_ARGS) {
    cPtr_typeCalculSimple * ptr_ = (cPtr_typeCalculSimple *) NULL ;
    macroMyNew (ptr_, cPtr_typeCalculSimple (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                           class 'typeUse_AND'                             *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeUse_AND::cPtr_typeUse_AND (LOCATION_ARGS)
:cPtr_typeCalcul (THERE) {
}

//---------------------------------------------------------------------------*

void cPtr_typeUse_AND::appendForDescription (C_Lexique & /* _inLexique */, C_String & ioString COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeUse_AND:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_typeUse_AND'                       *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeUse_AND * GGS_typeUse_AND::
constructor_new (C_Lexique & /* inLexique */ COMMA_LOCATION_ARGS) {
    cPtr_typeUse_AND * ptr_ = (cPtr_typeUse_AND *) NULL ;
    macroMyNew (ptr_, cPtr_typeUse_AND (THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                           class 'typeUse_ITE'                             *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeUse_ITE::cPtr_typeUse_ITE (LOCATION_ARGS)
:cPtr_typeCalcul (THERE) {
}

//---------------------------------------------------------------------------*

void cPtr_typeUse_ITE::appendForDescription (C_Lexique & /* _inLexique */, C_String & ioString COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeUse_ITE:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_typeUse_ITE'                       *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeUse_ITE * GGS_typeUse_ITE::
constructor_new (C_Lexique & /* inLexique */ COMMA_LOCATION_ARGS) {
    cPtr_typeUse_ITE * ptr_ = (cPtr_typeUse_ITE *) NULL ;
    macroMyNew (ptr_, cPtr_typeUse_ITE (THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'typeUse_AND_ITE'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeUse_AND_ITE::cPtr_typeUse_AND_ITE (LOCATION_ARGS)
:cPtr_typeCalcul (THERE) {
}

//---------------------------------------------------------------------------*

void cPtr_typeUse_AND_ITE::appendForDescription (C_Lexique & /* _inLexique */, C_String & ioString COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeUse_AND_ITE:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeUse_AND_ITE'                     *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeUse_AND_ITE * GGS_typeUse_AND_ITE::
constructor_new (C_Lexique & /* inLexique */ COMMA_LOCATION_ARGS) {
    cPtr_typeUse_AND_ITE * ptr_ = (cPtr_typeUse_AND_ITE *) NULL ;
    macroMyNew (ptr_, cPtr_typeUse_AND_ITE (THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'typeDimensionnerANDCache'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeDimensionnerANDCache::cPtr_typeDimensionnerANDCache (const GGS_luint & argument_0 COMMA_LOCATION_ARGS)
:cPtr_typeCalcul (THERE),
mDimensionCache (argument_0) {
}

//---------------------------------------------------------------------------*

void cPtr_typeDimensionnerANDCache::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@typeDimensionnerANDCache:" ;
mDimensionCache.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeDimensionnerANDCache'                 *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeDimensionnerANDCache * GGS_typeDimensionnerANDCache::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_luint & argument_0 COMMA_LOCATION_ARGS) {
    cPtr_typeDimensionnerANDCache * ptr_ = (cPtr_typeDimensionnerANDCache *) NULL ;
    macroMyNew (ptr_, cPtr_typeDimensionnerANDCache (argument_0 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'typeDimensionnerITECache'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeDimensionnerITECache::cPtr_typeDimensionnerITECache (const GGS_luint & argument_0 COMMA_LOCATION_ARGS)
:cPtr_typeCalcul (THERE),
mDimensionCache (argument_0) {
}

//---------------------------------------------------------------------------*

void cPtr_typeDimensionnerITECache::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@typeDimensionnerITECache:" ;
mDimensionCache.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeDimensionnerITECache'                 *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeDimensionnerITECache * GGS_typeDimensionnerITECache::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_luint & argument_0 COMMA_LOCATION_ARGS) {
    cPtr_typeDimensionnerITECache * ptr_ = (cPtr_typeDimensionnerITECache *) NULL ;
    macroMyNew (ptr_, cPtr_typeDimensionnerITECache (argument_0 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'typeDimensionnerTable'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeDimensionnerTable::cPtr_typeDimensionnerTable (const GGS_luint & argument_0 COMMA_LOCATION_ARGS)
:cPtr_typeCalcul (THERE),
mDimensionTable (argument_0) {
}

//---------------------------------------------------------------------------*

void cPtr_typeDimensionnerTable::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@typeDimensionnerTable:" ;
mDimensionTable.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeDimensionnerTable'                  *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeDimensionnerTable * GGS_typeDimensionnerTable::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_luint & argument_0 COMMA_LOCATION_ARGS) {
    cPtr_typeDimensionnerTable * ptr_ = (cPtr_typeDimensionnerTable *) NULL ;
    macroMyNew (ptr_, cPtr_typeDimensionnerTable (argument_0 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'typeAfficherBilan'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeAfficherBilan::cPtr_typeAfficherBilan (LOCATION_ARGS)
:cPtr_typeCalcul (THERE) {
}

//---------------------------------------------------------------------------*

void cPtr_typeAfficherBilan::appendForDescription (C_Lexique & /* _inLexique */, C_String & ioString COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeAfficherBilan:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeAfficherBilan'                    *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeAfficherBilan * GGS_typeAfficherBilan::
constructor_new (C_Lexique & /* inLexique */ COMMA_LOCATION_ARGS) {
    cPtr_typeAfficherBilan * ptr_ = (cPtr_typeAfficherBilan *) NULL ;
    macroMyNew (ptr_, cPtr_typeAfficherBilan (THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'typeCalculIteratif'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeCalculIteratif::cPtr_typeCalculIteratif (const GGS_luint & argument_0,
                                const GGS_typeFormule & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_typeTableVariablesBool & argument_3,
                                const GGS_lbool & argument_4,
                                const GGS_luint & argument_5 COMMA_LOCATION_ARGS)
:cPtr_typeCalcul (THERE),
mNumeroFormule (argument_0),
mFormule (argument_1),
mNomFormule (argument_2),
mTableVariablesBool (argument_3),
mSigne (argument_4),
mAfficher (argument_5) {
}

//---------------------------------------------------------------------------*

void cPtr_typeCalculIteratif::appendForDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "->@typeCalculIteratif:" ;
mNumeroFormule.reader_description  (_inLexique COMMA_THERE) ;
mFormule.reader_description  (_inLexique COMMA_THERE) ;
mNomFormule.reader_description  (_inLexique COMMA_THERE) ;
mTableVariablesBool.reader_description  (_inLexique COMMA_THERE) ;
mSigne.reader_description  (_inLexique COMMA_THERE) ;
mAfficher.reader_description  (_inLexique COMMA_THERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeCalculIteratif'                    *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeCalculIteratif * GGS_typeCalculIteratif::
constructor_new (C_Lexique & /* inLexique */,
                                const GGS_luint & argument_0,
                                const GGS_typeFormule & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_typeTableVariablesBool & argument_3,
                                const GGS_lbool & argument_4,
                                const GGS_luint & argument_5 COMMA_LOCATION_ARGS) {
    cPtr_typeCalculIteratif * ptr_ = (cPtr_typeCalculIteratif *) NULL ;
    macroMyNew (ptr_, cPtr_typeCalculIteratif (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5 COMMA_THERE)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                   Element of list '@typeListeCalculs'                     *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeListeCalculs::
elementOf_GGS_typeListeCalculs (const GGS_typeCalcul & argument_0):
mNextItem (NULL),
mCalcul (argument_0) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeListeCalculs::
appendForListDescription (C_Lexique & _inLexique, C_String & ioString COMMA_LOCATION_ARGS) const {
  ioString << "[" ;
  ioString << mCalcul.reader_description  (_inLexique COMMA_THERE) ;
  ioString << "]" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         List '@typeListeCalculs'                          *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeListeCalculs::cRootList::cRootList (void):
mFirstItem (NULL),
mLastItem (NULL),
mListLength (0),
mCountReference (1) {
}

//---------------------------------------------------------------------------*

GGS_typeListeCalculs::cRootList::~cRootList (void) {
  while (mFirstItem != NULL) {
    element_type * p = mFirstItem->nextObject () ;
    macroMyDelete (mFirstItem, element_type) ;
    mFirstItem = p ;
  }
}

//---------------------------------------------------------------------------*

GGS_typeListeCalculs::GGS_typeListeCalculs (void) { // Default Constructor
  mRoot = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeListeCalculs::~GGS_typeListeCalculs (void) {
  drop_operation () ;
}

//---------------------------------------------------------------------------*

GGS_typeListeCalculs::
GGS_typeListeCalculs (const GGS_typeListeCalculs & inSource) {
  mRoot = inSource.mRoot ;
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    mRoot->mCountReference ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeCalculs::
operator = (const GGS_typeListeCalculs & inSource) {
  if (this != & inSource) {
    drop_operation () ;
    mRoot = inSource.mRoot ;
    if (mRoot != NULL) {
      macroValidPointer (mRoot) ;
      mRoot->mCountReference ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeListeCalculs::element_type * GGS_typeListeCalculs::
firstObject (void) const {
  return (mRoot == NULL) ? NULL : mRoot->mFirstItem ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeCalculs::
internalAppendItem (const GGS_typeCalcul & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mRoot->mLastItem == NULL) {
      mRoot->mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mRoot->mLastItem) ;
      mRoot->mLastItem->mNextItem = nouvelElement ;
    }
    mRoot->mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mRoot->mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeCalculs::
addAssign_operation (const GGS_typeCalcul & argument_0) {
  if (isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeCalculs::
insulateList (void) {
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    if (mRoot->mCountReference > 1) {
      element_type * p = mRoot->mFirstItem ;
      mRoot->mCountReference -- ;
      mRoot = NULL ;
      macroMyNew (mRoot, cRootList) ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->mCalcul) ;
        p = p->mNextItem ;
      }
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeListeCalculs  GGS_typeListeCalculs::
constructor_emptyList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeListeCalculs result ;
  macroMyNew (result.mRoot, cRootList) ;
  return result ;
}

//---------------------------------------------------------------------------*

sint32 GGS_typeListeCalculs::
count (void) const {
  return (mRoot == NULL) ? 0 : mRoot->mListLength ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeListeCalculs::
reader_description (C_Lexique & _inLexique COMMA_LOCATION_ARGS) const {
  C_String s ;
  s << "<list @typeListeCalculs" ;
  if (isBuilt ()) {
    s << " " << mRoot->mListLength << " object" << ((mRoot->mListLength > 1) ? "s " : " ") ;
    element_type * p = mRoot->mFirstItem ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForListDescription (_inLexique, s COMMA_THERE) ;
      p = p->mNextItem ;
    }
  }else{
    s << " not built" ;
  }
  s << ">\n" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

GGS_uint GGS_typeListeCalculs::
reader_length (C_Lexique & /* inLexique */
               COMMA_UNUSED_LOCATION_ARGS) const {
  return GGS_uint (mRoot != NULL,
                   (mRoot == NULL) ? 0 : (uint32) mRoot->mListLength) ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeCalculs::
drop_operation (void) {
  if (mRoot != NULL) {
    macroValidPointer (mRoot) ;
    if (mRoot->mCountReference == 1) {
      macroMyDelete (mRoot, cRootList) ;
    }else{
      mRoot->mCountReference -- ;
      mRoot = NULL ;
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//         Implementation of routine "verifierNombreArgumentsBool"           *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_verifierNombreArgumentsBool (C_Lexique & _inLexique,
                                const GGS_typeFormalArgumentsList  & var_cas_t1,
                                const GGS_typeActualArgumentsList  & var_cas_t2,
                                const GGS_location  & var_cas_positionFinListe COMMA_UNUSED_LOCATION_ARGS) {
  if (((var_cas_t1.reader_length (_inLexique SOURCE_FILE_AT_LINE (257))) < (var_cas_t2.reader_length (_inLexique SOURCE_FILE_AT_LINE (257)))).isBuiltAndTrue ()) {
      var_cas_positionFinListe.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "too much actual arguments") SOURCE_FILE_AT_LINE (258)) ;
  }else if (((var_cas_t1.reader_length (_inLexique SOURCE_FILE_AT_LINE (259))) > (var_cas_t2.reader_length (_inLexique SOURCE_FILE_AT_LINE (259)))).isBuiltAndTrue ()) {
      var_cas_positionFinListe.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "one or more actual arguments missing") SOURCE_FILE_AT_LINE (260)) ;
  }
  GGS_typeFormalArgumentsList::element_type * operand_7763 = var_cas_t1.firstObject () ;
  GGS_typeActualArgumentsList::element_type * operand_7852 = var_cas_t2.firstObject () ;
  while ((operand_7763 != NULL)
      && (operand_7852 != NULL)) {
    macroValidPointer (operand_7763) ;
    macroValidPointer (operand_7852) ;
    if (((operand_7763->mVariableBitSize.reader_value (_inLexique SOURCE_FILE_AT_LINE (264))) == (operand_7852->mVariableBitSize.reader_value (_inLexique SOURCE_FILE_AT_LINE (264)))).isBuiltAndTrue ()) {
      if (((operand_7763->mLowBound.reader_value (_inLexique SOURCE_FILE_AT_LINE (265))) == (operand_7852->mLowBound.reader_value (_inLexique SOURCE_FILE_AT_LINE (265)))).isBuiltAndTrue ()) {
        if (((operand_7763->mHighBound.reader_value (_inLexique SOURCE_FILE_AT_LINE (266))) == (operand_7852->mHighBound.reader_value (_inLexique SOURCE_FILE_AT_LINE (266)))).isBuiltAndTrue ()) {
        }else{
            operand_7852->mErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "the actual high bound is different the formal one") SOURCE_FILE_AT_LINE (268)) ;
        }
      }else{
          operand_7852->mErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "the actual low bound is different the formal one") SOURCE_FILE_AT_LINE (271)) ;
      }
    }else{
        operand_7852->mErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "the actual dimension is different from the formal one") SOURCE_FILE_AT_LINE (274)) ;
    }
    operand_7763 = operand_7763->nextObject () ;
    operand_7852 = operand_7852->nextObject () ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//             Implementation of routine "buildFormalArgsList"               *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_buildFormalArgsList (C_Lexique & _inLexique,
                                const GGS_typeVariableDescriptor  & var_cas_inVariableDescriptor,
                                GGS_typeFormalArgumentsList  & var_cas_ioFormalArgsList,
                                const GGS_location  & var_cas_inErrorLocation COMMA_UNUSED_LOCATION_ARGS) {
  if (var_cas_inVariableDescriptor.isBuilt ()) {
    if (dynamic_cast <cPtr_typeDirectVariable *> (var_cas_inVariableDescriptor.getPtr ()) != NULL) {
      cPtr_typeDirectVariable * operand_8741 = dynamic_cast <cPtr_typeDirectVariable *> (var_cas_inVariableDescriptor.getPtr ()) ;
      macroValidPointer (operand_8741) ; 
      var_cas_ioFormalArgsList.addAssign_operation (operand_8741->mIndex, operand_8741->mBitSize, operand_8741->mLowBound, operand_8741->mHighBound) ;
    }else if (dynamic_cast <cPtr_typeRecordVariable *> (var_cas_inVariableDescriptor.getPtr ()) != NULL) {
      cPtr_typeRecordVariable * operand_8927 = dynamic_cast <cPtr_typeRecordVariable *> (var_cas_inVariableDescriptor.getPtr ()) ;
      macroValidPointer (operand_8927) ; 
      GGS_typeTableVariablesBool::element_type * operand_9024 = operand_8927->mMap.firstObject () ;
      while ((operand_9024 != NULL)) {
        macroValidPointer (operand_9024) ;
        ::routine_buildFormalArgsList (_inLexique,  operand_9024->mInfo.mVariableDescriptor,  var_cas_ioFormalArgsList,  var_cas_inErrorLocation SOURCE_FILE_AT_LINE (291)) ;
        operand_9024 = operand_9024->nextObject () ;
      }
    }else{ // Else part
        var_cas_inErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, ((GGS_string (true, "a variable was expected here ; I found ")) + (var_cas_inVariableDescriptor.reader_variableDescriptorErrorMessage (_inLexique SOURCE_FILE_AT_LINE (294)))) SOURCE_FILE_AT_LINE (294)) ;
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//             Implementation of routine "buildActualArgsList"               *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_buildActualArgsList (C_Lexique & _inLexique,
                                const GGS_typeTableVariablesBool  & var_cas_inDomainMap,
                                GGS_typeActualArgumentsList  & var_cas_ioActualArgsList,
                                const GGS_location  & var_cas_inErrorLocation COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeTableVariablesBool::element_type * operand_9599 = var_cas_inDomainMap.firstObject () ;
  while ((operand_9599 != NULL)) {
    macroValidPointer (operand_9599) ;
    if (operand_9599->mInfo.mVariableDescriptor.isBuilt ()) {
      if (dynamic_cast <cPtr_typeDirectVariable *> (operand_9599->mInfo.mVariableDescriptor.getPtr ()) != NULL) {
        cPtr_typeDirectVariable * operand_9708 = dynamic_cast <cPtr_typeDirectVariable *> (operand_9599->mInfo.mVariableDescriptor.getPtr ()) ;
        macroValidPointer (operand_9708) ; 
        var_cas_ioActualArgsList.addAssign_operation (operand_9708->mIndex, operand_9708->mBitSize, operand_9708->mLowBound, operand_9708->mHighBound, var_cas_inErrorLocation) ;
      }else if (dynamic_cast <cPtr_typeRecordVariable *> (operand_9599->mInfo.mVariableDescriptor.getPtr ()) != NULL) {
        cPtr_typeRecordVariable * operand_9915 = dynamic_cast <cPtr_typeRecordVariable *> (operand_9599->mInfo.mVariableDescriptor.getPtr ()) ;
        macroValidPointer (operand_9915) ; 
        ::routine_buildActualArgsList (_inLexique,  operand_9915->mMap,  var_cas_ioActualArgsList,  var_cas_inErrorLocation SOURCE_FILE_AT_LINE (310)) ;
      }else{ // Else part
          var_cas_inErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, ((GGS_string (true, "a variable was expected here ; I found ")) + (operand_9599->mInfo.mVariableDescriptor.reader_variableDescriptorErrorMessage (_inLexique SOURCE_FILE_AT_LINE (313)))) SOURCE_FILE_AT_LINE (313)) ;
      }
    }
    operand_9599 = operand_9599->nextObject () ;
  }
}

//---------------------------------------------------------------------------*

