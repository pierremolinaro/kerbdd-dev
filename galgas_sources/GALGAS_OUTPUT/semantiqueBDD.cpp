//---------------------------------------------------------------------------*
//                                                                           *
//                         File 'semantiqueBDD.cpp'                          *
//         Generated by version GALGAS_BETA_VERSION (LL(1) grammar)          *
//                     january 3rd, 2006, at 21h10'12"                       *
//                                                                           *
// This file is free software; you can redistribute it and/or modify it      *
// under the terms of the GNU Lesser General Public License as published     *
// by the Free Software Foundation; either version 2 of the License, or      *
// (at your option) any later version.                                       *
//                                                                           *
// This file is distributed in the hope it will be useful, but WITHOUT       *
// ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or     *
// FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public       *
// License for more details.                                                 *
//                                                                           *
// You should have received a copy of the GNU General Public License along   *
// with this program; if not, write to the Free Software Foundation          *
// Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA            *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

#include "utilities/MF_MemoryControl.h"
#include "files/C_TextFileWrite.h"
#include "semantiqueBDD.h"

//---------------------------------------------------------------------------*
//                                                                           *
//               Include directives generated by extern types                *
//                                                                           *
//---------------------------------------------------------------------------*

#include "cTableVariablesBDD.hh"

//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//                     abstract class 'cPtr_typeDomain'                      *
//                                                                           *
//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*

const char * cPtr_typeDomain
::static_string_message_messageDomainType (void) {
  return "any domain" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeDomain::
message_messageDomainType (void) const {
  return "any domain" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_typeDomain'                        *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeDomain::
GGS_typeDomain (void) {
  mPointer = (cPtr_typeDomain *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeDomain::
GGS_typeDomain (const GGS_typeDomain & inOperand) {
  mPointer = (cPtr_typeDomain *) NULL ;
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeDomain::
~GGS_typeDomain (void) {
  macroDetachPointer (mPointer, cPtr_typeDomain) ;
}

//---------------------------------------------------------------------------*

void GGS_typeDomain::
operator = (const GGS_typeDomain & inOperand) {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

void GGS_typeDomain::
operator = (cPtr_typeDomain * inSource) {
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

GGS_typeDomain::
GGS_typeDomain (cPtr_typeDomain * inSource) {
  mPointer = (cPtr_typeDomain *) NULL ;
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeDomain * GGS_typeDomain
::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_typeDomain::reader_messageDomainType (void) const {
  return GGS_string (mPointer != NULL, C_String ((mPointer == NULL) ? "" : mPointer->message_messageDomainType ())) ;
}

//---------------------------------------------------------------------------*

void GGS_typeDomain
::drop_operation (void) {
  macroDetachPointer (mPointer, cPtr_typeDomain) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'typeDirectDomain'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeDirectDomain::cPtr_typeDirectDomain (const GGS_luint & argument_0,
                                const GGS_luint & argument_1,
                                const GGS_luint & argument_2)
:mLowBound (argument_0),
mHighBound (argument_1),
mBitsCount (argument_2) {
}


const char * cPtr_typeDirectDomain::message_messageDomainType (void) const {
  return "an interval domain" ;
}

const char * cPtr_typeDirectDomain::static_string_message_messageDomainType (void) {
  return "an interval domain" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeDirectDomain'                     *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeDirectDomain * GGS_typeDirectDomain::
    constructor_new (const GGS_luint & argument_0,
                                const GGS_luint & argument_1,
                                const GGS_luint & argument_2) {
    cPtr_typeDirectDomain * ptr_ = (cPtr_typeDirectDomain *) NULL ;
    macroMyNew (ptr_, cPtr_typeDirectDomain (argument_0,
                                argument_1,
                                argument_2)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                        class map 'typeDomainMap'                          *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeDomainMap::
elementOf_GGS_typeDomainMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_typeDomainMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_typeDomainMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_typeDomainMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_typeDomainMap * info = (e_typeDomainMap *) inInfo ;
  macroMyNew (p, element_type (inKey, count (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_typeDomainMap GGS_typeDomainMap::constructor_empty (void) {
  GGS_typeDomainMap result ;
  macroMyNew (result.mReferenceCountPtr, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeDomainMap::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mRoot, extension, index) ;
}

//---------------------------------------------------------------------------*

void GGS_typeDomainMap::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_typeDomain &  inParameter0,
               GGS_luint * outIndex) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()) {
    insulateMap () ;
    e_typeDomainMap info  ;
    info.mDomain = inParameter0 ;
    bool extension = false ; // Unused here
    internalInsert (inKey, (void *) & info, mRoot, extension, index) ;
    if (index < 0) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeDomainMap::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_typeDomain   & outParameter0,
               GGS_luint * outIndex) {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop_operation () ;
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mDomain ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeDomainMap::methode_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_typeDomain   & outParameter0) {
  searchElement (inLexique,
                 "the '%K' domain is not declared",
                 inKey,
                 outParameter0,
                 NULL) ;
}

//---------------------------------------------------------------------------*

void GGS_typeDomainMap::methode_insertKey (C_Lexique & lexique_var_,
                                const GGS_lstring & inKey,
                                const GGS_typeDomain & inParameter0) {
  insertElement (lexique_var_,
                 "the '%K' domain has been already declared",
                 inKey,
                 inParameter0,
                 NULL) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'typeRecordDomain'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeRecordDomain::cPtr_typeRecordDomain (const GGS_typeDomainMap & argument_0)
:mRecordMap (argument_0) {
}


const char * cPtr_typeRecordDomain::message_messageDomainType (void) const {
  return "a record domain" ;
}

const char * cPtr_typeRecordDomain::static_string_message_messageDomainType (void) {
  return "a record domain" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeRecordDomain'                     *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeRecordDomain * GGS_typeRecordDomain::
    constructor_new (const GGS_typeDomainMap & argument_0) {
    cPtr_typeRecordDomain * ptr_ = (cPtr_typeRecordDomain *) NULL ;
    macroMyNew (ptr_, cPtr_typeRecordDomain (argument_0)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@typeFormalArgumentsList'                 *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeFormalArgumentsList::
elementOf_GGS_typeFormalArgumentsList (const GGS_luint & argument_0,
                                const GGS_luint & argument_1,
                                const GGS_luint & argument_2,
                                const GGS_luint & argument_3) {
  mNextItem = (elementOf_GGS_typeFormalArgumentsList *) NULL ;
  mVariableIndex = argument_0 ;
  mVariableBitSize = argument_1 ;
  mLowBound = argument_2 ;
  mHighBound = argument_3 ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     List '@typeFormalArgumentsList'                       *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeFormalArgumentsList
::GGS_typeFormalArgumentsList (void) { // Default Constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeFormalArgumentsList::~GGS_typeFormalArgumentsList (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*

GGS_typeFormalArgumentsList::GGS_typeFormalArgumentsList (const GGS_typeFormalArgumentsList & source) { // Copy constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
  *this = source ;
}

//---------------------------------------------------------------------------*

void GGS_typeFormalArgumentsList
::operator = (const GGS_typeFormalArgumentsList & source) { // Assignment operator
  if (this != & source) {
    emptyList () ;
    mFirstItem = source.mFirstItem ;
    mLastItem = source.mLastItem ;
    mListLength = source.mListLength ;
    mCountReference = source.mCountReference ;
    if (mCountReference != NULL) {
      macroValidPointer (mCountReference) ;
      (*mCountReference) ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeFormalArgumentsList
::emptyList (void) {
  mListLength = 0 ;
  mLastItem = (element_type *) NULL ;
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) == 1) {
      macroMyDelete (mCountReference, sint32) ;
      while (mFirstItem != NULL) {
        macroValidPointer (mFirstItem) ;
        mLastItem = mFirstItem->mNextItem ;
        macroMyDelete (mFirstItem, element_type) ;
        mFirstItem = mLastItem ;
      }
    }else{
      mFirstItem = (element_type *) NULL ;
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeFormalArgumentsList::
internalAppendItem (const GGS_luint & argument_0,
                                const GGS_luint & argument_1,
                                const GGS_luint & argument_2,
                                const GGS_luint & argument_3) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2,
                                argument_3)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mLastItem == NULL) {
      mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mLastItem) ;
      mLastItem->mNextItem = nouvelElement ;
    }
    mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeFormalArgumentsList::
addAssign_operation (const GGS_luint & argument_0,
                                const GGS_luint & argument_1,
                                const GGS_luint & argument_2,
                                const GGS_luint & argument_3) {
  if (isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0,
                                argument_1,
                                argument_2,
                                argument_3) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeFormalArgumentsList
::insulateList (void) {
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) > 1) {
      element_type * p = mFirstItem ;
      mFirstItem = (element_type *)  NULL ;
      mLastItem = (element_type *)  NULL ;
      mListLength = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->mVariableIndex,
                                p->mVariableBitSize,
                                p->mLowBound,
                                p->mHighBound) ;
        p = p->mNextItem ;
      }
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
      macroMyNew (mCountReference, sint32 (1)) ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeFormalArgumentsList  GGS_typeFormalArgumentsList::
constructor_empty (void) {
  GGS_typeFormalArgumentsList result ;
  macroMyNew (result.mCountReference, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeFormalArgumentsList
::drop_operation (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@typeActualArgumentsList'                 *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeActualArgumentsList::
elementOf_GGS_typeActualArgumentsList (const GGS_luint & argument_0,
                                const GGS_luint & argument_1,
                                const GGS_luint & argument_2,
                                const GGS_luint & argument_3,
                                const GGS_location & argument_4) {
  mNextItem = (elementOf_GGS_typeActualArgumentsList *) NULL ;
  mVariableIndex = argument_0 ;
  mVariableBitSize = argument_1 ;
  mLowBound = argument_2 ;
  mHighBound = argument_3 ;
  mErrorLocation = argument_4 ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     List '@typeActualArgumentsList'                       *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeActualArgumentsList
::GGS_typeActualArgumentsList (void) { // Default Constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeActualArgumentsList::~GGS_typeActualArgumentsList (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*

GGS_typeActualArgumentsList::GGS_typeActualArgumentsList (const GGS_typeActualArgumentsList & source) { // Copy constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
  *this = source ;
}

//---------------------------------------------------------------------------*

void GGS_typeActualArgumentsList
::operator = (const GGS_typeActualArgumentsList & source) { // Assignment operator
  if (this != & source) {
    emptyList () ;
    mFirstItem = source.mFirstItem ;
    mLastItem = source.mLastItem ;
    mListLength = source.mListLength ;
    mCountReference = source.mCountReference ;
    if (mCountReference != NULL) {
      macroValidPointer (mCountReference) ;
      (*mCountReference) ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeActualArgumentsList
::emptyList (void) {
  mListLength = 0 ;
  mLastItem = (element_type *) NULL ;
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) == 1) {
      macroMyDelete (mCountReference, sint32) ;
      while (mFirstItem != NULL) {
        macroValidPointer (mFirstItem) ;
        mLastItem = mFirstItem->mNextItem ;
        macroMyDelete (mFirstItem, element_type) ;
        mFirstItem = mLastItem ;
      }
    }else{
      mFirstItem = (element_type *) NULL ;
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeActualArgumentsList::
internalAppendItem (const GGS_luint & argument_0,
                                const GGS_luint & argument_1,
                                const GGS_luint & argument_2,
                                const GGS_luint & argument_3,
                                const GGS_location & argument_4) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mLastItem == NULL) {
      mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mLastItem) ;
      mLastItem->mNextItem = nouvelElement ;
    }
    mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeActualArgumentsList::
addAssign_operation (const GGS_luint & argument_0,
                                const GGS_luint & argument_1,
                                const GGS_luint & argument_2,
                                const GGS_luint & argument_3,
                                const GGS_location & argument_4) {
  if (isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeActualArgumentsList
::insulateList (void) {
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) > 1) {
      element_type * p = mFirstItem ;
      mFirstItem = (element_type *)  NULL ;
      mLastItem = (element_type *)  NULL ;
      mListLength = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->mVariableIndex,
                                p->mVariableBitSize,
                                p->mLowBound,
                                p->mHighBound,
                                p->mErrorLocation) ;
        p = p->mNextItem ;
      }
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
      macroMyNew (mCountReference, sint32 (1)) ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeActualArgumentsList  GGS_typeActualArgumentsList::
constructor_empty (void) {
  GGS_typeActualArgumentsList result ;
  macroMyNew (result.mCountReference, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeActualArgumentsList
::drop_operation (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               abstract class 'cPtr_typeVariableDescriptor'                *
//                                                                           *
//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*

const char * cPtr_typeVariableDescriptor
::static_string_message_variableDescriptorErrorMessage (void) {
  return "any variable" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeVariableDescriptor::
message_variableDescriptorErrorMessage (void) const {
  return "any variable" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_typeVariableDescriptor'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeVariableDescriptor::
GGS_typeVariableDescriptor (void) {
  mPointer = (cPtr_typeVariableDescriptor *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeVariableDescriptor::
GGS_typeVariableDescriptor (const GGS_typeVariableDescriptor & inOperand) {
  mPointer = (cPtr_typeVariableDescriptor *) NULL ;
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeVariableDescriptor::
~GGS_typeVariableDescriptor (void) {
  macroDetachPointer (mPointer, cPtr_typeVariableDescriptor) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariableDescriptor::
operator = (const GGS_typeVariableDescriptor & inOperand) {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariableDescriptor::
operator = (cPtr_typeVariableDescriptor * inSource) {
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

GGS_typeVariableDescriptor::
GGS_typeVariableDescriptor (cPtr_typeVariableDescriptor * inSource) {
  mPointer = (cPtr_typeVariableDescriptor *) NULL ;
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeVariableDescriptor * GGS_typeVariableDescriptor
::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

GGS_string GGS_typeVariableDescriptor::reader_variableDescriptorErrorMessage (void) const {
  return GGS_string (mPointer != NULL, C_String ((mPointer == NULL) ? "" : mPointer->message_variableDescriptorErrorMessage ())) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariableDescriptor
::drop_operation (void) {
  macroDetachPointer (mPointer, cPtr_typeVariableDescriptor) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'typeDirectVariable'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeDirectVariable::cPtr_typeDirectVariable (const GGS_luint & argument_0,
                                const GGS_luint & argument_1,
                                const GGS_luint & argument_2,
                                const GGS_luint & argument_3)
:mIndex (argument_0),
mBitSize (argument_1),
mLowBound (argument_2),
mHighBound (argument_3) {
}


const char * cPtr_typeDirectVariable::message_variableDescriptorErrorMessage (void) const {
  return "a direct domain variable" ;
}

const char * cPtr_typeDirectVariable::static_string_message_variableDescriptorErrorMessage (void) {
  return "a direct domain variable" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeDirectVariable'                    *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeDirectVariable * GGS_typeDirectVariable::
    constructor_new (const GGS_luint & argument_0,
                                const GGS_luint & argument_1,
                                const GGS_luint & argument_2,
                                const GGS_luint & argument_3) {
    cPtr_typeDirectVariable * ptr_ = (cPtr_typeDirectVariable *) NULL ;
    macroMyNew (ptr_, cPtr_typeDirectVariable (argument_0,
                                argument_1,
                                argument_2,
                                argument_3)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//               class map element 'e_typeTableVariablesBool'                *
//                                                                           *
//---------------------------------------------------------------------------*

template class cTableVariablesBDD <e_typeTableVariablesBool> ;

//---------------------------------------------------------------------------*
//                                                                           *
//                       Map 'typeTableVariablesBool'                        *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeTableVariablesBool GGS_typeTableVariablesBool::constructor_empty (void) {
  GGS_typeTableVariablesBool t ;
  t.build () ;
  return t ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableVariablesBool::methode_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_typeVariableDescriptor   & outParameter0) {
  GGS_typeTableVariablesBool::element_type * info = searchKey (inLexique, inKey, inKey, "the '%' variable is not declared") ;
  if (info == NULL) {
    outParameter0.drop_operation () ;
  }else{
    outParameter0 = info->mInfo.mVariableDescriptor ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTableVariablesBool::methode_searchKeyGetIndex (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                GGS_typeVariableDescriptor   & outParameter0) {
  GGS_typeTableVariablesBool::element_type * info = searchKey (inLexique, inKey, inKey, "the '%' variable is not declared") ;
  if (info == NULL) {
    outParameter0.drop_operation () ;
    outIndex.drop_operation () ;
  }else{
    outParameter0 = info->mInfo.mVariableDescriptor ;
    outIndex = GGS_luint (GGS_uint (true, (uint32) info->mEntryIndex), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTableVariablesBool::methode_insertKey (C_Lexique & lexique_var_,
                                const GGS_lstring & inKey,
                                const GGS_typeVariableDescriptor &  inParameter0) {
  e_typeTableVariablesBool info ;
  info.mVariableDescriptor = inParameter0 ;
  insertKey (lexique_var_, info, inKey, inKey, "the '%' variable has been already declared") ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableVariablesBool::methode_insertKeyGetIndex (C_Lexique & lexique_var_,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_typeVariableDescriptor &  inParameter0) {
  e_typeTableVariablesBool info ;
  info.mVariableDescriptor = inParameter0 ;
  const sint32 index = insertKey (lexique_var_, info, inKey, inKey, "the '%' variable has been already declared") ;
  outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'typeRecordVariable'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeRecordVariable::cPtr_typeRecordVariable (const GGS_typeTableVariablesBool & argument_0)
:mMap (argument_0) {
}


const char * cPtr_typeRecordVariable::message_variableDescriptorErrorMessage (void) const {
  return "a record domain variable" ;
}

const char * cPtr_typeRecordVariable::static_string_message_variableDescriptorErrorMessage (void) {
  return "a record domain variable" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeRecordVariable'                    *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeRecordVariable * GGS_typeRecordVariable::
    constructor_new (const GGS_typeTableVariablesBool & argument_0) {
    cPtr_typeRecordVariable * ptr_ = (cPtr_typeRecordVariable *) NULL ;
    macroMyNew (ptr_, cPtr_typeRecordVariable (argument_0)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                      class map 'typeTableFormules'                        *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeTableFormules::
elementOf_GGS_typeTableFormules (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_typeTableFormules & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_typeTableFormules::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_typeTableFormules *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_typeTableFormules * info = (e_typeTableFormules *) inInfo ;
  macroMyNew (p, element_type (inKey, count (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_typeTableFormules GGS_typeTableFormules::constructor_empty (void) {
  GGS_typeTableFormules result ;
  macroMyNew (result.mReferenceCountPtr, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableFormules::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mRoot, extension, index) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableFormules::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_typeFormalArgumentsList &  inParameter0,
               const GGS_bdd&  inParameter1,
               GGS_luint * outIndex) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()) {
    insulateMap () ;
    e_typeTableFormules info  ;
    info.aListeArgsFormelsBool = inParameter0 ;
    info.aBDD = inParameter1 ;
    bool extension = false ; // Unused here
    internalInsert (inKey, (void *) & info, mRoot, extension, index) ;
    if (index < 0) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTableFormules::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_typeFormalArgumentsList   & outParameter0,
               GGS_bdd  & outParameter1,
               GGS_luint * outIndex) {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop_operation () ;
    outParameter1.drop_operation () ;
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.aListeArgsFormelsBool ;
    outParameter1 = node->mInfo.aBDD ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTableFormules::methode_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_typeFormalArgumentsList   & outParameter0,
                                GGS_bdd  & outParameter1) {
  searchElement (inLexique,
                 "the '#%K' formula is not defined",
                 inKey,
                 outParameter0,
                 outParameter1,
                 NULL) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableFormules::methode_searchKeyGetIndex (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                GGS_typeFormalArgumentsList   & outParameter0,
                                GGS_bdd  & outParameter1) {
  searchElement (inLexique,
                 "the '#%K' formula is not defined",
                 inKey,
                 outParameter0,
                 outParameter1,
                 & outIndex) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableFormules::methode_insertKey (C_Lexique & lexique_var_,
                                const GGS_lstring & inKey,
                                const GGS_typeFormalArgumentsList & inParameter0,
                                const GGS_bdd& inParameter1) {
  insertElement (lexique_var_,
                 "the '#%K' formula is already defined",
                 inKey,
                 inParameter0,
                 inParameter1,
                 NULL) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableFormules::methode_insertKeyGetIndex (C_Lexique & lexique_var_,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_typeFormalArgumentsList & inParameter0,
                                const GGS_bdd& inParameter1) {
  insertElement (lexique_var_,
                 "the '#%K' formula is already defined",
                 inKey,
                 inParameter0,
                 inParameter1,
                 & outIndex) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    abstract class 'cPtr_typeFormule'                      *
//                                                                           *
//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_typeFormule'                       *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeFormule::
GGS_typeFormule (void) {
  mPointer = (cPtr_typeFormule *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeFormule::
GGS_typeFormule (const GGS_typeFormule & inOperand) {
  mPointer = (cPtr_typeFormule *) NULL ;
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeFormule::
~GGS_typeFormule (void) {
  macroDetachPointer (mPointer, cPtr_typeFormule) ;
}

//---------------------------------------------------------------------------*

void GGS_typeFormule::
operator = (const GGS_typeFormule & inOperand) {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

void GGS_typeFormule::
operator = (cPtr_typeFormule * inSource) {
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

GGS_typeFormule::
GGS_typeFormule (cPtr_typeFormule * inSource) {
  mPointer = (cPtr_typeFormule *) NULL ;
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeFormule * GGS_typeFormule
::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void GGS_typeFormule
::drop_operation (void) {
  macroDetachPointer (mPointer, cPtr_typeFormule) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'typeFormuleTrue'                           *
//                                                                           *
//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeFormuleTrue'                     *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeFormuleTrue * GGS_typeFormuleTrue::
    constructor_new () {
    cPtr_typeFormuleTrue * ptr_ = (cPtr_typeFormuleTrue *) NULL ;
    macroMyNew (ptr_, cPtr_typeFormuleTrue ()) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'typeFormuleFalse'                          *
//                                                                           *
//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeFormuleFalse'                     *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeFormuleFalse * GGS_typeFormuleFalse::
    constructor_new () {
    cPtr_typeFormuleFalse * ptr_ = (cPtr_typeFormuleFalse *) NULL ;
    macroMyNew (ptr_, cPtr_typeFormuleFalse ()) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'typeFormuleVar'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeFormuleVar::cPtr_typeFormuleVar (const GGS_luint & argument_0,
                                const GGS_luint & argument_1,
                                const GGS_luint & argument_2)
:aNumeroVariable (argument_0),
mLowBound (argument_1),
mHighBound (argument_2) {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeFormuleVar'                      *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeFormuleVar * GGS_typeFormuleVar::
    constructor_new (const GGS_luint & argument_0,
                                const GGS_luint & argument_1,
                                const GGS_luint & argument_2) {
    cPtr_typeFormuleVar * ptr_ = (cPtr_typeFormuleVar *) NULL ;
    macroMyNew (ptr_, cPtr_typeFormuleVar (argument_0,
                                argument_1,
                                argument_2)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'typeFormuleFor'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeFormuleFor::cPtr_typeFormuleFor (const GGS_luint & argument_0,
                                const GGS_typeActualArgumentsList & argument_1,
                                const GGS_bdd& argument_2,
                                const GGS_lbool & argument_3)
:aNumeroFormule (argument_0),
aListeArgsBool (argument_1),
aFormuleTraduite (argument_2),
aEstFormuleCourante (argument_3) {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeFormuleFor'                      *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeFormuleFor * GGS_typeFormuleFor::
    constructor_new (const GGS_luint & argument_0,
                                const GGS_typeActualArgumentsList & argument_1,
                                const GGS_bdd& argument_2,
                                const GGS_lbool & argument_3) {
    cPtr_typeFormuleFor * ptr_ = (cPtr_typeFormuleFor *) NULL ;
    macroMyNew (ptr_, cPtr_typeFormuleFor (argument_0,
                                argument_1,
                                argument_2,
                                argument_3)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'typeFormuleNon'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeFormuleNon::cPtr_typeFormuleNon (const GGS_typeFormule & argument_0)
:aOperande (argument_0) {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeFormuleNon'                      *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeFormuleNon * GGS_typeFormuleNon::
    constructor_new (const GGS_typeFormule & argument_0) {
    cPtr_typeFormuleNon * ptr_ = (cPtr_typeFormuleNon *) NULL ;
    macroMyNew (ptr_, cPtr_typeFormuleNon (argument_0)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'typeFormuleEt'                            *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeFormuleEt::cPtr_typeFormuleEt (const GGS_typeFormule & argument_0,
                                const GGS_typeFormule & argument_1)
:aOperande1 (argument_0),
aOperande2 (argument_1) {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_typeFormuleEt'                      *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeFormuleEt * GGS_typeFormuleEt::
    constructor_new (const GGS_typeFormule & argument_0,
                                const GGS_typeFormule & argument_1) {
    cPtr_typeFormuleEt * ptr_ = (cPtr_typeFormuleEt *) NULL ;
    macroMyNew (ptr_, cPtr_typeFormuleEt (argument_0,
                                argument_1)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'typeFormuleIte'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeFormuleIte::cPtr_typeFormuleIte (const GGS_typeFormule & argument_0,
                                const GGS_typeFormule & argument_1,
                                const GGS_typeFormule & argument_2)
:aOperande1 (argument_0),
aOperande2 (argument_1),
aOperande3 (argument_2) {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeFormuleIte'                      *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeFormuleIte * GGS_typeFormuleIte::
    constructor_new (const GGS_typeFormule & argument_0,
                                const GGS_typeFormule & argument_1,
                                const GGS_typeFormule & argument_2) {
    cPtr_typeFormuleIte * ptr_ = (cPtr_typeFormuleIte *) NULL ;
    macroMyNew (ptr_, cPtr_typeFormuleIte (argument_0,
                                argument_1,
                                argument_2)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'typeFormuleOu'                            *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeFormuleOu::cPtr_typeFormuleOu (const GGS_typeFormule & argument_0,
                                const GGS_typeFormule & argument_1)
:aOperande1 (argument_0),
aOperande2 (argument_1) {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_typeFormuleOu'                      *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeFormuleOu * GGS_typeFormuleOu::
    constructor_new (const GGS_typeFormule & argument_0,
                                const GGS_typeFormule & argument_1) {
    cPtr_typeFormuleOu * ptr_ = (cPtr_typeFormuleOu *) NULL ;
    macroMyNew (ptr_, cPtr_typeFormuleOu (argument_0,
                                argument_1)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'typeFormuleImplique'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeFormuleImplique::cPtr_typeFormuleImplique (const GGS_typeFormule & argument_0,
                                const GGS_typeFormule & argument_1)
:aOperande1 (argument_0),
aOperande2 (argument_1) {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeFormuleImplique'                   *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeFormuleImplique * GGS_typeFormuleImplique::
    constructor_new (const GGS_typeFormule & argument_0,
                                const GGS_typeFormule & argument_1) {
    cPtr_typeFormuleImplique * ptr_ = (cPtr_typeFormuleImplique *) NULL ;
    macroMyNew (ptr_, cPtr_typeFormuleImplique (argument_0,
                                argument_1)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'typeComparaisonFormules'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeComparaisonFormules::cPtr_typeComparaisonFormules (const GGS_luint & argument_0,
                                const GGS_typeFormule & argument_1,
                                const GGS_typeFormule & argument_2)
:aComparaison (argument_0),
aOperande1 (argument_1),
aOperande2 (argument_2) {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_typeComparaisonFormules'                 *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeComparaisonFormules * GGS_typeComparaisonFormules::
    constructor_new (const GGS_luint & argument_0,
                                const GGS_typeFormule & argument_1,
                                const GGS_typeFormule & argument_2) {
    cPtr_typeComparaisonFormules * ptr_ = (cPtr_typeComparaisonFormules *) NULL ;
    macroMyNew (ptr_, cPtr_typeComparaisonFormules (argument_0,
                                argument_1,
                                argument_2)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'typeFormuleExist'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeFormuleExist::cPtr_typeFormuleExist (const GGS_typeFormalArgumentsList & argument_0,
                                const GGS_typeFormule & argument_1,
                                const GGS_bdd& argument_2)
:aListeArgsBooleens (argument_0),
aOperande (argument_1),
aContraintes (argument_2) {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeFormuleExist'                     *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeFormuleExist * GGS_typeFormuleExist::
    constructor_new (const GGS_typeFormalArgumentsList & argument_0,
                                const GGS_typeFormule & argument_1,
                                const GGS_bdd& argument_2) {
    cPtr_typeFormuleExist * ptr_ = (cPtr_typeFormuleExist *) NULL ;
    macroMyNew (ptr_, cPtr_typeFormuleExist (argument_0,
                                argument_1,
                                argument_2)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'typeFormuleComparaisonValeur'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeFormuleComparaisonValeur::cPtr_typeFormuleComparaisonValeur (const GGS_luint & argument_0,
                                const GGS_luint & argument_1,
                                const GGS_luint & argument_2,
                                const GGS_luint & argument_3,
                                const GGS_luint & argument_4,
                                const GGS_luint & argument_5)
:aIndiceBDD (argument_0),
aDimension (argument_1),
mLowBound (argument_2),
mHighBound (argument_3),
aComparaison (argument_4),
aValeur (argument_5) {
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_typeFormuleComparaisonValeur'               *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeFormuleComparaisonValeur * GGS_typeFormuleComparaisonValeur::
    constructor_new (const GGS_luint & argument_0,
                                const GGS_luint & argument_1,
                                const GGS_luint & argument_2,
                                const GGS_luint & argument_3,
                                const GGS_luint & argument_4,
                                const GGS_luint & argument_5) {
    cPtr_typeFormuleComparaisonValeur * ptr_ = (cPtr_typeFormuleComparaisonValeur *) NULL ;
    macroMyNew (ptr_, cPtr_typeFormuleComparaisonValeur (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'typeFormuleComparaisonVariable'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeFormuleComparaisonVariable::cPtr_typeFormuleComparaisonVariable (const GGS_luint & argument_0,
                                const GGS_luint & argument_1,
                                const GGS_luint & argument_2,
                                const GGS_luint & argument_3,
                                const GGS_luint & argument_4,
                                const GGS_luint & argument_5,
                                const GGS_luint & argument_6,
                                const GGS_luint & argument_7)
:aIndiceBDDgauche (argument_0),
aDimension (argument_1),
mLeftLowBound (argument_2),
mLeftHighBound (argument_3),
aComparaison (argument_4),
aIndiceBDDdroite (argument_5),
mRightLowBound (argument_6),
mRightHighBound (argument_7) {
}

//---------------------------------------------------------------------------*
//                                                                           *
//            GALGAS class 'GGS_typeFormuleComparaisonVariable'              *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeFormuleComparaisonVariable * GGS_typeFormuleComparaisonVariable::
    constructor_new (const GGS_luint & argument_0,
                                const GGS_luint & argument_1,
                                const GGS_luint & argument_2,
                                const GGS_luint & argument_3,
                                const GGS_luint & argument_4,
                                const GGS_luint & argument_5,
                                const GGS_luint & argument_6,
                                const GGS_luint & argument_7) {
    cPtr_typeFormuleComparaisonVariable * ptr_ = (cPtr_typeFormuleComparaisonVariable *) NULL ;
    macroMyNew (ptr_, cPtr_typeFormuleComparaisonVariable (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6,
                                argument_7)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                     abstract class 'cPtr_typeCalcul'                      *
//                                                                           *
//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_typeCalcul'                        *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeCalcul::
GGS_typeCalcul (void) {
  mPointer = (cPtr_typeCalcul *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeCalcul::
GGS_typeCalcul (const GGS_typeCalcul & inOperand) {
  mPointer = (cPtr_typeCalcul *) NULL ;
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeCalcul::
~GGS_typeCalcul (void) {
  macroDetachPointer (mPointer, cPtr_typeCalcul) ;
}

//---------------------------------------------------------------------------*

void GGS_typeCalcul::
operator = (const GGS_typeCalcul & inOperand) {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

void GGS_typeCalcul::
operator = (cPtr_typeCalcul * inSource) {
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

GGS_typeCalcul::
GGS_typeCalcul (cPtr_typeCalcul * inSource) {
  mPointer = (cPtr_typeCalcul *) NULL ;
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeCalcul * GGS_typeCalcul
::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void GGS_typeCalcul
::drop_operation (void) {
  macroDetachPointer (mPointer, cPtr_typeCalcul) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'typeCalculSimple'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeCalculSimple::cPtr_typeCalculSimple (const GGS_luint & argument_0,
                                const GGS_typeFormule & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_typeTableVariablesBool & argument_3,
                                const GGS_luint & argument_4)
:aNumeroFormule (argument_0),
aFormule (argument_1),
aNomFormule (argument_2),
aTableVariablesBool (argument_3),
aAfficher (argument_4) {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeCalculSimple'                     *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeCalculSimple * GGS_typeCalculSimple::
    constructor_new (const GGS_luint & argument_0,
                                const GGS_typeFormule & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_typeTableVariablesBool & argument_3,
                                const GGS_luint & argument_4) {
    cPtr_typeCalculSimple * ptr_ = (cPtr_typeCalculSimple *) NULL ;
    macroMyNew (ptr_, cPtr_typeCalculSimple (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                           class 'typeUse_AND'                             *
//                                                                           *
//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_typeUse_AND'                       *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeUse_AND * GGS_typeUse_AND::
    constructor_new () {
    cPtr_typeUse_AND * ptr_ = (cPtr_typeUse_AND *) NULL ;
    macroMyNew (ptr_, cPtr_typeUse_AND ()) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                           class 'typeUse_ITE'                             *
//                                                                           *
//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_typeUse_ITE'                       *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeUse_ITE * GGS_typeUse_ITE::
    constructor_new () {
    cPtr_typeUse_ITE * ptr_ = (cPtr_typeUse_ITE *) NULL ;
    macroMyNew (ptr_, cPtr_typeUse_ITE ()) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'typeUse_AND_ITE'                           *
//                                                                           *
//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeUse_AND_ITE'                     *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeUse_AND_ITE * GGS_typeUse_AND_ITE::
    constructor_new () {
    cPtr_typeUse_AND_ITE * ptr_ = (cPtr_typeUse_AND_ITE *) NULL ;
    macroMyNew (ptr_, cPtr_typeUse_AND_ITE ()) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'typeDimensionnerANDCache'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeDimensionnerANDCache::cPtr_typeDimensionnerANDCache (const GGS_luint & argument_0)
:aDimensionCache (argument_0) {
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeDimensionnerANDCache'                 *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeDimensionnerANDCache * GGS_typeDimensionnerANDCache::
    constructor_new (const GGS_luint & argument_0) {
    cPtr_typeDimensionnerANDCache * ptr_ = (cPtr_typeDimensionnerANDCache *) NULL ;
    macroMyNew (ptr_, cPtr_typeDimensionnerANDCache (argument_0)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'typeDimensionnerITECache'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeDimensionnerITECache::cPtr_typeDimensionnerITECache (const GGS_luint & argument_0)
:aDimensionCache (argument_0) {
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeDimensionnerITECache'                 *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeDimensionnerITECache * GGS_typeDimensionnerITECache::
    constructor_new (const GGS_luint & argument_0) {
    cPtr_typeDimensionnerITECache * ptr_ = (cPtr_typeDimensionnerITECache *) NULL ;
    macroMyNew (ptr_, cPtr_typeDimensionnerITECache (argument_0)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'typeDimensionnerTable'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeDimensionnerTable::cPtr_typeDimensionnerTable (const GGS_luint & argument_0)
:aDimensionTable (argument_0) {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeDimensionnerTable'                  *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeDimensionnerTable * GGS_typeDimensionnerTable::
    constructor_new (const GGS_luint & argument_0) {
    cPtr_typeDimensionnerTable * ptr_ = (cPtr_typeDimensionnerTable *) NULL ;
    macroMyNew (ptr_, cPtr_typeDimensionnerTable (argument_0)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'typeAfficherBilan'                          *
//                                                                           *
//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeAfficherBilan'                    *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeAfficherBilan * GGS_typeAfficherBilan::
    constructor_new () {
    cPtr_typeAfficherBilan * ptr_ = (cPtr_typeAfficherBilan *) NULL ;
    macroMyNew (ptr_, cPtr_typeAfficherBilan ()) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'typeCalculIteratif'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeCalculIteratif::cPtr_typeCalculIteratif (const GGS_luint & argument_0,
                                const GGS_typeFormule & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_typeTableVariablesBool & argument_3,
                                const GGS_lbool & argument_4,
                                const GGS_luint & argument_5)
:aNumeroFormule (argument_0),
aFormule (argument_1),
aNomFormule (argument_2),
aTableVariablesBool (argument_3),
aSigne (argument_4),
aAfficher (argument_5) {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeCalculIteratif'                    *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeCalculIteratif * GGS_typeCalculIteratif::
    constructor_new (const GGS_luint & argument_0,
                                const GGS_typeFormule & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_typeTableVariablesBool & argument_3,
                                const GGS_lbool & argument_4,
                                const GGS_luint & argument_5) {
    cPtr_typeCalculIteratif * ptr_ = (cPtr_typeCalculIteratif *) NULL ;
    macroMyNew (ptr_, cPtr_typeCalculIteratif (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                   Element of list '@typeListeCalculs'                     *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeListeCalculs::
elementOf_GGS_typeListeCalculs (const GGS_typeCalcul & argument_0) {
  mNextItem = (elementOf_GGS_typeListeCalculs *) NULL ;
  aCalcul = argument_0 ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         List '@typeListeCalculs'                          *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeListeCalculs
::GGS_typeListeCalculs (void) { // Default Constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeListeCalculs::~GGS_typeListeCalculs (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*

GGS_typeListeCalculs::GGS_typeListeCalculs (const GGS_typeListeCalculs & source) { // Copy constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
  *this = source ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeCalculs
::operator = (const GGS_typeListeCalculs & source) { // Assignment operator
  if (this != & source) {
    emptyList () ;
    mFirstItem = source.mFirstItem ;
    mLastItem = source.mLastItem ;
    mListLength = source.mListLength ;
    mCountReference = source.mCountReference ;
    if (mCountReference != NULL) {
      macroValidPointer (mCountReference) ;
      (*mCountReference) ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeCalculs
::emptyList (void) {
  mListLength = 0 ;
  mLastItem = (element_type *) NULL ;
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) == 1) {
      macroMyDelete (mCountReference, sint32) ;
      while (mFirstItem != NULL) {
        macroValidPointer (mFirstItem) ;
        mLastItem = mFirstItem->mNextItem ;
        macroMyDelete (mFirstItem, element_type) ;
        mFirstItem = mLastItem ;
      }
    }else{
      mFirstItem = (element_type *) NULL ;
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeCalculs::
internalAppendItem (const GGS_typeCalcul & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mLastItem == NULL) {
      mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mLastItem) ;
      mLastItem->mNextItem = nouvelElement ;
    }
    mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeCalculs::
addAssign_operation (const GGS_typeCalcul & argument_0) {
  if (isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeCalculs
::insulateList (void) {
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) > 1) {
      element_type * p = mFirstItem ;
      mFirstItem = (element_type *)  NULL ;
      mLastItem = (element_type *)  NULL ;
      mListLength = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->aCalcul) ;
        p = p->mNextItem ;
      }
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
      macroMyNew (mCountReference, sint32 (1)) ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeListeCalculs  GGS_typeListeCalculs::
constructor_empty (void) {
  GGS_typeListeCalculs result ;
  macroMyNew (result.mCountReference, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeCalculs
::drop_operation (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//         Implementation of routine "verifierNombreArgumentsBool"           *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_verifierNombreArgumentsBool (C_Lexique & lexique_var_,
                                const GGS_typeFormalArgumentsList  & var_cas_t1,
                                const GGS_typeActualArgumentsList  & var_cas_t2,
                                const GGS_location  & var_cas_positionFinListe) {
  if (((var_cas_t1.reader_length ()) < (var_cas_t2.reader_length ())).isBuiltAndTrue ()) {
      var_cas_positionFinListe.reader_location ().signalGGSSemanticError (lexique_var_, GGS_string (true, "too much actual arguments")) ;
  }else if (((var_cas_t1.reader_length ()) > (var_cas_t2.reader_length ())).isBuiltAndTrue ()) {
      var_cas_positionFinListe.reader_location ().signalGGSSemanticError (lexique_var_, GGS_string (true, "one or more actual arguments missing")) ;
  }
  GGS_typeFormalArgumentsList::element_type * operand_7876 = var_cas_t1.firstObject () ;
  GGS_typeActualArgumentsList::element_type * operand_7965 = var_cas_t2.firstObject () ;
  while ((operand_7876 != NULL)
      && (operand_7965 != NULL)) {
    macroValidPointer (operand_7876) ;
    macroValidPointer (operand_7965) ;
    if (((operand_7876->mVariableBitSize.reader_value ()) == (operand_7965->mVariableBitSize.reader_value ())).isBuiltAndTrue ()) {
      if (((operand_7876->mLowBound.reader_value ()) == (operand_7965->mLowBound.reader_value ())).isBuiltAndTrue ()) {
        if (((operand_7876->mHighBound.reader_value ()) == (operand_7965->mHighBound.reader_value ())).isBuiltAndTrue ()) {
        }else{
            operand_7965->mErrorLocation.reader_location ().signalGGSSemanticError (lexique_var_, GGS_string (true, "the actual high bound is different the formal one")) ;
        }
      }else{
          operand_7965->mErrorLocation.reader_location ().signalGGSSemanticError (lexique_var_, GGS_string (true, "the actual low bound is different the formal one")) ;
      }
    }else{
        operand_7965->mErrorLocation.reader_location ().signalGGSSemanticError (lexique_var_, GGS_string (true, "the actual dimension is different from the formal one")) ;
    }
    operand_7876 = operand_7876->nextObject () ;
    operand_7965 = operand_7965->nextObject () ;
  }
}

//---------------------------------------------------------------------------*

