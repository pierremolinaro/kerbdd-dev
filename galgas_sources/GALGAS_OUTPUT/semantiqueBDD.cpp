//---------------------------------------------------------------------------*
//                                                                           *
//                         File 'semantiqueBDD.cpp'                          *
//               Generated by version 0.14.1 (LL(1) grammar)                 *
//                       june 3rd, 2005, at 14h12'47"                        *
//                                                                           *
// This program is free software; you can redistribute it and/or modify it   *
// under the terms of the GNU General Public License as published by the     *
// Free Software Foundation.                                                 *
//                                                                           *
// This program is distributed in the hope it will be useful, but WITHOUT    *
// ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or     *
// FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for  *
// more details.                                                             *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

#include "utilities/MF_MemoryControl.h"
#include "files/C_TextFileWrite.h"
#include "semantiqueBDD.h"

//---------------------------------------------------------------------------*
//                                                                           *
//               Include directives generated by extern types                *
//                                                                           *
//---------------------------------------------------------------------------*

#include "cTableVariablesBDD.hh"

//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//                     abstract class 'cPtr_typeDomain'                      *
//                                                                           *
//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*

const char * cPtr_typeDomain
::static_string_message_messageDomainType (void) {
  return "any domain" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeDomain::
message_messageDomainType (void) const {
  return "any domain" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_typeDomain'                        *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeDomain::
GGS_typeDomain (void) {
  mPointer = (cPtr_typeDomain *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeDomain::
GGS_typeDomain (const GGS_typeDomain & inOperand) {
  mPointer = (cPtr_typeDomain *) NULL ;
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeDomain::
~GGS_typeDomain (void) {
  macroDetachPointer (mPointer, cPtr_typeDomain) ;
}

//---------------------------------------------------------------------------*

void GGS_typeDomain::
operator = (const GGS_typeDomain & inOperand) {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

bool GGS_typeDomain::isBuilt (void) const {
  bool result = false ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    result = mPointer->isBuilt () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeDomain::
operator = (cPtr_typeDomain * inSource) {
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

GGS_typeDomain::
GGS_typeDomain (cPtr_typeDomain * inSource) {
  mPointer = (cPtr_typeDomain *) NULL ;
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

cPtr_typeDomain * GGS_typeDomain
::operator () (void) const {
  macroValidPointer (mPointer) ;
  return mPointer ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeDomain::reader_messageDomainType (void) const {
  return GGS_string (mPointer != NULL, C_String ((mPointer == NULL) ? "" : mPointer->message_messageDomainType ())) ;
}

//---------------------------------------------------------------------------*

void GGS_typeDomain
::drop_operation (void) {
  macroDetachPointer (mPointer, cPtr_typeDomain) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'typeDirectDomain'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeDirectDomain::cPtr_typeDirectDomain (const GGS_luint & argument_0,
                                const GGS_luint & argument_1,
                                const GGS_luint & argument_2)
:mLowBound (argument_0),
mHighBound (argument_1),
mBitsCount (argument_2) {
}

//---------------------------------------------------------------------------*

bool cPtr_typeDirectDomain::isBuilt (void) const {
  return mLowBound.isBuilt () &&
       mHighBound.isBuilt () &&
       mBitsCount.isBuilt () ;
}


const char * cPtr_typeDirectDomain::message_messageDomainType (void) const {
  return "an interval domain" ;
}

const char * cPtr_typeDirectDomain::static_string_message_messageDomainType (void) {
  return "an interval domain" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeDirectDomain'                     *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeDirectDomain * GGS_typeDirectDomain::
    constructor_new (const GGS_luint & argument_0,
                                const GGS_luint & argument_1,
                                const GGS_luint & argument_2) {
    cPtr_typeDirectDomain * ptr_ = (cPtr_typeDirectDomain *) NULL ;
    macroMyNew (ptr_, cPtr_typeDirectDomain (argument_0,
                                argument_1,
                                argument_2)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                        class map 'typeDomainMap'                          *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeDomainMap::element_type::
element_type (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_typeDomainMap & inInfo) :
AC_galgas_map_element (inIndex),
mKey (inKey),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_typeDomainMap::
new_element (void * inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <GGS_lstring *> (inKey) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_typeDomainMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  GGS_lstring * key = (GGS_lstring *) inKey ;
  e_typeDomainMap * info = (e_typeDomainMap *) inInfo ;
  macroMyNew (p, element_type (* key, count (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

sint32 GGS_typeDomainMap::element_type::compareKeys (void * inKey) const {
  MF_Assert (reinterpret_cast <GGS_lstring *> (inKey) != NULL, "Dynamic cast error", 0, 0) ;
  GGS_lstring * key = (GGS_lstring *) inKey ;
  return mKey.compare_key_for_map (* key) ;
}

//---------------------------------------------------------------------------*

C_String GGS_typeDomainMap::element_type::getStringForKey (void) const {
  C_String result ;
  result << mKey ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeDomainMap GGS_typeDomainMap::constructor_empty (void) {
  GGS_typeDomainMap result ;
  macroMyNew (result.mReferenceCountPtr, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeDomainMap::reader_hasKey (const GGS_lstring & inKey) const {
  return GGS_bool (isBuilt (), internal_has_key ((void *) & inKey)) ;
}

//---------------------------------------------------------------------------*

void GGS_typeDomainMap::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  internalInsert ((void * ) & p->mKey, (void *) & p->mInfo, mRoot, extension, index) ;
}

//---------------------------------------------------------------------------*

void GGS_typeDomainMap::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessagesArray [],
               const GGS_lstring & inKey,
               const GGS_typeDomain &  inParameter0,
               GGS_luint * outIndex) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()
                 && inParameter0.isBuilt ()) {
     insulateMap () ;
    e_typeDomainMap info  ;
    info.mDomain = inParameter0 ;
    bool extension = false ; // Unused here
    internalInsert ((void * ) & inKey, (void *) & info, mRoot, extension, index) ;
    if (index < 0) {
      C_String keyString ;
      keyString << inKey ;
      buildMapSemanticErrorMessage (inLexique, inKey, inErrorMessagesArray, keyString) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (isBuilt () && (index >= 0), (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeDomainMap::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessagesArray [],
               const GGS_lstring & inKey,
               GGS_typeDomain   * outParameter0,
               GGS_luint * outIndex) {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search ((void *) & inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      C_String keyString ;
      keyString << inKey ;
      buildMapSemanticErrorMessage (inLexique, inKey, inErrorMessagesArray, keyString) ;
    }
  }
  if (node == NULL) {
    if (outParameter0 != NULL) {
      outParameter0->drop_operation () ;
    }
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    if (outParameter0 != NULL) {
      * outParameter0 = node->mInfo.mDomain ;
    }
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void searchKey_typeDomainMap (C_Lexique & inLexique,
                                GGS_typeDomainMap & ioMap,
                                const GGS_lstring & inKey,
                                GGS_typeDomain   * outParameter0,
                                GGS_luint * outIndex) {
  const char * kErrorMessage [] = {"the '%' domain is not declared",
                                   NULL} ;
  ioMap.searchElement (inLexique,
                       kErrorMessage,
                       inKey,
                       outParameter0,
                       outIndex) ;
}

//---------------------------------------------------------------------------*

void insertKey_typeDomainMap (C_Lexique & lexique_var_,
                                GGS_typeDomainMap & ioMap,
                                const GGS_lstring & inKey,
                                const GGS_typeDomain & inParameter0,
                                GGS_luint * outIndex) {
  const char * kErrorMessage [] = {"the '%' domain has been already declared",
                                   NULL} ;
  ioMap.insertElement (lexique_var_,
                       kErrorMessage,
                       inKey,
                       inParameter0,
                       outIndex) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'typeRecordDomain'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeRecordDomain::cPtr_typeRecordDomain (const GGS_typeDomainMap & argument_0)
:mRecordMap (argument_0) {
}

//---------------------------------------------------------------------------*

bool cPtr_typeRecordDomain::isBuilt (void) const {
  return mRecordMap.isBuilt () ;
}


const char * cPtr_typeRecordDomain::message_messageDomainType (void) const {
  return "a record domain" ;
}

const char * cPtr_typeRecordDomain::static_string_message_messageDomainType (void) {
  return "a record domain" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeRecordDomain'                     *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeRecordDomain * GGS_typeRecordDomain::
    constructor_new (const GGS_typeDomainMap & argument_0) {
    cPtr_typeRecordDomain * ptr_ = (cPtr_typeRecordDomain *) NULL ;
    macroMyNew (ptr_, cPtr_typeRecordDomain (argument_0)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//             Class element of list 'typeFormalArgumentsList'               *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeFormalArgumentsList::element_type::
element_type (const GGS_luint & argument_0,
                                const GGS_luint & argument_1,
                                const GGS_luint & argument_2,
                                const GGS_luint & argument_3) {
  mNextItem = (element_type *) NULL ;
  mVariableIndex = argument_0 ;
  mVariableBitSize = argument_1 ;
  mLowBound = argument_2 ;
  mHighBound = argument_3 ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class list 'typeFormalArgumentsList'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeFormalArgumentsList
::GGS_typeFormalArgumentsList (void) { // Default Constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mCurrentItemPtr = (element_type *) NULL ;
  mCurrentItemIndex = 0 ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeFormalArgumentsList::~GGS_typeFormalArgumentsList (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*

GGS_typeFormalArgumentsList::GGS_typeFormalArgumentsList (const GGS_typeFormalArgumentsList & source) { // Copy constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mCurrentItemPtr = (element_type *) NULL ;
  mCurrentItemIndex = 0 ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
  *this = source ;
}

//---------------------------------------------------------------------------*

void GGS_typeFormalArgumentsList
::operator = (const GGS_typeFormalArgumentsList & source) { // Assignment operator
  if (this != & source) {
    emptyList () ;
    mFirstItem = source.mFirstItem ;
    mLastItem = source.mLastItem ;
    mCurrentItemPtr = (element_type *) NULL ;
    mCurrentItemIndex = 0 ;
    mListLength = source.mListLength ;
    mCountReference = source.mCountReference ;
    if (mCountReference != NULL) {
      macroValidPointer (mCountReference) ;
      (*mCountReference) ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeFormalArgumentsList
::emptyList (void) {
  mCurrentItemPtr = (element_type *) NULL ;
  mCurrentItemIndex = 0 ;
  mListLength = 0 ;
  mLastItem = (element_type *) NULL ;
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) == 1) {
      macroMyDelete (mCountReference, sint32) ;
      while (mFirstItem != NULL) {
        macroValidPointer (mFirstItem) ;
        mLastItem = mFirstItem->mNextItem ;
        macroMyDelete (mFirstItem, element_type) ;
        mFirstItem = mLastItem ;
      }
    }else{
      mFirstItem = (element_type *) NULL ;
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeFormalArgumentsList::
internalAppendItem (const GGS_luint & argument_0,
                                const GGS_luint & argument_1,
                                const GGS_luint & argument_2,
                                const GGS_luint & argument_3) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2,
                                argument_3)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mLastItem == NULL) {
      mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mLastItem) ;
      mLastItem->mNextItem = nouvelElement ;
    }
    mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeFormalArgumentsList::
addAssign_operation (const GGS_luint & argument_0,
                                const GGS_luint & argument_1,
                                const GGS_luint & argument_2,
                                const GGS_luint & argument_3) {
  if (isBuilt ()
                 && argument_0.isBuilt ()
                 && argument_1.isBuilt ()
                 && argument_2.isBuilt ()
                 && argument_3.isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0,
                                argument_1,
                                argument_2,
                                argument_3) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeFormalArgumentsList
::insulateList (void) {
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) > 1) {
      element_type * p = mFirstItem ;
      mFirstItem = (element_type *)  NULL ;
      mLastItem = (element_type *)  NULL ;
      mListLength = 0 ;
      mCurrentItemPtr = (element_type *) NULL ;
      mCurrentItemIndex = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->mVariableIndex,
                                p->mVariableBitSize,
                                p->mLowBound,
                                p->mHighBound) ;
        p = p->mNextItem ;
      }
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
      macroMyNew (mCountReference, sint32 (1)) ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeFormalArgumentsList  GGS_typeFormalArgumentsList::
constructor_empty (void) {
  GGS_typeFormalArgumentsList result ;
  macroMyNew (result.mCountReference, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeFormalArgumentsList
::drop_operation (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             Class element of list 'typeActualArgumentsList'               *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeActualArgumentsList::element_type::
element_type (const GGS_luint & argument_0,
                                const GGS_luint & argument_1,
                                const GGS_luint & argument_2,
                                const GGS_luint & argument_3,
                                const GGS_location & argument_4) {
  mNextItem = (element_type *) NULL ;
  mVariableIndex = argument_0 ;
  mVariableBitSize = argument_1 ;
  mLowBound = argument_2 ;
  mHighBound = argument_3 ;
  mErrorLocation = argument_4 ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class list 'typeActualArgumentsList'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeActualArgumentsList
::GGS_typeActualArgumentsList (void) { // Default Constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mCurrentItemPtr = (element_type *) NULL ;
  mCurrentItemIndex = 0 ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeActualArgumentsList::~GGS_typeActualArgumentsList (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*

GGS_typeActualArgumentsList::GGS_typeActualArgumentsList (const GGS_typeActualArgumentsList & source) { // Copy constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mCurrentItemPtr = (element_type *) NULL ;
  mCurrentItemIndex = 0 ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
  *this = source ;
}

//---------------------------------------------------------------------------*

void GGS_typeActualArgumentsList
::operator = (const GGS_typeActualArgumentsList & source) { // Assignment operator
  if (this != & source) {
    emptyList () ;
    mFirstItem = source.mFirstItem ;
    mLastItem = source.mLastItem ;
    mCurrentItemPtr = (element_type *) NULL ;
    mCurrentItemIndex = 0 ;
    mListLength = source.mListLength ;
    mCountReference = source.mCountReference ;
    if (mCountReference != NULL) {
      macroValidPointer (mCountReference) ;
      (*mCountReference) ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeActualArgumentsList
::emptyList (void) {
  mCurrentItemPtr = (element_type *) NULL ;
  mCurrentItemIndex = 0 ;
  mListLength = 0 ;
  mLastItem = (element_type *) NULL ;
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) == 1) {
      macroMyDelete (mCountReference, sint32) ;
      while (mFirstItem != NULL) {
        macroValidPointer (mFirstItem) ;
        mLastItem = mFirstItem->mNextItem ;
        macroMyDelete (mFirstItem, element_type) ;
        mFirstItem = mLastItem ;
      }
    }else{
      mFirstItem = (element_type *) NULL ;
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeActualArgumentsList::
internalAppendItem (const GGS_luint & argument_0,
                                const GGS_luint & argument_1,
                                const GGS_luint & argument_2,
                                const GGS_luint & argument_3,
                                const GGS_location & argument_4) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mLastItem == NULL) {
      mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mLastItem) ;
      mLastItem->mNextItem = nouvelElement ;
    }
    mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeActualArgumentsList::
addAssign_operation (const GGS_luint & argument_0,
                                const GGS_luint & argument_1,
                                const GGS_luint & argument_2,
                                const GGS_luint & argument_3,
                                const GGS_location & argument_4) {
  if (isBuilt ()
                 && argument_0.isBuilt ()
                 && argument_1.isBuilt ()
                 && argument_2.isBuilt ()
                 && argument_3.isBuilt ()
                 && argument_4.isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeActualArgumentsList
::insulateList (void) {
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) > 1) {
      element_type * p = mFirstItem ;
      mFirstItem = (element_type *)  NULL ;
      mLastItem = (element_type *)  NULL ;
      mListLength = 0 ;
      mCurrentItemPtr = (element_type *) NULL ;
      mCurrentItemIndex = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->mVariableIndex,
                                p->mVariableBitSize,
                                p->mLowBound,
                                p->mHighBound,
                                p->mErrorLocation) ;
        p = p->mNextItem ;
      }
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
      macroMyNew (mCountReference, sint32 (1)) ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeActualArgumentsList  GGS_typeActualArgumentsList::
constructor_empty (void) {
  GGS_typeActualArgumentsList result ;
  macroMyNew (result.mCountReference, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeActualArgumentsList
::drop_operation (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               abstract class 'cPtr_typeVariableDescriptor'                *
//                                                                           *
//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*

const char * cPtr_typeVariableDescriptor
::static_string_message_variableDescriptorErrorMessage (void) {
  return "any variable" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeVariableDescriptor::
message_variableDescriptorErrorMessage (void) const {
  return "any variable" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_typeVariableDescriptor'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeVariableDescriptor::
GGS_typeVariableDescriptor (void) {
  mPointer = (cPtr_typeVariableDescriptor *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeVariableDescriptor::
GGS_typeVariableDescriptor (const GGS_typeVariableDescriptor & inOperand) {
  mPointer = (cPtr_typeVariableDescriptor *) NULL ;
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeVariableDescriptor::
~GGS_typeVariableDescriptor (void) {
  macroDetachPointer (mPointer, cPtr_typeVariableDescriptor) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariableDescriptor::
operator = (const GGS_typeVariableDescriptor & inOperand) {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

bool GGS_typeVariableDescriptor::isBuilt (void) const {
  bool result = false ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    result = mPointer->isBuilt () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariableDescriptor::
operator = (cPtr_typeVariableDescriptor * inSource) {
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

GGS_typeVariableDescriptor::
GGS_typeVariableDescriptor (cPtr_typeVariableDescriptor * inSource) {
  mPointer = (cPtr_typeVariableDescriptor *) NULL ;
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

cPtr_typeVariableDescriptor * GGS_typeVariableDescriptor
::operator () (void) const {
  macroValidPointer (mPointer) ;
  return mPointer ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeVariableDescriptor::reader_variableDescriptorErrorMessage (void) const {
  return GGS_string (mPointer != NULL, C_String ((mPointer == NULL) ? "" : mPointer->message_variableDescriptorErrorMessage ())) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariableDescriptor
::drop_operation (void) {
  macroDetachPointer (mPointer, cPtr_typeVariableDescriptor) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'typeDirectVariable'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeDirectVariable::cPtr_typeDirectVariable (const GGS_luint & argument_0,
                                const GGS_luint & argument_1,
                                const GGS_luint & argument_2,
                                const GGS_luint & argument_3)
:mIndex (argument_0),
mBitSize (argument_1),
mLowBound (argument_2),
mHighBound (argument_3) {
}

//---------------------------------------------------------------------------*

bool cPtr_typeDirectVariable::isBuilt (void) const {
  return mIndex.isBuilt () &&
       mBitSize.isBuilt () &&
       mLowBound.isBuilt () &&
       mHighBound.isBuilt () ;
}


const char * cPtr_typeDirectVariable::message_variableDescriptorErrorMessage (void) const {
  return "a direct domain variable" ;
}

const char * cPtr_typeDirectVariable::static_string_message_variableDescriptorErrorMessage (void) {
  return "a direct domain variable" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeDirectVariable'                    *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeDirectVariable * GGS_typeDirectVariable::
    constructor_new (const GGS_luint & argument_0,
                                const GGS_luint & argument_1,
                                const GGS_luint & argument_2,
                                const GGS_luint & argument_3) {
    cPtr_typeDirectVariable * ptr_ = (cPtr_typeDirectVariable *) NULL ;
    macroMyNew (ptr_, cPtr_typeDirectVariable (argument_0,
                                argument_1,
                                argument_2,
                                argument_3)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//               class map element 'e_typeTableVariablesBool'                *
//                                                                           *
//---------------------------------------------------------------------------*

template class cTableVariablesBDD <e_typeTableVariablesBool, GGS_lstring> ;

//---------------------------------------------------------------------------*

bool e_typeTableVariablesBool::isBuilt (void) const {
  return mVariableDescriptor.isBuilt () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       Map 'typeTableVariablesBool'                        *
//                                                                           *
//---------------------------------------------------------------------------*

void searchKey_typeTableVariablesBool (C_Lexique & inLexique,
                                GGS_typeTableVariablesBool & ioMap,
                                const GGS_lstring & inKey,
                                GGS_typeVariableDescriptor   * outParameter0,
                                GGS_luint * outIndex) {
  const char * errorMessage_0 = "the '%' variable is not declared" ;
  GGS_typeTableVariablesBool::element_type * info = ioMap.searchKey (inLexique, inKey, inKey, errorMessage_0) ;
  if (info == NULL) {
    if (outParameter0 != NULL) {
      outParameter0->drop_operation () ;
    }
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
    }
  }else{
    if (outParameter0 != NULL) {
      * outParameter0 = info->mInfo.mVariableDescriptor ;
    }
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) info->mEntryIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void insertKey_typeTableVariablesBool (C_Lexique & lexique_var_,
                                GGS_typeTableVariablesBool & ioMap,
                                const GGS_lstring & inKey,
                                const GGS_typeVariableDescriptor &  inParameter0,
                                GGS_luint * outIndex) {
  const char * kErrorMessage_0 = "the '%' variable has been already declared" ;
  e_typeTableVariablesBool info ;
  info.mVariableDescriptor = inParameter0 ;
  const sint32 index = ioMap.insertKey (lexique_var_, info, inKey, inKey, kErrorMessage_0) ;
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (index >= 0, (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'typeRecordVariable'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeRecordVariable::cPtr_typeRecordVariable (const GGS_typeTableVariablesBool & argument_0)
:mMap (argument_0) {
}

//---------------------------------------------------------------------------*

bool cPtr_typeRecordVariable::isBuilt (void) const {
  return mMap.isBuilt () ;
}


const char * cPtr_typeRecordVariable::message_variableDescriptorErrorMessage (void) const {
  return "a record domain variable" ;
}

const char * cPtr_typeRecordVariable::static_string_message_variableDescriptorErrorMessage (void) {
  return "a record domain variable" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeRecordVariable'                    *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeRecordVariable * GGS_typeRecordVariable::
    constructor_new (const GGS_typeTableVariablesBool & argument_0) {
    cPtr_typeRecordVariable * ptr_ = (cPtr_typeRecordVariable *) NULL ;
    macroMyNew (ptr_, cPtr_typeRecordVariable (argument_0)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                      class map 'typeTableFormules'                        *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeTableFormules::element_type::
element_type (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_typeTableFormules & inInfo) :
AC_galgas_map_element (inIndex),
mKey (inKey),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_typeTableFormules::
new_element (void * inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <GGS_lstring *> (inKey) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_typeTableFormules *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  GGS_lstring * key = (GGS_lstring *) inKey ;
  e_typeTableFormules * info = (e_typeTableFormules *) inInfo ;
  macroMyNew (p, element_type (* key, count (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

sint32 GGS_typeTableFormules::element_type::compareKeys (void * inKey) const {
  MF_Assert (reinterpret_cast <GGS_lstring *> (inKey) != NULL, "Dynamic cast error", 0, 0) ;
  GGS_lstring * key = (GGS_lstring *) inKey ;
  return mKey.compare_key_for_map (* key) ;
}

//---------------------------------------------------------------------------*

C_String GGS_typeTableFormules::element_type::getStringForKey (void) const {
  C_String result ;
  result << mKey ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeTableFormules GGS_typeTableFormules::constructor_empty (void) {
  GGS_typeTableFormules result ;
  macroMyNew (result.mReferenceCountPtr, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeTableFormules::reader_hasKey (const GGS_lstring & inKey) const {
  return GGS_bool (isBuilt (), internal_has_key ((void *) & inKey)) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableFormules::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  internalInsert ((void * ) & p->mKey, (void *) & p->mInfo, mRoot, extension, index) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableFormules::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessagesArray [],
               const GGS_lstring & inKey,
               const GGS_typeFormalArgumentsList &  inParameter0,
               const GGS_bdd&  inParameter1,
               GGS_luint * outIndex) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()
                 && inParameter0.isBuilt ()
                 && inParameter1.isBuilt ()) {
     insulateMap () ;
    e_typeTableFormules info  ;
    info.aListeArgsFormelsBool = inParameter0 ;
    info.aBDD = inParameter1 ;
    bool extension = false ; // Unused here
    internalInsert ((void * ) & inKey, (void *) & info, mRoot, extension, index) ;
    if (index < 0) {
      C_String keyString ;
      keyString << inKey ;
      buildMapSemanticErrorMessage (inLexique, inKey, inErrorMessagesArray, keyString) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (isBuilt () && (index >= 0), (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTableFormules::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessagesArray [],
               const GGS_lstring & inKey,
               GGS_typeFormalArgumentsList   * outParameter0,
               GGS_bdd  * outParameter1,
               GGS_luint * outIndex) {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search ((void *) & inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      C_String keyString ;
      keyString << inKey ;
      buildMapSemanticErrorMessage (inLexique, inKey, inErrorMessagesArray, keyString) ;
    }
  }
  if (node == NULL) {
    if (outParameter0 != NULL) {
      outParameter0->drop_operation () ;
    }
    if (outParameter1 != NULL) {
      outParameter1->drop_operation () ;
    }
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    if (outParameter0 != NULL) {
      * outParameter0 = node->mInfo.aListeArgsFormelsBool ;
    }
    if (outParameter1 != NULL) {
      * outParameter1 = node->mInfo.aBDD ;
    }
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void searchKey_typeTableFormules (C_Lexique & inLexique,
                                GGS_typeTableFormules & ioMap,
                                const GGS_lstring & inKey,
                                GGS_typeFormalArgumentsList   * outParameter0,
                                GGS_bdd  * outParameter1,
                                GGS_luint * outIndex) {
  const char * kErrorMessage [] = {"the '#",
                                   "",
                                   "' formula is not defined",
                                   NULL} ;
  ioMap.searchElement (inLexique,
                       kErrorMessage,
                       inKey,
                       outParameter0,
                       outParameter1,
                       outIndex) ;
}

//---------------------------------------------------------------------------*

void insertKey_typeTableFormules (C_Lexique & lexique_var_,
                                GGS_typeTableFormules & ioMap,
                                const GGS_lstring & inKey,
                                const GGS_typeFormalArgumentsList & inParameter0,
                                const GGS_bdd& inParameter1,
                                GGS_luint * outIndex) {
  const char * kErrorMessage [] = {"the '#",
                                   "",
                                   "' formula is already defined",
                                   NULL} ;
  ioMap.insertElement (lexique_var_,
                       kErrorMessage,
                       inKey,
                       inParameter0,
                       inParameter1,
                       outIndex) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    abstract class 'cPtr_typeFormule'                      *
//                                                                           *
//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_typeFormule'                       *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeFormule::
GGS_typeFormule (void) {
  mPointer = (cPtr_typeFormule *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeFormule::
GGS_typeFormule (const GGS_typeFormule & inOperand) {
  mPointer = (cPtr_typeFormule *) NULL ;
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeFormule::
~GGS_typeFormule (void) {
  macroDetachPointer (mPointer, cPtr_typeFormule) ;
}

//---------------------------------------------------------------------------*

void GGS_typeFormule::
operator = (const GGS_typeFormule & inOperand) {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

bool GGS_typeFormule::isBuilt (void) const {
  bool result = false ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    result = mPointer->isBuilt () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeFormule::
operator = (cPtr_typeFormule * inSource) {
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

GGS_typeFormule::
GGS_typeFormule (cPtr_typeFormule * inSource) {
  mPointer = (cPtr_typeFormule *) NULL ;
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

cPtr_typeFormule * GGS_typeFormule
::operator () (void) const {
  macroValidPointer (mPointer) ;
  return mPointer ;
}

//---------------------------------------------------------------------------*

void GGS_typeFormule
::drop_operation (void) {
  macroDetachPointer (mPointer, cPtr_typeFormule) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'typeFormuleTrue'                           *
//                                                                           *
//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*

bool cPtr_typeFormuleTrue::isBuilt (void) const {
  return true ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeFormuleTrue'                     *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeFormuleTrue * GGS_typeFormuleTrue::
    constructor_new () {
    cPtr_typeFormuleTrue * ptr_ = (cPtr_typeFormuleTrue *) NULL ;
    macroMyNew (ptr_, cPtr_typeFormuleTrue ()) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'typeFormuleFalse'                          *
//                                                                           *
//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*

bool cPtr_typeFormuleFalse::isBuilt (void) const {
  return true ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeFormuleFalse'                     *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeFormuleFalse * GGS_typeFormuleFalse::
    constructor_new () {
    cPtr_typeFormuleFalse * ptr_ = (cPtr_typeFormuleFalse *) NULL ;
    macroMyNew (ptr_, cPtr_typeFormuleFalse ()) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'typeFormuleVar'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeFormuleVar::cPtr_typeFormuleVar (const GGS_luint & argument_0,
                                const GGS_luint & argument_1,
                                const GGS_luint & argument_2)
:aNumeroVariable (argument_0),
mLowBound (argument_1),
mHighBound (argument_2) {
}

//---------------------------------------------------------------------------*

bool cPtr_typeFormuleVar::isBuilt (void) const {
  return aNumeroVariable.isBuilt () &&
       mLowBound.isBuilt () &&
       mHighBound.isBuilt () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeFormuleVar'                      *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeFormuleVar * GGS_typeFormuleVar::
    constructor_new (const GGS_luint & argument_0,
                                const GGS_luint & argument_1,
                                const GGS_luint & argument_2) {
    cPtr_typeFormuleVar * ptr_ = (cPtr_typeFormuleVar *) NULL ;
    macroMyNew (ptr_, cPtr_typeFormuleVar (argument_0,
                                argument_1,
                                argument_2)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'typeFormuleFor'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeFormuleFor::cPtr_typeFormuleFor (const GGS_luint & argument_0,
                                const GGS_typeActualArgumentsList & argument_1,
                                const GGS_bdd& argument_2,
                                const GGS_lbool & argument_3)
:aNumeroFormule (argument_0),
aListeArgsBool (argument_1),
aFormuleTraduite (argument_2),
aEstFormuleCourante (argument_3) {
}

//---------------------------------------------------------------------------*

bool cPtr_typeFormuleFor::isBuilt (void) const {
  return aNumeroFormule.isBuilt () &&
       aListeArgsBool.isBuilt () &&
       aFormuleTraduite.isBuilt () &&
       aEstFormuleCourante.isBuilt () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeFormuleFor'                      *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeFormuleFor * GGS_typeFormuleFor::
    constructor_new (const GGS_luint & argument_0,
                                const GGS_typeActualArgumentsList & argument_1,
                                const GGS_bdd& argument_2,
                                const GGS_lbool & argument_3) {
    cPtr_typeFormuleFor * ptr_ = (cPtr_typeFormuleFor *) NULL ;
    macroMyNew (ptr_, cPtr_typeFormuleFor (argument_0,
                                argument_1,
                                argument_2,
                                argument_3)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'typeFormuleNon'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeFormuleNon::cPtr_typeFormuleNon (const GGS_typeFormule & argument_0)
:aOperande (argument_0) {
}

//---------------------------------------------------------------------------*

bool cPtr_typeFormuleNon::isBuilt (void) const {
  return aOperande.isBuilt () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeFormuleNon'                      *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeFormuleNon * GGS_typeFormuleNon::
    constructor_new (const GGS_typeFormule & argument_0) {
    cPtr_typeFormuleNon * ptr_ = (cPtr_typeFormuleNon *) NULL ;
    macroMyNew (ptr_, cPtr_typeFormuleNon (argument_0)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'typeFormuleEt'                            *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeFormuleEt::cPtr_typeFormuleEt (const GGS_typeFormule & argument_0,
                                const GGS_typeFormule & argument_1)
:aOperande1 (argument_0),
aOperande2 (argument_1) {
}

//---------------------------------------------------------------------------*

bool cPtr_typeFormuleEt::isBuilt (void) const {
  return aOperande1.isBuilt () &&
       aOperande2.isBuilt () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_typeFormuleEt'                      *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeFormuleEt * GGS_typeFormuleEt::
    constructor_new (const GGS_typeFormule & argument_0,
                                const GGS_typeFormule & argument_1) {
    cPtr_typeFormuleEt * ptr_ = (cPtr_typeFormuleEt *) NULL ;
    macroMyNew (ptr_, cPtr_typeFormuleEt (argument_0,
                                argument_1)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'typeFormuleIte'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeFormuleIte::cPtr_typeFormuleIte (const GGS_typeFormule & argument_0,
                                const GGS_typeFormule & argument_1,
                                const GGS_typeFormule & argument_2)
:aOperande1 (argument_0),
aOperande2 (argument_1),
aOperande3 (argument_2) {
}

//---------------------------------------------------------------------------*

bool cPtr_typeFormuleIte::isBuilt (void) const {
  return aOperande1.isBuilt () &&
       aOperande2.isBuilt () &&
       aOperande3.isBuilt () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeFormuleIte'                      *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeFormuleIte * GGS_typeFormuleIte::
    constructor_new (const GGS_typeFormule & argument_0,
                                const GGS_typeFormule & argument_1,
                                const GGS_typeFormule & argument_2) {
    cPtr_typeFormuleIte * ptr_ = (cPtr_typeFormuleIte *) NULL ;
    macroMyNew (ptr_, cPtr_typeFormuleIte (argument_0,
                                argument_1,
                                argument_2)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'typeFormuleOu'                            *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeFormuleOu::cPtr_typeFormuleOu (const GGS_typeFormule & argument_0,
                                const GGS_typeFormule & argument_1)
:aOperande1 (argument_0),
aOperande2 (argument_1) {
}

//---------------------------------------------------------------------------*

bool cPtr_typeFormuleOu::isBuilt (void) const {
  return aOperande1.isBuilt () &&
       aOperande2.isBuilt () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_typeFormuleOu'                      *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeFormuleOu * GGS_typeFormuleOu::
    constructor_new (const GGS_typeFormule & argument_0,
                                const GGS_typeFormule & argument_1) {
    cPtr_typeFormuleOu * ptr_ = (cPtr_typeFormuleOu *) NULL ;
    macroMyNew (ptr_, cPtr_typeFormuleOu (argument_0,
                                argument_1)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'typeFormuleImplique'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeFormuleImplique::cPtr_typeFormuleImplique (const GGS_typeFormule & argument_0,
                                const GGS_typeFormule & argument_1)
:aOperande1 (argument_0),
aOperande2 (argument_1) {
}

//---------------------------------------------------------------------------*

bool cPtr_typeFormuleImplique::isBuilt (void) const {
  return aOperande1.isBuilt () &&
       aOperande2.isBuilt () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeFormuleImplique'                   *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeFormuleImplique * GGS_typeFormuleImplique::
    constructor_new (const GGS_typeFormule & argument_0,
                                const GGS_typeFormule & argument_1) {
    cPtr_typeFormuleImplique * ptr_ = (cPtr_typeFormuleImplique *) NULL ;
    macroMyNew (ptr_, cPtr_typeFormuleImplique (argument_0,
                                argument_1)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'typeComparaisonFormules'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeComparaisonFormules::cPtr_typeComparaisonFormules (const GGS_luint & argument_0,
                                const GGS_typeFormule & argument_1,
                                const GGS_typeFormule & argument_2)
:aComparaison (argument_0),
aOperande1 (argument_1),
aOperande2 (argument_2) {
}

//---------------------------------------------------------------------------*

bool cPtr_typeComparaisonFormules::isBuilt (void) const {
  return aComparaison.isBuilt () &&
       aOperande1.isBuilt () &&
       aOperande2.isBuilt () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_typeComparaisonFormules'                 *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeComparaisonFormules * GGS_typeComparaisonFormules::
    constructor_new (const GGS_luint & argument_0,
                                const GGS_typeFormule & argument_1,
                                const GGS_typeFormule & argument_2) {
    cPtr_typeComparaisonFormules * ptr_ = (cPtr_typeComparaisonFormules *) NULL ;
    macroMyNew (ptr_, cPtr_typeComparaisonFormules (argument_0,
                                argument_1,
                                argument_2)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'typeFormuleExist'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeFormuleExist::cPtr_typeFormuleExist (const GGS_typeFormalArgumentsList & argument_0,
                                const GGS_typeFormule & argument_1,
                                const GGS_bdd& argument_2)
:aListeArgsBooleens (argument_0),
aOperande (argument_1),
aContraintes (argument_2) {
}

//---------------------------------------------------------------------------*

bool cPtr_typeFormuleExist::isBuilt (void) const {
  return aListeArgsBooleens.isBuilt () &&
       aOperande.isBuilt () &&
       aContraintes.isBuilt () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeFormuleExist'                     *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeFormuleExist * GGS_typeFormuleExist::
    constructor_new (const GGS_typeFormalArgumentsList & argument_0,
                                const GGS_typeFormule & argument_1,
                                const GGS_bdd& argument_2) {
    cPtr_typeFormuleExist * ptr_ = (cPtr_typeFormuleExist *) NULL ;
    macroMyNew (ptr_, cPtr_typeFormuleExist (argument_0,
                                argument_1,
                                argument_2)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'typeFormuleComparaisonValeur'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeFormuleComparaisonValeur::cPtr_typeFormuleComparaisonValeur (const GGS_luint & argument_0,
                                const GGS_luint & argument_1,
                                const GGS_luint & argument_2,
                                const GGS_luint & argument_3,
                                const GGS_luint & argument_4,
                                const GGS_luint & argument_5)
:aIndiceBDD (argument_0),
aDimension (argument_1),
mLowBound (argument_2),
mHighBound (argument_3),
aComparaison (argument_4),
aValeur (argument_5) {
}

//---------------------------------------------------------------------------*

bool cPtr_typeFormuleComparaisonValeur::isBuilt (void) const {
  return aIndiceBDD.isBuilt () &&
       aDimension.isBuilt () &&
       mLowBound.isBuilt () &&
       mHighBound.isBuilt () &&
       aComparaison.isBuilt () &&
       aValeur.isBuilt () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_typeFormuleComparaisonValeur'               *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeFormuleComparaisonValeur * GGS_typeFormuleComparaisonValeur::
    constructor_new (const GGS_luint & argument_0,
                                const GGS_luint & argument_1,
                                const GGS_luint & argument_2,
                                const GGS_luint & argument_3,
                                const GGS_luint & argument_4,
                                const GGS_luint & argument_5) {
    cPtr_typeFormuleComparaisonValeur * ptr_ = (cPtr_typeFormuleComparaisonValeur *) NULL ;
    macroMyNew (ptr_, cPtr_typeFormuleComparaisonValeur (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'typeFormuleComparaisonVariable'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeFormuleComparaisonVariable::cPtr_typeFormuleComparaisonVariable (const GGS_luint & argument_0,
                                const GGS_luint & argument_1,
                                const GGS_luint & argument_2,
                                const GGS_luint & argument_3,
                                const GGS_luint & argument_4,
                                const GGS_luint & argument_5,
                                const GGS_luint & argument_6,
                                const GGS_luint & argument_7)
:aIndiceBDDgauche (argument_0),
aDimension (argument_1),
mLeftLowBound (argument_2),
mLeftHighBound (argument_3),
aComparaison (argument_4),
aIndiceBDDdroite (argument_5),
mRightLowBound (argument_6),
mRightHighBound (argument_7) {
}

//---------------------------------------------------------------------------*

bool cPtr_typeFormuleComparaisonVariable::isBuilt (void) const {
  return aIndiceBDDgauche.isBuilt () &&
       aDimension.isBuilt () &&
       mLeftLowBound.isBuilt () &&
       mLeftHighBound.isBuilt () &&
       aComparaison.isBuilt () &&
       aIndiceBDDdroite.isBuilt () &&
       mRightLowBound.isBuilt () &&
       mRightHighBound.isBuilt () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            GALGAS class 'GGS_typeFormuleComparaisonVariable'              *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeFormuleComparaisonVariable * GGS_typeFormuleComparaisonVariable::
    constructor_new (const GGS_luint & argument_0,
                                const GGS_luint & argument_1,
                                const GGS_luint & argument_2,
                                const GGS_luint & argument_3,
                                const GGS_luint & argument_4,
                                const GGS_luint & argument_5,
                                const GGS_luint & argument_6,
                                const GGS_luint & argument_7) {
    cPtr_typeFormuleComparaisonVariable * ptr_ = (cPtr_typeFormuleComparaisonVariable *) NULL ;
    macroMyNew (ptr_, cPtr_typeFormuleComparaisonVariable (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6,
                                argument_7)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                     abstract class 'cPtr_typeCalcul'                      *
//                                                                           *
//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_typeCalcul'                        *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeCalcul::
GGS_typeCalcul (void) {
  mPointer = (cPtr_typeCalcul *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeCalcul::
GGS_typeCalcul (const GGS_typeCalcul & inOperand) {
  mPointer = (cPtr_typeCalcul *) NULL ;
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeCalcul::
~GGS_typeCalcul (void) {
  macroDetachPointer (mPointer, cPtr_typeCalcul) ;
}

//---------------------------------------------------------------------------*

void GGS_typeCalcul::
operator = (const GGS_typeCalcul & inOperand) {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

bool GGS_typeCalcul::isBuilt (void) const {
  bool result = false ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    result = mPointer->isBuilt () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeCalcul::
operator = (cPtr_typeCalcul * inSource) {
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

GGS_typeCalcul::
GGS_typeCalcul (cPtr_typeCalcul * inSource) {
  mPointer = (cPtr_typeCalcul *) NULL ;
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

cPtr_typeCalcul * GGS_typeCalcul
::operator () (void) const {
  macroValidPointer (mPointer) ;
  return mPointer ;
}

//---------------------------------------------------------------------------*

void GGS_typeCalcul
::drop_operation (void) {
  macroDetachPointer (mPointer, cPtr_typeCalcul) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'typeCalculSimple'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeCalculSimple::cPtr_typeCalculSimple (const GGS_luint & argument_0,
                                const GGS_typeFormule & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_typeTableVariablesBool & argument_3,
                                const GGS_luint & argument_4)
:aNumeroFormule (argument_0),
aFormule (argument_1),
aNomFormule (argument_2),
aTableVariablesBool (argument_3),
aAfficher (argument_4) {
}

//---------------------------------------------------------------------------*

bool cPtr_typeCalculSimple::isBuilt (void) const {
  return aNumeroFormule.isBuilt () &&
       aFormule.isBuilt () &&
       aNomFormule.isBuilt () &&
       aTableVariablesBool.isBuilt () &&
       aAfficher.isBuilt () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeCalculSimple'                     *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeCalculSimple * GGS_typeCalculSimple::
    constructor_new (const GGS_luint & argument_0,
                                const GGS_typeFormule & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_typeTableVariablesBool & argument_3,
                                const GGS_luint & argument_4) {
    cPtr_typeCalculSimple * ptr_ = (cPtr_typeCalculSimple *) NULL ;
    macroMyNew (ptr_, cPtr_typeCalculSimple (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                           class 'typeUse_AND'                             *
//                                                                           *
//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*

bool cPtr_typeUse_AND::isBuilt (void) const {
  return true ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_typeUse_AND'                       *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeUse_AND * GGS_typeUse_AND::
    constructor_new () {
    cPtr_typeUse_AND * ptr_ = (cPtr_typeUse_AND *) NULL ;
    macroMyNew (ptr_, cPtr_typeUse_AND ()) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                           class 'typeUse_ITE'                             *
//                                                                           *
//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*

bool cPtr_typeUse_ITE::isBuilt (void) const {
  return true ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_typeUse_ITE'                       *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeUse_ITE * GGS_typeUse_ITE::
    constructor_new () {
    cPtr_typeUse_ITE * ptr_ = (cPtr_typeUse_ITE *) NULL ;
    macroMyNew (ptr_, cPtr_typeUse_ITE ()) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'typeUse_AND_ITE'                           *
//                                                                           *
//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*

bool cPtr_typeUse_AND_ITE::isBuilt (void) const {
  return true ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeUse_AND_ITE'                     *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeUse_AND_ITE * GGS_typeUse_AND_ITE::
    constructor_new () {
    cPtr_typeUse_AND_ITE * ptr_ = (cPtr_typeUse_AND_ITE *) NULL ;
    macroMyNew (ptr_, cPtr_typeUse_AND_ITE ()) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'typeDimensionnerANDCache'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeDimensionnerANDCache::cPtr_typeDimensionnerANDCache (const GGS_luint & argument_0)
:aDimensionCache (argument_0) {
}

//---------------------------------------------------------------------------*

bool cPtr_typeDimensionnerANDCache::isBuilt (void) const {
  return aDimensionCache.isBuilt () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeDimensionnerANDCache'                 *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeDimensionnerANDCache * GGS_typeDimensionnerANDCache::
    constructor_new (const GGS_luint & argument_0) {
    cPtr_typeDimensionnerANDCache * ptr_ = (cPtr_typeDimensionnerANDCache *) NULL ;
    macroMyNew (ptr_, cPtr_typeDimensionnerANDCache (argument_0)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'typeDimensionnerITECache'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeDimensionnerITECache::cPtr_typeDimensionnerITECache (const GGS_luint & argument_0)
:aDimensionCache (argument_0) {
}

//---------------------------------------------------------------------------*

bool cPtr_typeDimensionnerITECache::isBuilt (void) const {
  return aDimensionCache.isBuilt () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeDimensionnerITECache'                 *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeDimensionnerITECache * GGS_typeDimensionnerITECache::
    constructor_new (const GGS_luint & argument_0) {
    cPtr_typeDimensionnerITECache * ptr_ = (cPtr_typeDimensionnerITECache *) NULL ;
    macroMyNew (ptr_, cPtr_typeDimensionnerITECache (argument_0)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'typeDimensionnerTable'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeDimensionnerTable::cPtr_typeDimensionnerTable (const GGS_luint & argument_0)
:aDimensionTable (argument_0) {
}

//---------------------------------------------------------------------------*

bool cPtr_typeDimensionnerTable::isBuilt (void) const {
  return aDimensionTable.isBuilt () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeDimensionnerTable'                  *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeDimensionnerTable * GGS_typeDimensionnerTable::
    constructor_new (const GGS_luint & argument_0) {
    cPtr_typeDimensionnerTable * ptr_ = (cPtr_typeDimensionnerTable *) NULL ;
    macroMyNew (ptr_, cPtr_typeDimensionnerTable (argument_0)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'typeAfficherBilan'                          *
//                                                                           *
//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*

bool cPtr_typeAfficherBilan::isBuilt (void) const {
  return true ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeAfficherBilan'                    *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeAfficherBilan * GGS_typeAfficherBilan::
    constructor_new () {
    cPtr_typeAfficherBilan * ptr_ = (cPtr_typeAfficherBilan *) NULL ;
    macroMyNew (ptr_, cPtr_typeAfficherBilan ()) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'typeCalculIteratif'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeCalculIteratif::cPtr_typeCalculIteratif (const GGS_luint & argument_0,
                                const GGS_typeFormule & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_typeTableVariablesBool & argument_3,
                                const GGS_lbool & argument_4,
                                const GGS_luint & argument_5)
:aNumeroFormule (argument_0),
aFormule (argument_1),
aNomFormule (argument_2),
aTableVariablesBool (argument_3),
aSigne (argument_4),
aAfficher (argument_5) {
}

//---------------------------------------------------------------------------*

bool cPtr_typeCalculIteratif::isBuilt (void) const {
  return aNumeroFormule.isBuilt () &&
       aFormule.isBuilt () &&
       aNomFormule.isBuilt () &&
       aTableVariablesBool.isBuilt () &&
       aSigne.isBuilt () &&
       aAfficher.isBuilt () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeCalculIteratif'                    *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeCalculIteratif * GGS_typeCalculIteratif::
    constructor_new (const GGS_luint & argument_0,
                                const GGS_typeFormule & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_typeTableVariablesBool & argument_3,
                                const GGS_lbool & argument_4,
                                const GGS_luint & argument_5) {
    cPtr_typeCalculIteratif * ptr_ = (cPtr_typeCalculIteratif *) NULL ;
    macroMyNew (ptr_, cPtr_typeCalculIteratif (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                 Class element of list 'typeListeCalculs'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeListeCalculs::element_type::
element_type (const GGS_typeCalcul & argument_0) {
  mNextItem = (element_type *) NULL ;
  aCalcul = argument_0 ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class list 'typeListeCalculs'                        *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeListeCalculs
::GGS_typeListeCalculs (void) { // Default Constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mCurrentItemPtr = (element_type *) NULL ;
  mCurrentItemIndex = 0 ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeListeCalculs::~GGS_typeListeCalculs (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*

GGS_typeListeCalculs::GGS_typeListeCalculs (const GGS_typeListeCalculs & source) { // Copy constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mCurrentItemPtr = (element_type *) NULL ;
  mCurrentItemIndex = 0 ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
  *this = source ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeCalculs
::operator = (const GGS_typeListeCalculs & source) { // Assignment operator
  if (this != & source) {
    emptyList () ;
    mFirstItem = source.mFirstItem ;
    mLastItem = source.mLastItem ;
    mCurrentItemPtr = (element_type *) NULL ;
    mCurrentItemIndex = 0 ;
    mListLength = source.mListLength ;
    mCountReference = source.mCountReference ;
    if (mCountReference != NULL) {
      macroValidPointer (mCountReference) ;
      (*mCountReference) ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeCalculs
::emptyList (void) {
  mCurrentItemPtr = (element_type *) NULL ;
  mCurrentItemIndex = 0 ;
  mListLength = 0 ;
  mLastItem = (element_type *) NULL ;
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) == 1) {
      macroMyDelete (mCountReference, sint32) ;
      while (mFirstItem != NULL) {
        macroValidPointer (mFirstItem) ;
        mLastItem = mFirstItem->mNextItem ;
        macroMyDelete (mFirstItem, element_type) ;
        mFirstItem = mLastItem ;
      }
    }else{
      mFirstItem = (element_type *) NULL ;
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeCalculs::
internalAppendItem (const GGS_typeCalcul & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mLastItem == NULL) {
      mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mLastItem) ;
      mLastItem->mNextItem = nouvelElement ;
    }
    mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeCalculs::
addAssign_operation (const GGS_typeCalcul & argument_0) {
  if (isBuilt ()
                 && argument_0.isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeCalculs
::insulateList (void) {
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) > 1) {
      element_type * p = mFirstItem ;
      mFirstItem = (element_type *)  NULL ;
      mLastItem = (element_type *)  NULL ;
      mListLength = 0 ;
      mCurrentItemPtr = (element_type *) NULL ;
      mCurrentItemIndex = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->aCalcul) ;
        p = p->mNextItem ;
      }
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
      macroMyNew (mCountReference, sint32 (1)) ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeListeCalculs  GGS_typeListeCalculs::
constructor_empty (void) {
  GGS_typeListeCalculs result ;
  macroMyNew (result.mCountReference, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeCalculs
::drop_operation (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//         Implementation of routine "verifierNombreArgumentsBool"           *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_verifierNombreArgumentsBool (C_Lexique & lexique_var_,
                                const GGS_typeFormalArgumentsList  & var_cas_t1,
                                const GGS_typeActualArgumentsList  & var_cas_t2,
                                const GGS_location  & var_cas_positionFinListe) {
  if (((var_cas_t1.reader_length ()) < (var_cas_t2.reader_length ())).isBuiltAndTrue ()) {
      var_cas_positionFinListe.reader_location ().signalGGSSemanticError (lexique_var_, GGS_string (true, "too much actual arguments")) ;
  }else if (((var_cas_t1.reader_length ()) > (var_cas_t2.reader_length ())).isBuiltAndTrue ()) {
      var_cas_positionFinListe.reader_location ().signalGGSSemanticError (lexique_var_, GGS_string (true, "one or more actual arguments missing")) ;
  }
  GGS_typeFormalArgumentsList::element_type * operand_8253 = var_cas_t1.getFirstItem () ;
  GGS_typeActualArgumentsList::element_type * operand_8333 = var_cas_t2.getFirstItem () ;
  while ((operand_8253 != NULL) && (operand_8333 != NULL)) {
    macroValidPointer (operand_8253) ;
    macroValidPointer (operand_8333) ;
    if (((operand_8253->mVariableBitSize.reader_value ()) == (operand_8333->mVariableBitSize.reader_value ())).isBuiltAndTrue ()) {
      if (((operand_8253->mLowBound.reader_value ()) == (operand_8333->mLowBound.reader_value ())).isBuiltAndTrue ()) {
        if (((operand_8253->mHighBound.reader_value ()) == (operand_8333->mHighBound.reader_value ())).isBuiltAndTrue ()) {
        }else{
            operand_8333->mErrorLocation.reader_location ().signalGGSSemanticError (lexique_var_, GGS_string (true, "the actual high bound is different the formal one")) ;
        }
      }else{
          operand_8333->mErrorLocation.reader_location ().signalGGSSemanticError (lexique_var_, GGS_string (true, "the actual low bound is different the formal one")) ;
      }
    }else{
        operand_8333->mErrorLocation.reader_location ().signalGGSSemanticError (lexique_var_, GGS_string (true, "the actual dimension is different from the formal one")) ;
    }
    operand_8253 = operand_8253->getNextItem () ;
    operand_8333 = operand_8333->getNextItem () ;
  }
}

//---------------------------------------------------------------------------*

