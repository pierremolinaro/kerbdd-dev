//---------------------------------------------------------------------------*
//                                                                           *
//                         File 'semantiqueBDD.cpp'                          *
//         Generated by version GALGAS_BETA_VERSION (LL(1) grammar)          *
//                       may 28th, 2007, at 14h20'31"                        *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

//---------------------------------------------------------------------------*

#include "version_libpm.h"
#if LIBPM_VERSION != THE_LIBPM_VERSION
  #error "This file has been compiled with a version of GALGAS different than the version of libpm"
#endif

//---------------------------------------------------------------------------*

#include <typeinfo>
#include "utilities/MF_MemoryControl.h"
#include "files/C_TextFileWrite.h"
#include "semantiqueBDD.h"

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  #define SOURCE_FILE_AT_LINE(line) "semantiqueBDD.ggs", line
  #define COMMA_SOURCE_FILE_AT_LINE(line) , SOURCE_FILE_AT_LINE(line)
#else
  #define SOURCE_FILE_AT_LINE(line) 
  #define COMMA_SOURCE_FILE_AT_LINE(line) 
#endif


//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//                     abstract class 'cPtr_typeDomain'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeDomain::
cPtr_typeDomain (LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeDomain * GGS_typeDomain::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeDomain *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeDomain *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_typeDomain::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeDomain:" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeDomain::
static_string_message_messageDomainType (void) {
  return "any domain" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeDomain::
message_messageDomainType (void) const {
  return "any domain" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeDomain::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeDomain::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeDomain (& typeid (cPtr_typeDomain), NULL
, "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_typeDomain'                        *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeDomain::
GGS_typeDomain (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeDomain GGS_typeDomain::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeDomain _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeDomain *> (inPointer) != NULL)
      : (typeid (cPtr_typeDomain) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeDomain (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeDomain),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeDomain::
reader_messageDomainType (C_Compiler & /* _inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeDomain *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    cPtr_typeDomain * p = (cPtr_typeDomain *) mPointer ;
    result = GGS_string (true, p->message_messageDomainType ()) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeDomain::actualTypeName (void) const {
  return "typeDomain" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  abstract class 'cPtr_typeDirectDomain'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeDirectDomain::
cPtr_typeDirectDomain (const GGS_luint & argument_0,
                                const GGS_luint & argument_1,
                                const GGS_luint & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeDomain (THERE),
mLowBound (argument_0),
mHighBound (argument_1),
mBitsCount (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeDirectDomain * GGS_typeDirectDomain::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeDirectDomain *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeDirectDomain *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeDirectDomain::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeDirectDomain * _p = dynamic_cast <const cPtr_typeDirectDomain *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mLowBound._operator_isEqual (_p->mLowBound).boolValue ()
         && mHighBound._operator_isEqual (_p->mHighBound).boolValue ()
         && mBitsCount._operator_isEqual (_p->mBitsCount).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeDirectDomain::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeDirectDomain:"
           << mLowBound.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mHighBound.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mBitsCount.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeDirectDomain::
static_string_message_messageDomainType (void) {
  return "an interval domain" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeDirectDomain::
message_messageDomainType (void) const {
  return "an interval domain" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeDirectDomain::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeDirectDomain::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeDirectDomain (& typeid (cPtr_typeDirectDomain), & typeid (cPtr_typeDomain), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeDirectDomain'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeDirectDomain::
GGS_typeDirectDomain (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeDirectDomain GGS_typeDirectDomain::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeDirectDomain _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeDirectDomain *> (inPointer) != NULL)
      : (typeid (cPtr_typeDirectDomain) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeDirectDomain (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeDirectDomain),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_typeDirectDomain GGS_typeDirectDomain::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_luint & argument_0,
                 const GGS_luint & argument_1,
                 const GGS_luint & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeDirectDomain result ;
  macroMyNew (result.mPointer, cPtr_typeDirectDomain (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeDirectDomain::
reader_messageDomainType (C_Compiler & /* _inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeDirectDomain *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    cPtr_typeDirectDomain * p = (cPtr_typeDirectDomain *) mPointer ;
    result = GGS_string (true, p->message_messageDomainType ()) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_typeDirectDomain::
reader_mLowBound (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeDirectDomain *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeDirectDomain *) mPointer)->mLowBound ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_typeDirectDomain::
reader_mHighBound (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeDirectDomain *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeDirectDomain *) mPointer)->mHighBound ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_typeDirectDomain::
reader_mBitsCount (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeDirectDomain *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeDirectDomain *) mPointer)->mBitsCount ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeDirectDomain::actualTypeName (void) const {
  return "typeDirectDomain" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class map '@typeDomainMap'                         *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeDomainMap::
elementOf_GGS_typeDomainMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_typeDomainMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeDomainMap::
appendForMapDescription (C_Compiler & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mDomain.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_typeDomainMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_typeDomainMap * _p = dynamic_cast <const elementOf_GGS_typeDomainMap *> (inOperand) ;
  macroValidPointer (_p) ;
  return (mInfo.mDomain._operator_isEqual (_p->mInfo.mDomain)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_typeDomainMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_typeDomainMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_typeDomainMap * info = (e_typeDomainMap *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_typeDomainMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_typeDomainMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  e_typeDomainMap * info = (e_typeDomainMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_typeDomainMap GGS_typeDomainMap::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeDomainMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeDomainMap::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_typeDomainMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      mSharedMapRoot->rootForKey (inKey),
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeDomainMap::
_operator_isEqual (const GGS_typeDomainMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeDomainMap::
_operator_isNotEqual (const GGS_typeDomainMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_typeDomainMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->rootForKey (inPtr->mKey), attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_typeDomainMap::
_insertElement (C_Compiler & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_typeDomain & inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementID = - 1 ;
  if (_isBuilt ()
   && inParameter0._isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_typeDomainMap info  ;
    info.mDomain = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->rootForKey (inKey), elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (uint32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeDomainMap::
_searchElement (C_Compiler & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_typeDomain   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0._drop_operation () ;
    if (outIndex != NULL) {
      outIndex->_drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mDomain ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeDomainMap::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_typeDomain   & outParameter0 COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "the '%K' domain is not declared",
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeDomainMap::
modifier_insertKey (C_Compiler & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_typeDomain & inParameter0 COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "the '%K' domain has been already declared",
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_typeDomainMap GGS_typeDomainMap::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_typeDomainMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeDomainMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeDomainMap GGS_typeDomainMap::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeDomainMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeDomainMap::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @typeDomainMap " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    sint32 elementID = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementID, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementID ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  abstract class 'cPtr_typeRecordDomain'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeRecordDomain::
cPtr_typeRecordDomain (const GGS_typeDomainMap & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_typeDomain (THERE),
mRecordMap (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeRecordDomain * GGS_typeRecordDomain::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeRecordDomain *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeRecordDomain *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeRecordDomain::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeRecordDomain * _p = dynamic_cast <const cPtr_typeRecordDomain *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mRecordMap._operator_isEqual (_p->mRecordMap).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeRecordDomain::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeRecordDomain:"
           << mRecordMap.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeRecordDomain::
static_string_message_messageDomainType (void) {
  return "a record domain" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeRecordDomain::
message_messageDomainType (void) const {
  return "a record domain" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeRecordDomain::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeRecordDomain::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeRecordDomain (& typeid (cPtr_typeRecordDomain), & typeid (cPtr_typeDomain), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeRecordDomain'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeRecordDomain::
GGS_typeRecordDomain (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeRecordDomain GGS_typeRecordDomain::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeRecordDomain _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeRecordDomain *> (inPointer) != NULL)
      : (typeid (cPtr_typeRecordDomain) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeRecordDomain (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeRecordDomain),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_typeRecordDomain GGS_typeRecordDomain::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_typeDomainMap & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_typeRecordDomain result ;
  macroMyNew (result.mPointer, cPtr_typeRecordDomain (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeRecordDomain::
reader_messageDomainType (C_Compiler & /* _inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeRecordDomain *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    cPtr_typeRecordDomain * p = (cPtr_typeRecordDomain *) mPointer ;
    result = GGS_string (true, p->message_messageDomainType ()) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeDomainMap  GGS_typeRecordDomain::
reader_mRecordMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeDomainMap   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeRecordDomain *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeRecordDomain *) mPointer)->mRecordMap ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeRecordDomain::actualTypeName (void) const {
  return "typeRecordDomain" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@typeFormalArgumentsList'                 *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeFormalArgumentsList::
elementOf_GGS_typeFormalArgumentsList (const GGS_luint & argument_0,
                                const GGS_luint & argument_1,
                                const GGS_luint & argument_2,
                                const GGS_luint & argument_3
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mVariableIndex (argument_0),
mVariableBitSize (argument_1),
mLowBound (argument_2),
mHighBound (argument_3) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_typeFormalArgumentsList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_typeFormalArgumentsList * _p = dynamic_cast <const elementOf_GGS_typeFormalArgumentsList *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mVariableIndex._operator_isEqual (_p->mVariableIndex).boolValue ()
         && mVariableBitSize._operator_isEqual (_p->mVariableBitSize).boolValue ()
         && mLowBound._operator_isEqual (_p->mLowBound).boolValue ()
         && mHighBound._operator_isEqual (_p->mHighBound).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeFormalArgumentsList::
appendForDescription (C_Compiler & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mVariableIndex.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mVariableBitSize.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLowBound.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mHighBound.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     List '@typeFormalArgumentsList'                       *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_typeFormalArgumentsList::
_internalAppendValues (const GGS_luint & argument_0,
                    const GGS_luint & argument_1,
                    const GGS_luint & argument_2,
                    const GGS_luint & argument_3
                    COMMA_LOCATION_ARGS) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeFormalArgumentsList::
_internalPrependValues (const GGS_luint & argument_0,
                    const GGS_luint & argument_1,
                    const GGS_luint & argument_2,
                    const GGS_luint & argument_3
                    COMMA_LOCATION_ARGS) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeFormalArgumentsList::
_addAssign_operation (const GGS_luint & argument_0,
                                const GGS_luint & argument_1,
                                const GGS_luint & argument_2,
                                const GGS_luint & argument_3) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_typeFormalArgumentsList GGS_typeFormalArgumentsList::
_operator_concat (const GGS_typeFormalArgumentsList & inOperand) const {
  GGS_typeFormalArgumentsList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        elementOf_GGS_typeFormalArgumentsList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_luint  p_0 = p->mVariableIndex ;
          GGS_luint  p_1 = p->mVariableBitSize ;
          GGS_luint  p_2 = p->mLowBound ;
          GGS_luint  p_3 = p->mHighBound ;
          result._internalAppendValues (p_0, p_1, p_2, p_3 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeFormalArgumentsList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_luint & argument_0,
                     const GGS_luint & argument_1,
                     const GGS_luint & argument_2,
                     const GGS_luint & argument_3
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeFormalArgumentsList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mVariableIndex,
                                _p->mVariableBitSize,
                                _p->mLowBound,
                                _p->mHighBound
                                COMMA_HERE) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeFormalArgumentsList  GGS_typeFormalArgumentsList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeFormalArgumentsList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeFormalArgumentsList  GGS_typeFormalArgumentsList::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_luint & argument_0,
                           const GGS_luint & argument_1,
                           const GGS_luint & argument_2,
                           const GGS_luint & argument_3
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeFormalArgumentsList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1, argument_2, argument_3) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeFormalArgumentsList::
internalSubListWithRange (GGS_typeFormalArgumentsList & ioList,
                          const sint32 inFirstIndex,
                          const sint32 inCount) const {
  ioList._alloc () ;
  if (inCount > 0) {
    element_type * _p = firstObject () ;
    for (sint32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (_p) ;
      _p = _p->nextObject () ;
    }
    for (sint32 i=0 ; i<inCount ; i++) {
      macroValidPointer (_p) ;
      ioList._addAssign_operation (_p->mVariableIndex, _p->mVariableBitSize, _p->mLowBound, _p->mHighBound) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeFormalArgumentsList GGS_typeFormalArgumentsList::
reader_subListWithRange (C_Compiler & _inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_typeFormalArgumentsList result ;
  if (_isBuilt () && inFirstIndex._isBuilt () && inCount._isBuilt ()) {
    const sint32 firstIndex = (sint32) inFirstIndex.uintValue () ;
    const sint32 rangeCount = (sint32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeFormalArgumentsList GGS_typeFormalArgumentsList::
reader_subListFromIndex (C_Compiler & _inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_typeFormalArgumentsList result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    const sint32 startIndex = (sint32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeFormalArgumentsList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@typeFormalArgumentsList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeFormalArgumentsList::
method_first (C_Compiler & _inLexique,
              GGS_luint & _out_0,
              GGS_luint & _out_1,
              GGS_luint & _out_2,
              GGS_luint & _out_3
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mVariableIndex ;
    _out_1 = _p->mVariableBitSize ;
    _out_2 = _p->mLowBound ;
    _out_3 = _p->mHighBound ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
    _out_3._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeFormalArgumentsList::
method_last (C_Compiler & _inLexique,
             GGS_luint & _out_0,
             GGS_luint & _out_1,
             GGS_luint & _out_2,
             GGS_luint & _out_3
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mVariableIndex ;
    _out_1 = _p->mVariableBitSize ;
    _out_2 = _p->mLowBound ;
    _out_3 = _p->mHighBound ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
    _out_3._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeFormalArgumentsList::
modifier_popFirst (C_Compiler & _inLexique,
                 GGS_luint & _out_0,
                 GGS_luint & _out_1,
                 GGS_luint & _out_2,
                 GGS_luint & _out_3
                 COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mVariableIndex ;
    _out_1 = _p->mVariableBitSize ;
    _out_2 = _p->mLowBound ;
    _out_3 = _p->mHighBound ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
    _out_3._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeFormalArgumentsList::
modifier_popLast (C_Compiler & _inLexique,
                GGS_luint & _out_0,
                GGS_luint & _out_1,
                GGS_luint & _out_2,
                GGS_luint & _out_3
                COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mVariableIndex ;
    _out_1 = _p->mVariableBitSize ;
    _out_2 = _p->mLowBound ;
    _out_3 = _p->mHighBound ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
    _out_3._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@typeActualArgumentsList'                 *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeActualArgumentsList::
elementOf_GGS_typeActualArgumentsList (const GGS_luint & argument_0,
                                const GGS_luint & argument_1,
                                const GGS_luint & argument_2,
                                const GGS_luint & argument_3,
                                const GGS_location & argument_4
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mVariableIndex (argument_0),
mVariableBitSize (argument_1),
mLowBound (argument_2),
mHighBound (argument_3),
mErrorLocation (argument_4) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_typeActualArgumentsList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_typeActualArgumentsList * _p = dynamic_cast <const elementOf_GGS_typeActualArgumentsList *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mVariableIndex._operator_isEqual (_p->mVariableIndex).boolValue ()
         && mVariableBitSize._operator_isEqual (_p->mVariableBitSize).boolValue ()
         && mLowBound._operator_isEqual (_p->mLowBound).boolValue ()
         && mHighBound._operator_isEqual (_p->mHighBound).boolValue ()
         && mErrorLocation._operator_isEqual (_p->mErrorLocation).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeActualArgumentsList::
appendForDescription (C_Compiler & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mVariableIndex.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mVariableBitSize.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLowBound.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mHighBound.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mErrorLocation.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     List '@typeActualArgumentsList'                       *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_typeActualArgumentsList::
_internalAppendValues (const GGS_luint & argument_0,
                    const GGS_luint & argument_1,
                    const GGS_luint & argument_2,
                    const GGS_luint & argument_3,
                    const GGS_location & argument_4
                    COMMA_LOCATION_ARGS) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeActualArgumentsList::
_internalPrependValues (const GGS_luint & argument_0,
                    const GGS_luint & argument_1,
                    const GGS_luint & argument_2,
                    const GGS_luint & argument_3,
                    const GGS_location & argument_4
                    COMMA_LOCATION_ARGS) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeActualArgumentsList::
_addAssign_operation (const GGS_luint & argument_0,
                                const GGS_luint & argument_1,
                                const GGS_luint & argument_2,
                                const GGS_luint & argument_3,
                                const GGS_location & argument_4) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_typeActualArgumentsList GGS_typeActualArgumentsList::
_operator_concat (const GGS_typeActualArgumentsList & inOperand) const {
  GGS_typeActualArgumentsList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        elementOf_GGS_typeActualArgumentsList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_luint  p_0 = p->mVariableIndex ;
          GGS_luint  p_1 = p->mVariableBitSize ;
          GGS_luint  p_2 = p->mLowBound ;
          GGS_luint  p_3 = p->mHighBound ;
          GGS_location  p_4 = p->mErrorLocation ;
          result._internalAppendValues (p_0, p_1, p_2, p_3, p_4 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeActualArgumentsList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_luint & argument_0,
                     const GGS_luint & argument_1,
                     const GGS_luint & argument_2,
                     const GGS_luint & argument_3,
                     const GGS_location & argument_4
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeActualArgumentsList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mVariableIndex,
                                _p->mVariableBitSize,
                                _p->mLowBound,
                                _p->mHighBound,
                                _p->mErrorLocation
                                COMMA_HERE) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeActualArgumentsList  GGS_typeActualArgumentsList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeActualArgumentsList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeActualArgumentsList  GGS_typeActualArgumentsList::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_luint & argument_0,
                           const GGS_luint & argument_1,
                           const GGS_luint & argument_2,
                           const GGS_luint & argument_3,
                           const GGS_location & argument_4
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeActualArgumentsList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1, argument_2, argument_3, argument_4) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeActualArgumentsList::
internalSubListWithRange (GGS_typeActualArgumentsList & ioList,
                          const sint32 inFirstIndex,
                          const sint32 inCount) const {
  ioList._alloc () ;
  if (inCount > 0) {
    element_type * _p = firstObject () ;
    for (sint32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (_p) ;
      _p = _p->nextObject () ;
    }
    for (sint32 i=0 ; i<inCount ; i++) {
      macroValidPointer (_p) ;
      ioList._addAssign_operation (_p->mVariableIndex, _p->mVariableBitSize, _p->mLowBound, _p->mHighBound, _p->mErrorLocation) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeActualArgumentsList GGS_typeActualArgumentsList::
reader_subListWithRange (C_Compiler & _inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_typeActualArgumentsList result ;
  if (_isBuilt () && inFirstIndex._isBuilt () && inCount._isBuilt ()) {
    const sint32 firstIndex = (sint32) inFirstIndex.uintValue () ;
    const sint32 rangeCount = (sint32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeActualArgumentsList GGS_typeActualArgumentsList::
reader_subListFromIndex (C_Compiler & _inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_typeActualArgumentsList result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    const sint32 startIndex = (sint32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeActualArgumentsList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@typeActualArgumentsList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeActualArgumentsList::
method_first (C_Compiler & _inLexique,
              GGS_luint & _out_0,
              GGS_luint & _out_1,
              GGS_luint & _out_2,
              GGS_luint & _out_3,
              GGS_location & _out_4
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mVariableIndex ;
    _out_1 = _p->mVariableBitSize ;
    _out_2 = _p->mLowBound ;
    _out_3 = _p->mHighBound ;
    _out_4 = _p->mErrorLocation ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
    _out_3._drop_operation () ;
    _out_4._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeActualArgumentsList::
method_last (C_Compiler & _inLexique,
             GGS_luint & _out_0,
             GGS_luint & _out_1,
             GGS_luint & _out_2,
             GGS_luint & _out_3,
             GGS_location & _out_4
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mVariableIndex ;
    _out_1 = _p->mVariableBitSize ;
    _out_2 = _p->mLowBound ;
    _out_3 = _p->mHighBound ;
    _out_4 = _p->mErrorLocation ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
    _out_3._drop_operation () ;
    _out_4._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeActualArgumentsList::
modifier_popFirst (C_Compiler & _inLexique,
                 GGS_luint & _out_0,
                 GGS_luint & _out_1,
                 GGS_luint & _out_2,
                 GGS_luint & _out_3,
                 GGS_location & _out_4
                 COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mVariableIndex ;
    _out_1 = _p->mVariableBitSize ;
    _out_2 = _p->mLowBound ;
    _out_3 = _p->mHighBound ;
    _out_4 = _p->mErrorLocation ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
    _out_3._drop_operation () ;
    _out_4._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeActualArgumentsList::
modifier_popLast (C_Compiler & _inLexique,
                GGS_luint & _out_0,
                GGS_luint & _out_1,
                GGS_luint & _out_2,
                GGS_luint & _out_3,
                GGS_location & _out_4
                COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mVariableIndex ;
    _out_1 = _p->mVariableBitSize ;
    _out_2 = _p->mLowBound ;
    _out_3 = _p->mHighBound ;
    _out_4 = _p->mErrorLocation ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
    _out_3._drop_operation () ;
    _out_4._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//               abstract class 'cPtr_typeVariableDescriptor'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeVariableDescriptor::
cPtr_typeVariableDescriptor (LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeVariableDescriptor * GGS_typeVariableDescriptor::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeVariableDescriptor *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeVariableDescriptor *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_typeVariableDescriptor::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeVariableDescriptor:" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeVariableDescriptor::
static_string_message_variableDescriptorErrorMessage (void) {
  return "any variable" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeVariableDescriptor::
message_variableDescriptorErrorMessage (void) const {
  return "any variable" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeVariableDescriptor::
_message (void) const {
  return "any variable" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeVariableDescriptor::
_static_message (void) {
  return "any variable" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeVariableDescriptor (& typeid (cPtr_typeVariableDescriptor), NULL
, "any variable") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_typeVariableDescriptor'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeVariableDescriptor::
GGS_typeVariableDescriptor (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeVariableDescriptor GGS_typeVariableDescriptor::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeVariableDescriptor _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeVariableDescriptor *> (inPointer) != NULL)
      : (typeid (cPtr_typeVariableDescriptor) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeVariableDescriptor (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeVariableDescriptor),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeVariableDescriptor::
reader_variableDescriptorErrorMessage (C_Compiler & /* _inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeVariableDescriptor *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    cPtr_typeVariableDescriptor * p = (cPtr_typeVariableDescriptor *) mPointer ;
    result = GGS_string (true, p->message_variableDescriptorErrorMessage ()) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeVariableDescriptor::actualTypeName (void) const {
  return "typeVariableDescriptor" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 abstract class 'cPtr_typeDirectVariable'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeDirectVariable::
cPtr_typeDirectVariable (const GGS_luint & argument_0,
                                const GGS_luint & argument_1,
                                const GGS_luint & argument_2,
                                const GGS_luint & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_typeVariableDescriptor (THERE),
mIndex (argument_0),
mBitSize (argument_1),
mLowBound (argument_2),
mHighBound (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeDirectVariable * GGS_typeDirectVariable::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeDirectVariable *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeDirectVariable *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeDirectVariable::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeDirectVariable * _p = dynamic_cast <const cPtr_typeDirectVariable *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mIndex._operator_isEqual (_p->mIndex).boolValue ()
         && mBitSize._operator_isEqual (_p->mBitSize).boolValue ()
         && mLowBound._operator_isEqual (_p->mLowBound).boolValue ()
         && mHighBound._operator_isEqual (_p->mHighBound).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeDirectVariable::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeDirectVariable:"
           << mIndex.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mBitSize.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mLowBound.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mHighBound.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeDirectVariable::
static_string_message_variableDescriptorErrorMessage (void) {
  return "a direct domain variable" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeDirectVariable::
message_variableDescriptorErrorMessage (void) const {
  return "a direct domain variable" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeDirectVariable::
_message (void) const {
  return "a direct domain variable" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeDirectVariable::
_static_message (void) {
  return "a direct domain variable" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeDirectVariable (& typeid (cPtr_typeDirectVariable), & typeid (cPtr_typeVariableDescriptor), "a direct domain variable") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeDirectVariable'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeDirectVariable::
GGS_typeDirectVariable (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeDirectVariable GGS_typeDirectVariable::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeDirectVariable _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeDirectVariable *> (inPointer) != NULL)
      : (typeid (cPtr_typeDirectVariable) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeDirectVariable (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeDirectVariable),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_typeDirectVariable GGS_typeDirectVariable::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_luint & argument_0,
                 const GGS_luint & argument_1,
                 const GGS_luint & argument_2,
                 const GGS_luint & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_typeDirectVariable result ;
  macroMyNew (result.mPointer, cPtr_typeDirectVariable (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeDirectVariable::
reader_variableDescriptorErrorMessage (C_Compiler & /* _inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeDirectVariable *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    cPtr_typeDirectVariable * p = (cPtr_typeDirectVariable *) mPointer ;
    result = GGS_string (true, p->message_variableDescriptorErrorMessage ()) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_typeDirectVariable::
reader_mIndex (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeDirectVariable *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeDirectVariable *) mPointer)->mIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_typeDirectVariable::
reader_mBitSize (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeDirectVariable *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeDirectVariable *) mPointer)->mBitSize ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_typeDirectVariable::
reader_mLowBound (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeDirectVariable *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeDirectVariable *) mPointer)->mLowBound ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_typeDirectVariable::
reader_mHighBound (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeDirectVariable *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeDirectVariable *) mPointer)->mHighBound ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeDirectVariable::actualTypeName (void) const {
  return "typeDirectVariable" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class map '@typeTableVariablesBool'                     *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeTableVariablesBool::
elementOf_GGS_typeTableVariablesBool (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_typeTableVariablesBool & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeTableVariablesBool::
appendForMapDescription (C_Compiler & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mVariableDescriptor.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_typeTableVariablesBool::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_typeTableVariablesBool * _p = dynamic_cast <const elementOf_GGS_typeTableVariablesBool *> (inOperand) ;
  macroValidPointer (_p) ;
  return (mInfo.mVariableDescriptor._operator_isEqual (_p->mInfo.mVariableDescriptor)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_typeTableVariablesBool::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_typeTableVariablesBool *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_typeTableVariablesBool * info = (e_typeTableVariablesBool *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableVariablesBool::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_typeTableVariablesBool *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  e_typeTableVariablesBool * info = (e_typeTableVariablesBool *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_typeTableVariablesBool GGS_typeTableVariablesBool::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeTableVariablesBool result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableVariablesBool::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_typeTableVariablesBool info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      mSharedMapRoot->rootForKey (inKey),
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeTableVariablesBool::
_operator_isEqual (const GGS_typeTableVariablesBool & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeTableVariablesBool::
_operator_isNotEqual (const GGS_typeTableVariablesBool & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableVariablesBool::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->rootForKey (inPtr->mKey), attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableVariablesBool::
_insertElement (C_Compiler & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_typeVariableDescriptor & inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementID = - 1 ;
  if (_isBuilt ()
   && inParameter0._isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_typeTableVariablesBool info  ;
    info.mVariableDescriptor = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->rootForKey (inKey), elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (uint32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTableVariablesBool::
_searchElement (C_Compiler & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_typeVariableDescriptor   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0._drop_operation () ;
    if (outIndex != NULL) {
      outIndex->_drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mVariableDescriptor ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTableVariablesBool::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_typeVariableDescriptor   & outParameter0 COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "the '%K' variable is not declared",
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableVariablesBool::
modifier_insertKey (C_Compiler & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_typeVariableDescriptor & inParameter0 COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "the '%K' variable has been already declared",
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_typeTableVariablesBool GGS_typeTableVariablesBool::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_typeTableVariablesBool & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeTableVariablesBool result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeTableVariablesBool GGS_typeTableVariablesBool::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeTableVariablesBool result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeTableVariablesBool::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @typeTableVariablesBool " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    sint32 elementID = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementID, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementID ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 abstract class 'cPtr_typeRecordVariable'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeRecordVariable::
cPtr_typeRecordVariable (const GGS_typeTableVariablesBool & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_typeVariableDescriptor (THERE),
mMap (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeRecordVariable * GGS_typeRecordVariable::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeRecordVariable *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeRecordVariable *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeRecordVariable::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeRecordVariable * _p = dynamic_cast <const cPtr_typeRecordVariable *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mMap._operator_isEqual (_p->mMap).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeRecordVariable::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeRecordVariable:"
           << mMap.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeRecordVariable::
static_string_message_variableDescriptorErrorMessage (void) {
  return "a record domain variable" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeRecordVariable::
message_variableDescriptorErrorMessage (void) const {
  return "a record domain variable" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeRecordVariable::
_message (void) const {
  return "a record domain variable" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeRecordVariable::
_static_message (void) {
  return "a record domain variable" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeRecordVariable (& typeid (cPtr_typeRecordVariable), & typeid (cPtr_typeVariableDescriptor), "a record domain variable") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeRecordVariable'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeRecordVariable::
GGS_typeRecordVariable (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeRecordVariable GGS_typeRecordVariable::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeRecordVariable _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeRecordVariable *> (inPointer) != NULL)
      : (typeid (cPtr_typeRecordVariable) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeRecordVariable (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeRecordVariable),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_typeRecordVariable GGS_typeRecordVariable::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_typeTableVariablesBool & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_typeRecordVariable result ;
  macroMyNew (result.mPointer, cPtr_typeRecordVariable (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeRecordVariable::
reader_variableDescriptorErrorMessage (C_Compiler & /* _inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeRecordVariable *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    cPtr_typeRecordVariable * p = (cPtr_typeRecordVariable *) mPointer ;
    result = GGS_string (true, p->message_variableDescriptorErrorMessage ()) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeTableVariablesBool  GGS_typeRecordVariable::
reader_mMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeTableVariablesBool   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeRecordVariable *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeRecordVariable *) mPointer)->mMap ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeRecordVariable::actualTypeName (void) const {
  return "typeRecordVariable" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class map '@typeTableFormules'                       *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeTableFormules::
elementOf_GGS_typeTableFormules (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_typeTableFormules & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeTableFormules::
appendForMapDescription (C_Compiler & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.aListeArgsFormelsBool.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.aBDD.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_typeTableFormules::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_typeTableFormules * _p = dynamic_cast <const elementOf_GGS_typeTableFormules *> (inOperand) ;
  macroValidPointer (_p) ;
  return (mInfo.aListeArgsFormelsBool._operator_isEqual (_p->mInfo.aListeArgsFormelsBool)).boolValue ()
           && (mInfo.aBDD._operator_isEqual (_p->mInfo.aBDD)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_typeTableFormules::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_typeTableFormules *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_typeTableFormules * info = (e_typeTableFormules *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableFormules::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_typeTableFormules *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  e_typeTableFormules * info = (e_typeTableFormules *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_typeTableFormules GGS_typeTableFormules::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeTableFormules result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableFormules::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_typeTableFormules info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      mSharedMapRoot->rootForKey (inKey),
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeTableFormules::
_operator_isEqual (const GGS_typeTableFormules & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeTableFormules::
_operator_isNotEqual (const GGS_typeTableFormules & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableFormules::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->rootForKey (inPtr->mKey), attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableFormules::
_insertElement (C_Compiler & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_typeFormalArgumentsList & inParameter0,
                const GGS_extern_bdd& inParameter1,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementID = - 1 ;
  if (_isBuilt ()
   && inParameter0._isBuilt ()
   && inParameter1._isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_typeTableFormules info  ;
    info.aListeArgsFormelsBool = inParameter0 ;
    info.aBDD = inParameter1 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->rootForKey (inKey), elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (uint32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTableFormules::
_searchElement (C_Compiler & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_typeFormalArgumentsList   & outParameter0,
               GGS_extern_bdd  & outParameter1,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0._drop_operation () ;
    outParameter1._drop_operation () ;
    if (outIndex != NULL) {
      outIndex->_drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.aListeArgsFormelsBool ;
    outParameter1 = node->mInfo.aBDD ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTableFormules::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_typeFormalArgumentsList   & outParameter0,
                                GGS_extern_bdd  & outParameter1 COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "the '#%K' formula is not defined",
                  inKey,
                  outParameter0,
                  outParameter1,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableFormules::
method_searchKeyGetIndex (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                GGS_typeFormalArgumentsList   & outParameter0,
                                GGS_extern_bdd  & outParameter1 COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "the '#%K' formula is not defined",
                  inKey,
                  outParameter0,
                  outParameter1,
                  & outIndex
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableFormules::
modifier_insertKey (C_Compiler & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_typeFormalArgumentsList & inParameter0,
                                const GGS_extern_bdd& inParameter1 COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "the '#%K' formula is already defined",
                 inKey,
                 inParameter0,
                 inParameter1,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableFormules::
modifier_insertKeyGetIndex (C_Compiler & _inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_typeFormalArgumentsList & inParameter0,
                                const GGS_extern_bdd& inParameter1 COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "the '#%K' formula is already defined",
                 inKey,
                 inParameter0,
                 inParameter1,
                 & outIndex
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_typeTableFormules GGS_typeTableFormules::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_typeTableFormules & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeTableFormules result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeTableFormules GGS_typeTableFormules::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeTableFormules result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeTableFormules::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @typeTableFormules " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    sint32 elementID = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementID, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementID ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    abstract class 'cPtr_typeFormule'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeFormule::
cPtr_typeFormule (LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeFormule * GGS_typeFormule::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFormule *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeFormule *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_typeFormule::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeFormule:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeFormule::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeFormule::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeFormule (& typeid (cPtr_typeFormule), NULL
, "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_typeFormule'                       *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeFormule::
GGS_typeFormule (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeFormule GGS_typeFormule::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeFormule _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeFormule *> (inPointer) != NULL)
      : (typeid (cPtr_typeFormule) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeFormule (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeFormule),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeFormule::actualTypeName (void) const {
  return "typeFormule" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  abstract class 'cPtr_typeFormuleTrue'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeFormuleTrue::
cPtr_typeFormuleTrue (LOCATION_ARGS)
:cPtr_typeFormule (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeFormuleTrue * GGS_typeFormuleTrue::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFormuleTrue *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeFormuleTrue *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeFormuleTrue::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeFormuleTrue::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeFormuleTrue:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeFormuleTrue::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeFormuleTrue::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeFormuleTrue (& typeid (cPtr_typeFormuleTrue), & typeid (cPtr_typeFormule), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeFormuleTrue'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeFormuleTrue::
GGS_typeFormuleTrue (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeFormuleTrue GGS_typeFormuleTrue::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeFormuleTrue _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeFormuleTrue *> (inPointer) != NULL)
      : (typeid (cPtr_typeFormuleTrue) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeFormuleTrue (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeFormuleTrue),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_typeFormuleTrue GGS_typeFormuleTrue::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_typeFormuleTrue result ;
  macroMyNew (result.mPointer, cPtr_typeFormuleTrue (THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeFormuleTrue::actualTypeName (void) const {
  return "typeFormuleTrue" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  abstract class 'cPtr_typeFormuleFalse'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeFormuleFalse::
cPtr_typeFormuleFalse (LOCATION_ARGS)
:cPtr_typeFormule (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeFormuleFalse * GGS_typeFormuleFalse::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFormuleFalse *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeFormuleFalse *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeFormuleFalse::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeFormuleFalse::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeFormuleFalse:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeFormuleFalse::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeFormuleFalse::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeFormuleFalse (& typeid (cPtr_typeFormuleFalse), & typeid (cPtr_typeFormule), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeFormuleFalse'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeFormuleFalse::
GGS_typeFormuleFalse (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeFormuleFalse GGS_typeFormuleFalse::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeFormuleFalse _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeFormuleFalse *> (inPointer) != NULL)
      : (typeid (cPtr_typeFormuleFalse) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeFormuleFalse (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeFormuleFalse),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_typeFormuleFalse GGS_typeFormuleFalse::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_typeFormuleFalse result ;
  macroMyNew (result.mPointer, cPtr_typeFormuleFalse (THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeFormuleFalse::actualTypeName (void) const {
  return "typeFormuleFalse" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   abstract class 'cPtr_typeFormuleVar'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeFormuleVar::
cPtr_typeFormuleVar (const GGS_luint & argument_0,
                                const GGS_luint & argument_1,
                                const GGS_luint & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeFormule (THERE),
mNumeroVariable (argument_0),
mLowBound (argument_1),
mHighBound (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeFormuleVar * GGS_typeFormuleVar::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFormuleVar *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeFormuleVar *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeFormuleVar::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeFormuleVar * _p = dynamic_cast <const cPtr_typeFormuleVar *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mNumeroVariable._operator_isEqual (_p->mNumeroVariable).boolValue ()
         && mLowBound._operator_isEqual (_p->mLowBound).boolValue ()
         && mHighBound._operator_isEqual (_p->mHighBound).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeFormuleVar::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeFormuleVar:"
           << mNumeroVariable.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mLowBound.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mHighBound.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeFormuleVar::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeFormuleVar::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeFormuleVar (& typeid (cPtr_typeFormuleVar), & typeid (cPtr_typeFormule), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeFormuleVar'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeFormuleVar::
GGS_typeFormuleVar (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeFormuleVar GGS_typeFormuleVar::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeFormuleVar _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeFormuleVar *> (inPointer) != NULL)
      : (typeid (cPtr_typeFormuleVar) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeFormuleVar (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeFormuleVar),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_typeFormuleVar GGS_typeFormuleVar::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_luint & argument_0,
                 const GGS_luint & argument_1,
                 const GGS_luint & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeFormuleVar result ;
  macroMyNew (result.mPointer, cPtr_typeFormuleVar (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_typeFormuleVar::
reader_mNumeroVariable (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFormuleVar *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeFormuleVar *) mPointer)->mNumeroVariable ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_typeFormuleVar::
reader_mLowBound (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFormuleVar *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeFormuleVar *) mPointer)->mLowBound ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_typeFormuleVar::
reader_mHighBound (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFormuleVar *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeFormuleVar *) mPointer)->mHighBound ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeFormuleVar::actualTypeName (void) const {
  return "typeFormuleVar" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   abstract class 'cPtr_typeFormuleFor'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeFormuleFor::
cPtr_typeFormuleFor (const GGS_luint & argument_0,
                                const GGS_typeActualArgumentsList & argument_1,
                                const GGS_extern_bdd& argument_2,
                                const GGS_lbool & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_typeFormule (THERE),
mNumeroFormule (argument_0),
mListeArgsBool (argument_1),
mFormuleTraduite (argument_2),
mEstFormuleCourante (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeFormuleFor * GGS_typeFormuleFor::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFormuleFor *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeFormuleFor *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeFormuleFor::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeFormuleFor * _p = dynamic_cast <const cPtr_typeFormuleFor *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mNumeroFormule._operator_isEqual (_p->mNumeroFormule).boolValue ()
         && mListeArgsBool._operator_isEqual (_p->mListeArgsBool).boolValue ()
         && mFormuleTraduite._operator_isEqual (_p->mFormuleTraduite).boolValue ()
         && mEstFormuleCourante._operator_isEqual (_p->mEstFormuleCourante).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeFormuleFor::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeFormuleFor:"
           << mNumeroFormule.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mListeArgsBool.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mFormuleTraduite.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mEstFormuleCourante.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeFormuleFor::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeFormuleFor::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeFormuleFor (& typeid (cPtr_typeFormuleFor), & typeid (cPtr_typeFormule), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeFormuleFor'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeFormuleFor::
GGS_typeFormuleFor (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeFormuleFor GGS_typeFormuleFor::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeFormuleFor _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeFormuleFor *> (inPointer) != NULL)
      : (typeid (cPtr_typeFormuleFor) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeFormuleFor (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeFormuleFor),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_typeFormuleFor GGS_typeFormuleFor::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_luint & argument_0,
                 const GGS_typeActualArgumentsList & argument_1,
                 const GGS_extern_bdd& argument_2,
                 const GGS_lbool & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_typeFormuleFor result ;
  macroMyNew (result.mPointer, cPtr_typeFormuleFor (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_typeFormuleFor::
reader_mNumeroFormule (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFormuleFor *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeFormuleFor *) mPointer)->mNumeroFormule ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeActualArgumentsList  GGS_typeFormuleFor::
reader_mListeArgsBool (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeActualArgumentsList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFormuleFor *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeFormuleFor *) mPointer)->mListeArgsBool ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_extern_bdd GGS_typeFormuleFor::
reader_mFormuleTraduite (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_extern_bdd  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFormuleFor *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeFormuleFor *) mPointer)->mFormuleTraduite ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lbool  GGS_typeFormuleFor::
reader_mEstFormuleCourante (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lbool   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFormuleFor *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeFormuleFor *) mPointer)->mEstFormuleCourante ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeFormuleFor::actualTypeName (void) const {
  return "typeFormuleFor" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   abstract class 'cPtr_typeFormuleNon'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeFormuleNon::
cPtr_typeFormuleNon (const GGS_typeFormule & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_typeFormule (THERE),
mOperand (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeFormuleNon * GGS_typeFormuleNon::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFormuleNon *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeFormuleNon *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeFormuleNon::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeFormuleNon * _p = dynamic_cast <const cPtr_typeFormuleNon *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mOperand._operator_isEqual (_p->mOperand).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeFormuleNon::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeFormuleNon:"
           << mOperand.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeFormuleNon::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeFormuleNon::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeFormuleNon (& typeid (cPtr_typeFormuleNon), & typeid (cPtr_typeFormule), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeFormuleNon'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeFormuleNon::
GGS_typeFormuleNon (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeFormuleNon GGS_typeFormuleNon::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeFormuleNon _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeFormuleNon *> (inPointer) != NULL)
      : (typeid (cPtr_typeFormuleNon) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeFormuleNon (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeFormuleNon),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_typeFormuleNon GGS_typeFormuleNon::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_typeFormule & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_typeFormuleNon result ;
  macroMyNew (result.mPointer, cPtr_typeFormuleNon (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeFormule  GGS_typeFormuleNon::
reader_mOperand (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeFormule   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFormuleNon *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeFormuleNon *) mPointer)->mOperand ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeFormuleNon::actualTypeName (void) const {
  return "typeFormuleNon" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   abstract class 'cPtr_typeFormuleEt'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeFormuleEt::
cPtr_typeFormuleEt (const GGS_typeFormule & argument_0,
                                const GGS_typeFormule & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_typeFormule (THERE),
mOperand1 (argument_0),
mOperand2 (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeFormuleEt * GGS_typeFormuleEt::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFormuleEt *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeFormuleEt *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeFormuleEt::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeFormuleEt * _p = dynamic_cast <const cPtr_typeFormuleEt *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mOperand1._operator_isEqual (_p->mOperand1).boolValue ()
         && mOperand2._operator_isEqual (_p->mOperand2).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeFormuleEt::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeFormuleEt:"
           << mOperand1.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mOperand2.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeFormuleEt::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeFormuleEt::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeFormuleEt (& typeid (cPtr_typeFormuleEt), & typeid (cPtr_typeFormule), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_typeFormuleEt'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeFormuleEt::
GGS_typeFormuleEt (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeFormuleEt GGS_typeFormuleEt::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeFormuleEt _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeFormuleEt *> (inPointer) != NULL)
      : (typeid (cPtr_typeFormuleEt) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeFormuleEt (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeFormuleEt),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_typeFormuleEt GGS_typeFormuleEt::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_typeFormule & argument_0,
                 const GGS_typeFormule & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_typeFormuleEt result ;
  macroMyNew (result.mPointer, cPtr_typeFormuleEt (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeFormule  GGS_typeFormuleEt::
reader_mOperand1 (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeFormule   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFormuleEt *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeFormuleEt *) mPointer)->mOperand1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeFormule  GGS_typeFormuleEt::
reader_mOperand2 (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeFormule   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFormuleEt *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeFormuleEt *) mPointer)->mOperand2 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeFormuleEt::actualTypeName (void) const {
  return "typeFormuleEt" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   abstract class 'cPtr_typeFormuleIte'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeFormuleIte::
cPtr_typeFormuleIte (const GGS_typeFormule & argument_0,
                                const GGS_typeFormule & argument_1,
                                const GGS_typeFormule & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeFormule (THERE),
mOperand1 (argument_0),
mOperand2 (argument_1),
mOperand3 (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeFormuleIte * GGS_typeFormuleIte::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFormuleIte *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeFormuleIte *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeFormuleIte::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeFormuleIte * _p = dynamic_cast <const cPtr_typeFormuleIte *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mOperand1._operator_isEqual (_p->mOperand1).boolValue ()
         && mOperand2._operator_isEqual (_p->mOperand2).boolValue ()
         && mOperand3._operator_isEqual (_p->mOperand3).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeFormuleIte::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeFormuleIte:"
           << mOperand1.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mOperand2.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mOperand3.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeFormuleIte::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeFormuleIte::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeFormuleIte (& typeid (cPtr_typeFormuleIte), & typeid (cPtr_typeFormule), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeFormuleIte'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeFormuleIte::
GGS_typeFormuleIte (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeFormuleIte GGS_typeFormuleIte::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeFormuleIte _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeFormuleIte *> (inPointer) != NULL)
      : (typeid (cPtr_typeFormuleIte) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeFormuleIte (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeFormuleIte),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_typeFormuleIte GGS_typeFormuleIte::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_typeFormule & argument_0,
                 const GGS_typeFormule & argument_1,
                 const GGS_typeFormule & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeFormuleIte result ;
  macroMyNew (result.mPointer, cPtr_typeFormuleIte (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeFormule  GGS_typeFormuleIte::
reader_mOperand1 (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeFormule   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFormuleIte *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeFormuleIte *) mPointer)->mOperand1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeFormule  GGS_typeFormuleIte::
reader_mOperand2 (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeFormule   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFormuleIte *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeFormuleIte *) mPointer)->mOperand2 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeFormule  GGS_typeFormuleIte::
reader_mOperand3 (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeFormule   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFormuleIte *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeFormuleIte *) mPointer)->mOperand3 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeFormuleIte::actualTypeName (void) const {
  return "typeFormuleIte" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   abstract class 'cPtr_typeFormuleOu'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeFormuleOu::
cPtr_typeFormuleOu (const GGS_typeFormule & argument_0,
                                const GGS_typeFormule & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_typeFormule (THERE),
mOperand1 (argument_0),
mOperand2 (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeFormuleOu * GGS_typeFormuleOu::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFormuleOu *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeFormuleOu *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeFormuleOu::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeFormuleOu * _p = dynamic_cast <const cPtr_typeFormuleOu *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mOperand1._operator_isEqual (_p->mOperand1).boolValue ()
         && mOperand2._operator_isEqual (_p->mOperand2).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeFormuleOu::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeFormuleOu:"
           << mOperand1.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mOperand2.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeFormuleOu::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeFormuleOu::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeFormuleOu (& typeid (cPtr_typeFormuleOu), & typeid (cPtr_typeFormule), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_typeFormuleOu'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeFormuleOu::
GGS_typeFormuleOu (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeFormuleOu GGS_typeFormuleOu::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeFormuleOu _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeFormuleOu *> (inPointer) != NULL)
      : (typeid (cPtr_typeFormuleOu) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeFormuleOu (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeFormuleOu),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_typeFormuleOu GGS_typeFormuleOu::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_typeFormule & argument_0,
                 const GGS_typeFormule & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_typeFormuleOu result ;
  macroMyNew (result.mPointer, cPtr_typeFormuleOu (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeFormule  GGS_typeFormuleOu::
reader_mOperand1 (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeFormule   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFormuleOu *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeFormuleOu *) mPointer)->mOperand1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeFormule  GGS_typeFormuleOu::
reader_mOperand2 (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeFormule   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFormuleOu *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeFormuleOu *) mPointer)->mOperand2 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeFormuleOu::actualTypeName (void) const {
  return "typeFormuleOu" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                abstract class 'cPtr_typeFormuleImplique'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeFormuleImplique::
cPtr_typeFormuleImplique (const GGS_typeFormule & argument_0,
                                const GGS_typeFormule & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_typeFormule (THERE),
mOperand1 (argument_0),
mOperand2 (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeFormuleImplique * GGS_typeFormuleImplique::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFormuleImplique *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeFormuleImplique *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeFormuleImplique::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeFormuleImplique * _p = dynamic_cast <const cPtr_typeFormuleImplique *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mOperand1._operator_isEqual (_p->mOperand1).boolValue ()
         && mOperand2._operator_isEqual (_p->mOperand2).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeFormuleImplique::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeFormuleImplique:"
           << mOperand1.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mOperand2.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeFormuleImplique::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeFormuleImplique::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeFormuleImplique (& typeid (cPtr_typeFormuleImplique), & typeid (cPtr_typeFormule), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeFormuleImplique'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeFormuleImplique::
GGS_typeFormuleImplique (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeFormuleImplique GGS_typeFormuleImplique::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeFormuleImplique _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeFormuleImplique *> (inPointer) != NULL)
      : (typeid (cPtr_typeFormuleImplique) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeFormuleImplique (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeFormuleImplique),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_typeFormuleImplique GGS_typeFormuleImplique::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_typeFormule & argument_0,
                 const GGS_typeFormule & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_typeFormuleImplique result ;
  macroMyNew (result.mPointer, cPtr_typeFormuleImplique (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeFormule  GGS_typeFormuleImplique::
reader_mOperand1 (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeFormule   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFormuleImplique *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeFormuleImplique *) mPointer)->mOperand1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeFormule  GGS_typeFormuleImplique::
reader_mOperand2 (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeFormule   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFormuleImplique *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeFormuleImplique *) mPointer)->mOperand2 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeFormuleImplique::actualTypeName (void) const {
  return "typeFormuleImplique" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              abstract class 'cPtr_typeComparaisonFormules'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeComparaisonFormules::
cPtr_typeComparaisonFormules (const GGS_luint & argument_0,
                                const GGS_typeFormule & argument_1,
                                const GGS_typeFormule & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeFormule (THERE),
mComparaison (argument_0),
mOperand1 (argument_1),
mOperand2 (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeComparaisonFormules * GGS_typeComparaisonFormules::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeComparaisonFormules *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeComparaisonFormules *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeComparaisonFormules::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeComparaisonFormules * _p = dynamic_cast <const cPtr_typeComparaisonFormules *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mComparaison._operator_isEqual (_p->mComparaison).boolValue ()
         && mOperand1._operator_isEqual (_p->mOperand1).boolValue ()
         && mOperand2._operator_isEqual (_p->mOperand2).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeComparaisonFormules::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeComparaisonFormules:"
           << mComparaison.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mOperand1.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mOperand2.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeComparaisonFormules::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeComparaisonFormules::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeComparaisonFormules (& typeid (cPtr_typeComparaisonFormules), & typeid (cPtr_typeFormule), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_typeComparaisonFormules'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeComparaisonFormules::
GGS_typeComparaisonFormules (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeComparaisonFormules GGS_typeComparaisonFormules::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeComparaisonFormules _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeComparaisonFormules *> (inPointer) != NULL)
      : (typeid (cPtr_typeComparaisonFormules) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeComparaisonFormules (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeComparaisonFormules),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_typeComparaisonFormules GGS_typeComparaisonFormules::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_luint & argument_0,
                 const GGS_typeFormule & argument_1,
                 const GGS_typeFormule & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeComparaisonFormules result ;
  macroMyNew (result.mPointer, cPtr_typeComparaisonFormules (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_typeComparaisonFormules::
reader_mComparaison (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeComparaisonFormules *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeComparaisonFormules *) mPointer)->mComparaison ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeFormule  GGS_typeComparaisonFormules::
reader_mOperand1 (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeFormule   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeComparaisonFormules *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeComparaisonFormules *) mPointer)->mOperand1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeFormule  GGS_typeComparaisonFormules::
reader_mOperand2 (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeFormule   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeComparaisonFormules *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeComparaisonFormules *) mPointer)->mOperand2 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeComparaisonFormules::actualTypeName (void) const {
  return "typeComparaisonFormules" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  abstract class 'cPtr_typeFormuleExist'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeFormuleExist::
cPtr_typeFormuleExist (const GGS_typeFormalArgumentsList & argument_0,
                                const GGS_typeFormule & argument_1,
                                const GGS_extern_bdd& argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeFormule (THERE),
mListeArgsBooleens (argument_0),
mOperand (argument_1),
mContraints (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeFormuleExist * GGS_typeFormuleExist::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFormuleExist *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeFormuleExist *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeFormuleExist::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeFormuleExist * _p = dynamic_cast <const cPtr_typeFormuleExist *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mListeArgsBooleens._operator_isEqual (_p->mListeArgsBooleens).boolValue ()
         && mOperand._operator_isEqual (_p->mOperand).boolValue ()
         && mContraints._operator_isEqual (_p->mContraints).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeFormuleExist::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeFormuleExist:"
           << mListeArgsBooleens.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mOperand.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mContraints.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeFormuleExist::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeFormuleExist::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeFormuleExist (& typeid (cPtr_typeFormuleExist), & typeid (cPtr_typeFormule), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeFormuleExist'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeFormuleExist::
GGS_typeFormuleExist (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeFormuleExist GGS_typeFormuleExist::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeFormuleExist _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeFormuleExist *> (inPointer) != NULL)
      : (typeid (cPtr_typeFormuleExist) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeFormuleExist (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeFormuleExist),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_typeFormuleExist GGS_typeFormuleExist::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_typeFormalArgumentsList & argument_0,
                 const GGS_typeFormule & argument_1,
                 const GGS_extern_bdd& argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeFormuleExist result ;
  macroMyNew (result.mPointer, cPtr_typeFormuleExist (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeFormalArgumentsList  GGS_typeFormuleExist::
reader_mListeArgsBooleens (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeFormalArgumentsList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFormuleExist *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeFormuleExist *) mPointer)->mListeArgsBooleens ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeFormule  GGS_typeFormuleExist::
reader_mOperand (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeFormule   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFormuleExist *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeFormuleExist *) mPointer)->mOperand ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_extern_bdd GGS_typeFormuleExist::
reader_mContraints (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_extern_bdd  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFormuleExist *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeFormuleExist *) mPointer)->mContraints ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeFormuleExist::actualTypeName (void) const {
  return "typeFormuleExist" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            abstract class 'cPtr_typeFormuleComparaisonValeur'             *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeFormuleComparaisonValeur::
cPtr_typeFormuleComparaisonValeur (const GGS_luint & argument_0,
                                const GGS_luint & argument_1,
                                const GGS_luint & argument_2,
                                const GGS_luint & argument_3,
                                const GGS_luint & argument_4,
                                const GGS_luint & argument_5
                                COMMA_LOCATION_ARGS)
:cPtr_typeFormule (THERE),
mIndiceBDD (argument_0),
mDimension (argument_1),
mLowBound (argument_2),
mHighBound (argument_3),
mComparaison (argument_4),
mValeur (argument_5) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeFormuleComparaisonValeur * GGS_typeFormuleComparaisonValeur::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFormuleComparaisonValeur *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeFormuleComparaisonValeur *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeFormuleComparaisonValeur::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeFormuleComparaisonValeur * _p = dynamic_cast <const cPtr_typeFormuleComparaisonValeur *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mIndiceBDD._operator_isEqual (_p->mIndiceBDD).boolValue ()
         && mDimension._operator_isEqual (_p->mDimension).boolValue ()
         && mLowBound._operator_isEqual (_p->mLowBound).boolValue ()
         && mHighBound._operator_isEqual (_p->mHighBound).boolValue ()
         && mComparaison._operator_isEqual (_p->mComparaison).boolValue ()
         && mValeur._operator_isEqual (_p->mValeur).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeFormuleComparaisonValeur::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeFormuleComparaisonValeur:"
           << mIndiceBDD.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mDimension.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mLowBound.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mHighBound.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mComparaison.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mValeur.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeFormuleComparaisonValeur::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeFormuleComparaisonValeur::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeFormuleComparaisonValeur (& typeid (cPtr_typeFormuleComparaisonValeur), & typeid (cPtr_typeFormule), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_typeFormuleComparaisonValeur'               *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeFormuleComparaisonValeur::
GGS_typeFormuleComparaisonValeur (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeFormuleComparaisonValeur GGS_typeFormuleComparaisonValeur::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeFormuleComparaisonValeur _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeFormuleComparaisonValeur *> (inPointer) != NULL)
      : (typeid (cPtr_typeFormuleComparaisonValeur) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeFormuleComparaisonValeur (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeFormuleComparaisonValeur),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_typeFormuleComparaisonValeur GGS_typeFormuleComparaisonValeur::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_luint & argument_0,
                 const GGS_luint & argument_1,
                 const GGS_luint & argument_2,
                 const GGS_luint & argument_3,
                 const GGS_luint & argument_4,
                 const GGS_luint & argument_5
                                COMMA_LOCATION_ARGS) {
  GGS_typeFormuleComparaisonValeur result ;
  macroMyNew (result.mPointer, cPtr_typeFormuleComparaisonValeur (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_typeFormuleComparaisonValeur::
reader_mIndiceBDD (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFormuleComparaisonValeur *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeFormuleComparaisonValeur *) mPointer)->mIndiceBDD ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_typeFormuleComparaisonValeur::
reader_mDimension (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFormuleComparaisonValeur *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeFormuleComparaisonValeur *) mPointer)->mDimension ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_typeFormuleComparaisonValeur::
reader_mLowBound (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFormuleComparaisonValeur *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeFormuleComparaisonValeur *) mPointer)->mLowBound ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_typeFormuleComparaisonValeur::
reader_mHighBound (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFormuleComparaisonValeur *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeFormuleComparaisonValeur *) mPointer)->mHighBound ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_typeFormuleComparaisonValeur::
reader_mComparaison (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFormuleComparaisonValeur *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeFormuleComparaisonValeur *) mPointer)->mComparaison ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_typeFormuleComparaisonValeur::
reader_mValeur (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFormuleComparaisonValeur *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeFormuleComparaisonValeur *) mPointer)->mValeur ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeFormuleComparaisonValeur::actualTypeName (void) const {
  return "typeFormuleComparaisonValeur" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           abstract class 'cPtr_typeFormuleComparaisonVariable'            *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeFormuleComparaisonVariable::
cPtr_typeFormuleComparaisonVariable (const GGS_luint & argument_0,
                                const GGS_luint & argument_1,
                                const GGS_luint & argument_2,
                                const GGS_luint & argument_3,
                                const GGS_luint & argument_4,
                                const GGS_luint & argument_5,
                                const GGS_luint & argument_6,
                                const GGS_luint & argument_7
                                COMMA_LOCATION_ARGS)
:cPtr_typeFormule (THERE),
mIndiceBDDgauche (argument_0),
mDimension (argument_1),
mLeftLowBound (argument_2),
mLeftHighBound (argument_3),
mComparaison (argument_4),
mIndiceBDDdroite (argument_5),
mRightLowBound (argument_6),
mRightHighBound (argument_7) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeFormuleComparaisonVariable * GGS_typeFormuleComparaisonVariable::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFormuleComparaisonVariable *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeFormuleComparaisonVariable *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeFormuleComparaisonVariable::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeFormuleComparaisonVariable * _p = dynamic_cast <const cPtr_typeFormuleComparaisonVariable *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mIndiceBDDgauche._operator_isEqual (_p->mIndiceBDDgauche).boolValue ()
         && mDimension._operator_isEqual (_p->mDimension).boolValue ()
         && mLeftLowBound._operator_isEqual (_p->mLeftLowBound).boolValue ()
         && mLeftHighBound._operator_isEqual (_p->mLeftHighBound).boolValue ()
         && mComparaison._operator_isEqual (_p->mComparaison).boolValue ()
         && mIndiceBDDdroite._operator_isEqual (_p->mIndiceBDDdroite).boolValue ()
         && mRightLowBound._operator_isEqual (_p->mRightLowBound).boolValue ()
         && mRightHighBound._operator_isEqual (_p->mRightHighBound).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeFormuleComparaisonVariable::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeFormuleComparaisonVariable:"
           << mIndiceBDDgauche.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mDimension.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mLeftLowBound.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mLeftHighBound.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mComparaison.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mIndiceBDDdroite.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mRightLowBound.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mRightHighBound.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeFormuleComparaisonVariable::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeFormuleComparaisonVariable::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeFormuleComparaisonVariable (& typeid (cPtr_typeFormuleComparaisonVariable), & typeid (cPtr_typeFormule), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//            GALGAS class 'GGS_typeFormuleComparaisonVariable'              *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeFormuleComparaisonVariable::
GGS_typeFormuleComparaisonVariable (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeFormuleComparaisonVariable GGS_typeFormuleComparaisonVariable::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeFormuleComparaisonVariable _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeFormuleComparaisonVariable *> (inPointer) != NULL)
      : (typeid (cPtr_typeFormuleComparaisonVariable) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeFormuleComparaisonVariable (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeFormuleComparaisonVariable),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_typeFormuleComparaisonVariable GGS_typeFormuleComparaisonVariable::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_luint & argument_0,
                 const GGS_luint & argument_1,
                 const GGS_luint & argument_2,
                 const GGS_luint & argument_3,
                 const GGS_luint & argument_4,
                 const GGS_luint & argument_5,
                 const GGS_luint & argument_6,
                 const GGS_luint & argument_7
                                COMMA_LOCATION_ARGS) {
  GGS_typeFormuleComparaisonVariable result ;
  macroMyNew (result.mPointer, cPtr_typeFormuleComparaisonVariable (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6,
                                argument_7 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_typeFormuleComparaisonVariable::
reader_mIndiceBDDgauche (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFormuleComparaisonVariable *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeFormuleComparaisonVariable *) mPointer)->mIndiceBDDgauche ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_typeFormuleComparaisonVariable::
reader_mDimension (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFormuleComparaisonVariable *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeFormuleComparaisonVariable *) mPointer)->mDimension ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_typeFormuleComparaisonVariable::
reader_mLeftLowBound (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFormuleComparaisonVariable *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeFormuleComparaisonVariable *) mPointer)->mLeftLowBound ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_typeFormuleComparaisonVariable::
reader_mLeftHighBound (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFormuleComparaisonVariable *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeFormuleComparaisonVariable *) mPointer)->mLeftHighBound ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_typeFormuleComparaisonVariable::
reader_mComparaison (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFormuleComparaisonVariable *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeFormuleComparaisonVariable *) mPointer)->mComparaison ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_typeFormuleComparaisonVariable::
reader_mIndiceBDDdroite (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFormuleComparaisonVariable *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeFormuleComparaisonVariable *) mPointer)->mIndiceBDDdroite ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_typeFormuleComparaisonVariable::
reader_mRightLowBound (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFormuleComparaisonVariable *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeFormuleComparaisonVariable *) mPointer)->mRightLowBound ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_typeFormuleComparaisonVariable::
reader_mRightHighBound (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFormuleComparaisonVariable *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeFormuleComparaisonVariable *) mPointer)->mRightHighBound ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeFormuleComparaisonVariable::actualTypeName (void) const {
  return "typeFormuleComparaisonVariable" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     abstract class 'cPtr_typeCalcul'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeCalcul::
cPtr_typeCalcul (LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeCalcul * GGS_typeCalcul::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeCalcul *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeCalcul *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_typeCalcul::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeCalcul:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeCalcul::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeCalcul::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeCalcul (& typeid (cPtr_typeCalcul), NULL
, "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_typeCalcul'                        *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeCalcul::
GGS_typeCalcul (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeCalcul GGS_typeCalcul::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeCalcul _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeCalcul *> (inPointer) != NULL)
      : (typeid (cPtr_typeCalcul) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeCalcul (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeCalcul),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeCalcul::actualTypeName (void) const {
  return "typeCalcul" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  abstract class 'cPtr_typeCalculSimple'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeCalculSimple::
cPtr_typeCalculSimple (const GGS_luint & argument_0,
                                const GGS_typeFormule & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_typeTableVariablesBool & argument_3,
                                const GGS_luint & argument_4
                                COMMA_LOCATION_ARGS)
:cPtr_typeCalcul (THERE),
mNumeroFormule (argument_0),
mFormule (argument_1),
mNomFormule (argument_2),
mTableVariablesBool (argument_3),
mAfficher (argument_4) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeCalculSimple * GGS_typeCalculSimple::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeCalculSimple *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeCalculSimple *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeCalculSimple::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeCalculSimple * _p = dynamic_cast <const cPtr_typeCalculSimple *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mNumeroFormule._operator_isEqual (_p->mNumeroFormule).boolValue ()
         && mFormule._operator_isEqual (_p->mFormule).boolValue ()
         && mNomFormule._operator_isEqual (_p->mNomFormule).boolValue ()
         && mTableVariablesBool._operator_isEqual (_p->mTableVariablesBool).boolValue ()
         && mAfficher._operator_isEqual (_p->mAfficher).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeCalculSimple::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeCalculSimple:"
           << mNumeroFormule.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mFormule.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mNomFormule.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mTableVariablesBool.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mAfficher.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeCalculSimple::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeCalculSimple::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeCalculSimple (& typeid (cPtr_typeCalculSimple), & typeid (cPtr_typeCalcul), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeCalculSimple'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeCalculSimple::
GGS_typeCalculSimple (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeCalculSimple GGS_typeCalculSimple::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeCalculSimple _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeCalculSimple *> (inPointer) != NULL)
      : (typeid (cPtr_typeCalculSimple) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeCalculSimple (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeCalculSimple),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_typeCalculSimple GGS_typeCalculSimple::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_luint & argument_0,
                 const GGS_typeFormule & argument_1,
                 const GGS_lstring & argument_2,
                 const GGS_typeTableVariablesBool & argument_3,
                 const GGS_luint & argument_4
                                COMMA_LOCATION_ARGS) {
  GGS_typeCalculSimple result ;
  macroMyNew (result.mPointer, cPtr_typeCalculSimple (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_typeCalculSimple::
reader_mNumeroFormule (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeCalculSimple *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeCalculSimple *) mPointer)->mNumeroFormule ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeFormule  GGS_typeCalculSimple::
reader_mFormule (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeFormule   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeCalculSimple *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeCalculSimple *) mPointer)->mFormule ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeCalculSimple::
reader_mNomFormule (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeCalculSimple *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeCalculSimple *) mPointer)->mNomFormule ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeTableVariablesBool  GGS_typeCalculSimple::
reader_mTableVariablesBool (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeTableVariablesBool   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeCalculSimple *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeCalculSimple *) mPointer)->mTableVariablesBool ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_typeCalculSimple::
reader_mAfficher (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeCalculSimple *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeCalculSimple *) mPointer)->mAfficher ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeCalculSimple::actualTypeName (void) const {
  return "typeCalculSimple" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    abstract class 'cPtr_typeUse_AND'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeUse_AND::
cPtr_typeUse_AND (LOCATION_ARGS)
:cPtr_typeCalcul (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeUse_AND * GGS_typeUse_AND::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeUse_AND *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeUse_AND *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeUse_AND::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeUse_AND::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeUse_AND:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeUse_AND::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeUse_AND::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeUse_AND (& typeid (cPtr_typeUse_AND), & typeid (cPtr_typeCalcul), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_typeUse_AND'                       *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeUse_AND::
GGS_typeUse_AND (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeUse_AND GGS_typeUse_AND::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeUse_AND _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeUse_AND *> (inPointer) != NULL)
      : (typeid (cPtr_typeUse_AND) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeUse_AND (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeUse_AND),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_typeUse_AND GGS_typeUse_AND::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_typeUse_AND result ;
  macroMyNew (result.mPointer, cPtr_typeUse_AND (THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeUse_AND::actualTypeName (void) const {
  return "typeUse_AND" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    abstract class 'cPtr_typeUse_ITE'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeUse_ITE::
cPtr_typeUse_ITE (LOCATION_ARGS)
:cPtr_typeCalcul (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeUse_ITE * GGS_typeUse_ITE::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeUse_ITE *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeUse_ITE *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeUse_ITE::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeUse_ITE::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeUse_ITE:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeUse_ITE::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeUse_ITE::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeUse_ITE (& typeid (cPtr_typeUse_ITE), & typeid (cPtr_typeCalcul), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_typeUse_ITE'                       *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeUse_ITE::
GGS_typeUse_ITE (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeUse_ITE GGS_typeUse_ITE::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeUse_ITE _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeUse_ITE *> (inPointer) != NULL)
      : (typeid (cPtr_typeUse_ITE) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeUse_ITE (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeUse_ITE),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_typeUse_ITE GGS_typeUse_ITE::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_typeUse_ITE result ;
  macroMyNew (result.mPointer, cPtr_typeUse_ITE (THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeUse_ITE::actualTypeName (void) const {
  return "typeUse_ITE" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  abstract class 'cPtr_typeUse_AND_ITE'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeUse_AND_ITE::
cPtr_typeUse_AND_ITE (LOCATION_ARGS)
:cPtr_typeCalcul (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeUse_AND_ITE * GGS_typeUse_AND_ITE::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeUse_AND_ITE *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeUse_AND_ITE *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeUse_AND_ITE::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeUse_AND_ITE::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeUse_AND_ITE:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeUse_AND_ITE::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeUse_AND_ITE::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeUse_AND_ITE (& typeid (cPtr_typeUse_AND_ITE), & typeid (cPtr_typeCalcul), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeUse_AND_ITE'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeUse_AND_ITE::
GGS_typeUse_AND_ITE (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeUse_AND_ITE GGS_typeUse_AND_ITE::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeUse_AND_ITE _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeUse_AND_ITE *> (inPointer) != NULL)
      : (typeid (cPtr_typeUse_AND_ITE) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeUse_AND_ITE (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeUse_AND_ITE),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_typeUse_AND_ITE GGS_typeUse_AND_ITE::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_typeUse_AND_ITE result ;
  macroMyNew (result.mPointer, cPtr_typeUse_AND_ITE (THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeUse_AND_ITE::actualTypeName (void) const {
  return "typeUse_AND_ITE" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              abstract class 'cPtr_typeDimensionnerANDCache'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeDimensionnerANDCache::
cPtr_typeDimensionnerANDCache (const GGS_luint & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_typeCalcul (THERE),
mDimensionCache (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeDimensionnerANDCache * GGS_typeDimensionnerANDCache::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeDimensionnerANDCache *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeDimensionnerANDCache *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeDimensionnerANDCache::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeDimensionnerANDCache * _p = dynamic_cast <const cPtr_typeDimensionnerANDCache *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mDimensionCache._operator_isEqual (_p->mDimensionCache).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeDimensionnerANDCache::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeDimensionnerANDCache:"
           << mDimensionCache.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeDimensionnerANDCache::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeDimensionnerANDCache::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeDimensionnerANDCache (& typeid (cPtr_typeDimensionnerANDCache), & typeid (cPtr_typeCalcul), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeDimensionnerANDCache'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeDimensionnerANDCache::
GGS_typeDimensionnerANDCache (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeDimensionnerANDCache GGS_typeDimensionnerANDCache::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeDimensionnerANDCache _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeDimensionnerANDCache *> (inPointer) != NULL)
      : (typeid (cPtr_typeDimensionnerANDCache) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeDimensionnerANDCache (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeDimensionnerANDCache),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_typeDimensionnerANDCache GGS_typeDimensionnerANDCache::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_luint & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_typeDimensionnerANDCache result ;
  macroMyNew (result.mPointer, cPtr_typeDimensionnerANDCache (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_typeDimensionnerANDCache::
reader_mDimensionCache (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeDimensionnerANDCache *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeDimensionnerANDCache *) mPointer)->mDimensionCache ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeDimensionnerANDCache::actualTypeName (void) const {
  return "typeDimensionnerANDCache" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              abstract class 'cPtr_typeDimensionnerITECache'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeDimensionnerITECache::
cPtr_typeDimensionnerITECache (const GGS_luint & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_typeCalcul (THERE),
mDimensionCache (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeDimensionnerITECache * GGS_typeDimensionnerITECache::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeDimensionnerITECache *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeDimensionnerITECache *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeDimensionnerITECache::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeDimensionnerITECache * _p = dynamic_cast <const cPtr_typeDimensionnerITECache *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mDimensionCache._operator_isEqual (_p->mDimensionCache).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeDimensionnerITECache::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeDimensionnerITECache:"
           << mDimensionCache.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeDimensionnerITECache::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeDimensionnerITECache::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeDimensionnerITECache (& typeid (cPtr_typeDimensionnerITECache), & typeid (cPtr_typeCalcul), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeDimensionnerITECache'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeDimensionnerITECache::
GGS_typeDimensionnerITECache (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeDimensionnerITECache GGS_typeDimensionnerITECache::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeDimensionnerITECache _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeDimensionnerITECache *> (inPointer) != NULL)
      : (typeid (cPtr_typeDimensionnerITECache) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeDimensionnerITECache (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeDimensionnerITECache),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_typeDimensionnerITECache GGS_typeDimensionnerITECache::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_luint & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_typeDimensionnerITECache result ;
  macroMyNew (result.mPointer, cPtr_typeDimensionnerITECache (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_typeDimensionnerITECache::
reader_mDimensionCache (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeDimensionnerITECache *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeDimensionnerITECache *) mPointer)->mDimensionCache ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeDimensionnerITECache::actualTypeName (void) const {
  return "typeDimensionnerITECache" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               abstract class 'cPtr_typeDimensionnerTable'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeDimensionnerTable::
cPtr_typeDimensionnerTable (const GGS_luint & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_typeCalcul (THERE),
mDimensionTable (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeDimensionnerTable * GGS_typeDimensionnerTable::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeDimensionnerTable *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeDimensionnerTable *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeDimensionnerTable::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeDimensionnerTable * _p = dynamic_cast <const cPtr_typeDimensionnerTable *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mDimensionTable._operator_isEqual (_p->mDimensionTable).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeDimensionnerTable::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeDimensionnerTable:"
           << mDimensionTable.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeDimensionnerTable::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeDimensionnerTable::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeDimensionnerTable (& typeid (cPtr_typeDimensionnerTable), & typeid (cPtr_typeCalcul), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeDimensionnerTable'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeDimensionnerTable::
GGS_typeDimensionnerTable (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeDimensionnerTable GGS_typeDimensionnerTable::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeDimensionnerTable _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeDimensionnerTable *> (inPointer) != NULL)
      : (typeid (cPtr_typeDimensionnerTable) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeDimensionnerTable (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeDimensionnerTable),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_typeDimensionnerTable GGS_typeDimensionnerTable::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_luint & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_typeDimensionnerTable result ;
  macroMyNew (result.mPointer, cPtr_typeDimensionnerTable (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_typeDimensionnerTable::
reader_mDimensionTable (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeDimensionnerTable *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeDimensionnerTable *) mPointer)->mDimensionTable ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeDimensionnerTable::actualTypeName (void) const {
  return "typeDimensionnerTable" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 abstract class 'cPtr_typeAfficherBilan'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeAfficherBilan::
cPtr_typeAfficherBilan (LOCATION_ARGS)
:cPtr_typeCalcul (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeAfficherBilan * GGS_typeAfficherBilan::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeAfficherBilan *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeAfficherBilan *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeAfficherBilan::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeAfficherBilan::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeAfficherBilan:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeAfficherBilan::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeAfficherBilan::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeAfficherBilan (& typeid (cPtr_typeAfficherBilan), & typeid (cPtr_typeCalcul), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeAfficherBilan'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeAfficherBilan::
GGS_typeAfficherBilan (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeAfficherBilan GGS_typeAfficherBilan::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeAfficherBilan _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeAfficherBilan *> (inPointer) != NULL)
      : (typeid (cPtr_typeAfficherBilan) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeAfficherBilan (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeAfficherBilan),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_typeAfficherBilan GGS_typeAfficherBilan::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_typeAfficherBilan result ;
  macroMyNew (result.mPointer, cPtr_typeAfficherBilan (THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeAfficherBilan::actualTypeName (void) const {
  return "typeAfficherBilan" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 abstract class 'cPtr_typeCalculIteratif'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeCalculIteratif::
cPtr_typeCalculIteratif (const GGS_luint & argument_0,
                                const GGS_typeFormule & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_typeTableVariablesBool & argument_3,
                                const GGS_lbool & argument_4,
                                const GGS_luint & argument_5
                                COMMA_LOCATION_ARGS)
:cPtr_typeCalcul (THERE),
mNumeroFormule (argument_0),
mFormule (argument_1),
mNomFormule (argument_2),
mTableVariablesBool (argument_3),
mSigne (argument_4),
mAfficher (argument_5) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeCalculIteratif * GGS_typeCalculIteratif::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeCalculIteratif *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeCalculIteratif *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeCalculIteratif::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeCalculIteratif * _p = dynamic_cast <const cPtr_typeCalculIteratif *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mNumeroFormule._operator_isEqual (_p->mNumeroFormule).boolValue ()
         && mFormule._operator_isEqual (_p->mFormule).boolValue ()
         && mNomFormule._operator_isEqual (_p->mNomFormule).boolValue ()
         && mTableVariablesBool._operator_isEqual (_p->mTableVariablesBool).boolValue ()
         && mSigne._operator_isEqual (_p->mSigne).boolValue ()
         && mAfficher._operator_isEqual (_p->mAfficher).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeCalculIteratif::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeCalculIteratif:"
           << mNumeroFormule.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mFormule.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mNomFormule.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mTableVariablesBool.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mSigne.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mAfficher.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeCalculIteratif::
_message (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeCalculIteratif::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeCalculIteratif (& typeid (cPtr_typeCalculIteratif), & typeid (cPtr_typeCalcul), "") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeCalculIteratif'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeCalculIteratif::
GGS_typeCalculIteratif (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_typeCalculIteratif GGS_typeCalculIteratif::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeCalculIteratif _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeCalculIteratif *> (inPointer) != NULL)
      : (typeid (cPtr_typeCalculIteratif) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_typeCalculIteratif (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeCalculIteratif),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_typeCalculIteratif GGS_typeCalculIteratif::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_luint & argument_0,
                 const GGS_typeFormule & argument_1,
                 const GGS_lstring & argument_2,
                 const GGS_typeTableVariablesBool & argument_3,
                 const GGS_lbool & argument_4,
                 const GGS_luint & argument_5
                                COMMA_LOCATION_ARGS) {
  GGS_typeCalculIteratif result ;
  macroMyNew (result.mPointer, cPtr_typeCalculIteratif (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_typeCalculIteratif::
reader_mNumeroFormule (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeCalculIteratif *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeCalculIteratif *) mPointer)->mNumeroFormule ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeFormule  GGS_typeCalculIteratif::
reader_mFormule (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeFormule   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeCalculIteratif *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeCalculIteratif *) mPointer)->mFormule ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeCalculIteratif::
reader_mNomFormule (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeCalculIteratif *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeCalculIteratif *) mPointer)->mNomFormule ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeTableVariablesBool  GGS_typeCalculIteratif::
reader_mTableVariablesBool (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeTableVariablesBool   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeCalculIteratif *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeCalculIteratif *) mPointer)->mTableVariablesBool ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lbool  GGS_typeCalculIteratif::
reader_mSigne (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lbool   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeCalculIteratif *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeCalculIteratif *) mPointer)->mSigne ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_typeCalculIteratif::
reader_mAfficher (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeCalculIteratif *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeCalculIteratif *) mPointer)->mAfficher ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeCalculIteratif::actualTypeName (void) const {
  return "typeCalculIteratif" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   Element of list '@typeListeCalculs'                     *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeListeCalculs::
elementOf_GGS_typeListeCalculs (const GGS_typeCalcul & argument_0
                                COMMA_LOCATION_ARGS) :
AC_galgas_list::cListElement (THERE),
mCalcul (argument_0) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_typeListeCalculs::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_typeListeCalculs * _p = dynamic_cast <const elementOf_GGS_typeListeCalculs *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mCalcul._operator_isEqual (_p->mCalcul).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeListeCalculs::
appendForDescription (C_Compiler & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mCalcul.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         List '@typeListeCalculs'                          *
//                                                                           *
//---------------------------------------------------------------------------*

void GGS_typeListeCalculs::
_internalAppendValues (const GGS_typeCalcul & argument_0
                    COMMA_LOCATION_ARGS) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0
                                COMMA_THERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeCalculs::
_internalPrependValues (const GGS_typeCalcul & argument_0
                    COMMA_LOCATION_ARGS) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0
                                COMMA_THERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeCalculs::
_addAssign_operation (const GGS_typeCalcul & argument_0) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_typeListeCalculs GGS_typeListeCalculs::
_operator_concat (const GGS_typeListeCalculs & inOperand) const {
  GGS_typeListeCalculs result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        elementOf_GGS_typeListeCalculs * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_typeCalcul  p_0 = p->mCalcul ;
          result._internalAppendValues (p_0 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeCalculs::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_typeCalcul & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeCalculs::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mCalcul
                                COMMA_HERE) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeListeCalculs  GGS_typeListeCalculs::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeListeCalculs result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeListeCalculs  GGS_typeListeCalculs::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_typeCalcul & argument_0
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeListeCalculs result ;
  result._alloc () ;
  result._addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeCalculs::
internalSubListWithRange (GGS_typeListeCalculs & ioList,
                          const sint32 inFirstIndex,
                          const sint32 inCount) const {
  ioList._alloc () ;
  if (inCount > 0) {
    element_type * _p = firstObject () ;
    for (sint32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (_p) ;
      _p = _p->nextObject () ;
    }
    for (sint32 i=0 ; i<inCount ; i++) {
      macroValidPointer (_p) ;
      ioList._addAssign_operation (_p->mCalcul) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeListeCalculs GGS_typeListeCalculs::
reader_subListWithRange (C_Compiler & _inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_typeListeCalculs result ;
  if (_isBuilt () && inFirstIndex._isBuilt () && inCount._isBuilt ()) {
    const sint32 firstIndex = (sint32) inFirstIndex.uintValue () ;
    const sint32 rangeCount = (sint32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeListeCalculs GGS_typeListeCalculs::
reader_subListFromIndex (C_Compiler & _inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_typeListeCalculs result ;
  if (_isBuilt () && inIndex._isBuilt ()) {
    const sint32 startIndex = (sint32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      _inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeListeCalculs::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@typeListeCalculs", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeCalculs::
method_first (C_Compiler & _inLexique,
              GGS_typeCalcul & _out_0
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mCalcul ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeCalculs::
method_last (C_Compiler & _inLexique,
             GGS_typeCalcul & _out_0
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mCalcul ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeCalculs::
modifier_popFirst (C_Compiler & _inLexique,
                 GGS_typeCalcul & _out_0
                 COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mCalcul ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeCalculs::
modifier_popLast (C_Compiler & _inLexique,
                GGS_typeCalcul & _out_0
                COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mCalcul ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//         Implementation of routine "verifierNombreArgumentsBool"           *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_verifierNombreArgumentsBool (C_Compiler & _inLexique,
                                const GGS_typeFormalArgumentsList   var_cas_t1,
                                const GGS_typeActualArgumentsList   var_cas_t2,
                                const GGS_location   var_cas_positionFinListe COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_verifierNombreArgumentsBool at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  if (((var_cas_t1.reader_length (_inLexique COMMA_SOURCE_FILE_AT_LINE (260)))._operator_strictInf (var_cas_t2.reader_length (_inLexique COMMA_SOURCE_FILE_AT_LINE (260)))).isBuiltAndTrue ()) {
    var_cas_positionFinListe.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "too much actual arguments") COMMA_SOURCE_FILE_AT_LINE (262)) ;
  }else if (((var_cas_t1.reader_length (_inLexique COMMA_SOURCE_FILE_AT_LINE (262)))._operator_strictSup (var_cas_t2.reader_length (_inLexique COMMA_SOURCE_FILE_AT_LINE (262)))).isBuiltAndTrue ()) {
    var_cas_positionFinListe.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "one or more actual arguments missing") COMMA_SOURCE_FILE_AT_LINE (264)) ;
  }
  const GGS_typeFormalArgumentsList _var_7876 = var_cas_t1 ;
  GGS_typeFormalArgumentsList::element_type * operand_7876 = _var_7876.firstObject () ;
  const GGS_typeActualArgumentsList _var_7947 = var_cas_t2 ;
  GGS_typeActualArgumentsList::element_type * operand_7947 = _var_7947.firstObject () ;
  while ((operand_7876 != NULL)
      && (operand_7947 != NULL)) {
    macroValidPointer (operand_7876) ;
    macroValidPointer (operand_7947) ;
    if (((operand_7876->mVariableBitSize.reader_uint (_inLexique COMMA_SOURCE_FILE_AT_LINE (267)))._operator_isEqual (operand_7947->mVariableBitSize.reader_uint (_inLexique COMMA_SOURCE_FILE_AT_LINE (267)))).isBuiltAndTrue ()) {
      if (((operand_7876->mLowBound.reader_uint (_inLexique COMMA_SOURCE_FILE_AT_LINE (268)))._operator_isEqual (operand_7947->mLowBound.reader_uint (_inLexique COMMA_SOURCE_FILE_AT_LINE (268)))).isBuiltAndTrue ()) {
        if (((operand_7876->mHighBound.reader_uint (_inLexique COMMA_SOURCE_FILE_AT_LINE (269)))._operator_isEqual (operand_7947->mHighBound.reader_uint (_inLexique COMMA_SOURCE_FILE_AT_LINE (269)))).isBuiltAndTrue ()) {
        }else{
          operand_7947->mErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "the actual high bound is different the formal one") COMMA_SOURCE_FILE_AT_LINE (272)) ;
        }
      }else{
        operand_7947->mErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "the actual low bound is different the formal one") COMMA_SOURCE_FILE_AT_LINE (275)) ;
      }
    }else{
      operand_7947->mErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "the actual dimension is different from the formal one") COMMA_SOURCE_FILE_AT_LINE (278)) ;
    }
    operand_7876 = operand_7876->nextObject () ;
    operand_7947 = operand_7947->nextObject () ;
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_verifierNombreArgumentsBool\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//             Implementation of routine "buildFormalArgsList"               *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_buildFormalArgsList (C_Compiler & _inLexique,
                                const GGS_typeVariableDescriptor   var_cas_inVariableDescriptor,
                                GGS_typeFormalArgumentsList  & var_cas_ioFormalArgsList,
                                const GGS_location   var_cas_inErrorLocation COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_buildFormalArgsList at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  if (var_cas_inVariableDescriptor._isBuilt ()) {
    cPtr_typeDirectVariable * operand_8833 = dynamic_cast <cPtr_typeDirectVariable *> (var_cas_inVariableDescriptor.getPtr ()) ;
    if (operand_8833 != NULL) {
      macroValidPointer (operand_8833) ; 
      var_cas_ioFormalArgsList._addAssign_operation (operand_8833->mIndex, operand_8833->mBitSize, operand_8833->mLowBound, operand_8833->mHighBound) ;
    }else{
      cPtr_typeRecordVariable * operand_9011 = dynamic_cast <cPtr_typeRecordVariable *> (var_cas_inVariableDescriptor.getPtr ()) ;
      if (operand_9011 != NULL) {
        macroValidPointer (operand_9011) ; 
        const GGS_typeTableVariablesBool _var_9089 = operand_9011->mMap ;
        GGS_typeTableVariablesBool::element_type * operand_9089 = _var_9089.firstObject () ;
        while ((operand_9089 != NULL)) {
          macroValidPointer (operand_9089) ;
          ::routine_buildFormalArgsList (_inLexique,  operand_9089->mInfo.mVariableDescriptor,  var_cas_ioFormalArgsList,  var_cas_inErrorLocation COMMA_SOURCE_FILE_AT_LINE (294)) ;
          operand_9089 = operand_9089->nextObject () ;
        }
      }else{ // Else part
        var_cas_inErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, (GGS_string (true, "a variable was expected here ; I found "))._operator_concat (var_cas_inVariableDescriptor.reader_variableDescriptorErrorMessage (_inLexique COMMA_SOURCE_FILE_AT_LINE (297))) COMMA_SOURCE_FILE_AT_LINE (298)) ;
      }
    }
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_buildFormalArgsList\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//             Implementation of routine "buildActualArgsList"               *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_buildActualArgsList (C_Compiler & _inLexique,
                                const GGS_typeTableVariablesBool   var_cas_inDomainMap,
                                GGS_typeActualArgumentsList  & var_cas_ioActualArgsList,
                                const GGS_location   var_cas_inErrorLocation COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_buildActualArgsList at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  const GGS_typeTableVariablesBool _var_9665 = var_cas_inDomainMap ;
  GGS_typeTableVariablesBool::element_type * operand_9665 = _var_9665.firstObject () ;
  while ((operand_9665 != NULL)) {
    macroValidPointer (operand_9665) ;
    if (operand_9665->mInfo.mVariableDescriptor._isBuilt ()) {
      cPtr_typeDirectVariable * operand_9782 = dynamic_cast <cPtr_typeDirectVariable *> (operand_9665->mInfo.mVariableDescriptor.getPtr ()) ;
      if (operand_9782 != NULL) {
        macroValidPointer (operand_9782) ; 
        var_cas_ioActualArgsList._addAssign_operation (operand_9782->mIndex, operand_9782->mBitSize, operand_9782->mLowBound, operand_9782->mHighBound, var_cas_inErrorLocation) ;
      }else{
        cPtr_typeRecordVariable * operand_9981 = dynamic_cast <cPtr_typeRecordVariable *> (operand_9665->mInfo.mVariableDescriptor.getPtr ()) ;
        if (operand_9981 != NULL) {
          macroValidPointer (operand_9981) ; 
          ::routine_buildActualArgsList (_inLexique,  operand_9981->mMap,  var_cas_ioActualArgsList,  var_cas_inErrorLocation COMMA_SOURCE_FILE_AT_LINE (313)) ;
        }else{ // Else part
          var_cas_inErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, (GGS_string (true, "a variable was expected here ; I found "))._operator_concat (operand_9665->mInfo.mVariableDescriptor.reader_variableDescriptorErrorMessage (_inLexique COMMA_SOURCE_FILE_AT_LINE (316))) COMMA_SOURCE_FILE_AT_LINE (317)) ;
        }
      }
    }
    operand_9665 = operand_9665->nextObject () ;
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_buildActualArgsList\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         abstract class 'cPtr_A'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_A::
cPtr_A (LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_A * GGS_A::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_A *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_A *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_A::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_A::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@A:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_A::
_message (void) const {
  return "a @A instance" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_A::
_static_message (void) {
  return "a @A instance" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_A (& typeid (cPtr_A), NULL
, "a @A instance") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                           GALGAS class 'GGS_A'                            *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_A::
GGS_A (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_A GGS_A::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_A _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_A *> (inPointer) != NULL)
      : (typeid (cPtr_A) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_A (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_A),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_A GGS_A::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_A result ;
  macroMyNew (result.mPointer, cPtr_A (THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_A::actualTypeName (void) const {
  return "A" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         abstract class 'cPtr_B'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_B::
cPtr_B (LOCATION_ARGS)
:cPtr_A (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_B * GGS_B::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_B *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_B *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_B::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_B::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@B:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_B::
_message (void) const {
  return "a @B instance" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_B::
_static_message (void) {
  return "a @B instance" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_B (& typeid (cPtr_B), & typeid (cPtr_A), "a @B instance") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                           GALGAS class 'GGS_B'                            *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_B::
GGS_B (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_B GGS_B::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_B _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_B *> (inPointer) != NULL)
      : (typeid (cPtr_B) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_B (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_B),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_B GGS_B::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_B result ;
  macroMyNew (result.mPointer, cPtr_B (THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_B::actualTypeName (void) const {
  return "B" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         abstract class 'cPtr_C'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_C::
cPtr_C (LOCATION_ARGS)
:cPtr_B (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_C * GGS_C::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_C *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_C *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_C::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_C::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@C:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_C::
_message (void) const {
  return "a @C instance" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_C::
_static_message (void) {
  return "a @C instance" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_C (& typeid (cPtr_C), & typeid (cPtr_B), "a @C instance") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                           GALGAS class 'GGS_C'                            *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_C::
GGS_C (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_C GGS_C::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_C _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_C *> (inPointer) != NULL)
      : (typeid (cPtr_C) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_C (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_C),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_C GGS_C::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_C result ;
  macroMyNew (result.mPointer, cPtr_C (THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_C::actualTypeName (void) const {
  return "C" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         abstract class 'cPtr_D'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_D::
cPtr_D (LOCATION_ARGS)
:cPtr_C (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_D * GGS_D::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_D *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_D *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_D::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_D::
appendForDescription (C_Compiler & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@D:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_D::
_message (void) const {
  return "a @D instance" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_D::
_static_message (void) {
  return "a @D instance" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_D (& typeid (cPtr_D), & typeid (cPtr_C), "a @D instance") ;
//---------------------------------------------------------------------------*
//                                                                           *
//                           GALGAS class 'GGS_D'                            *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_D::
GGS_D (cPtr__AC_galgas_class * inPointer) {
  macroAssignPointer (mPointer, inPointer) ;
}

//---------------------------------------------------------------------------*

//--- _castFrom class method (implements cast expression)
GGS_D GGS_D::
_castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_D _result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_D *> (inPointer) != NULL)
      : (typeid (cPtr_D) == typeid (*inPointer)) ;
    if (ok) {
      _result = GGS_D (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_D),
                                       inUseKindOfClass,
                                       inPointer->_message ()
                                       COMMA_THERE) ;
    }
  }
  return _result ;
}

//---------------------------------------------------------------------------*

GGS_D GGS_D::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_D result ;
  macroMyNew (result.mPointer, cPtr_D (THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_D::actualTypeName (void) const {
  return "D" ;
}

//---------------------------------------------------------------------------*

