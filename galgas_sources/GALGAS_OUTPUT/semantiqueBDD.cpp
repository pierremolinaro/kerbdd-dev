//---------------------------------------------------------------------------*
//                                                                           *
//                         File 'semantiqueBDD.cpp'                          *
//                 Generated by version GALGAS_BETA_VERSION                  *
//                       may 8th, 2010, at 21h43'53"                         *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

//---------------------------------------------------------------------------*

#include "version_libpm.h"
#if CURRENT_LIBPM_VERSION != VERSION_OF_LIBPM_USED_BY_GALGAS_COMPILER
  #error "This file has been compiled with a version of GALGAS that uses libpm version VERSION_OF_LIBPM_USED_BY_GALGAS_COMPILER, different than the current version (CURRENT_LIBPM_VERSION) of libpm"
#endif

//---------------------------------------------------------------------------*

#include <typeinfo>
#include "utilities/MF_MemoryControl.h"
#include "files/C_TextFileWrite.h"
#include "galgas/C_galgas_CLI_Options.h"
#include "semantiqueBDD.h"

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  #define SOURCE_FILE_AT_LINE(line) "semantiqueBDD.gSemantics", line
  #define COMMA_SOURCE_FILE_AT_LINE(line) , SOURCE_FILE_AT_LINE(line)
#else
  #define SOURCE_FILE_AT_LINE(line) 
  #define COMMA_SOURCE_FILE_AT_LINE(line) 
#endif


//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'cPtr_typeDomain'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeDomain::
cPtr_typeDomain (LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeDomain * GGS_typeDomain::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeDomain) ;
    return (cPtr_typeDomain *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_typeDomain::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@typeDomain:" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeDomain::
static_string_message_messageDomainType (void) {
  return "any domain" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeDomain::
message_messageDomainType (void) const {
  return "any domain" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeDomain::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeDomain::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeDomain (& typeid (cPtr_typeDomain), NULL, "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeDomain::galgasRTTI (void) const {
  return & gClassInfoFor__typeDomain ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_typeDomain'                        *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeDomain ("typeDomain", true, NULL) ;

//---------------------------------------------------------------------------*

GGS_typeDomain::
GGS_typeDomain (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeDomain::
GGS_typeDomain (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeDomain GGS_typeDomain::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeDomain result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeDomain *> (inPointer) != NULL)
      : (typeid (cPtr_typeDomain) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeDomain (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeDomain),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeDomain::
reader_messageDomainType (C_Compiler & /* inLexique */
                            COMMA_LOCATION_ARGS) const {
  GGS_string result ;
  if (mPointer != NULL) {
    macroValidObjectThere (mPointer, cPtr_typeDomain) ;
    cPtr_typeDomain * p = (cPtr_typeDomain *) mPointer ;
    result = GGS_string (true, p->message_messageDomainType ()) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeDomain::actualTypeName (void) const {
  return "typeDomain" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * GGS_typeDomain::galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformationEX * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformationEX gClassInfoFor__typeDomain ("typeDomain", & kTypeDescriptor_GGS_typeDomain) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeDomain::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeDomain * p = NULL ;
    macroMyNew (p, GGS_typeDomain (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeDomain GGS_typeDomain::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeDomain result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeDomain * p = dynamic_cast <const GGS_typeDomain *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeDomain, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeDomain::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeDomain ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_typeDirectDomain'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeDirectDomain::
cPtr_typeDirectDomain (const GGS_luint & argument_0,
                                const GGS_luint & argument_1,
                                const GGS_luint & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeDomain (THERE),
mLowBound (argument_0),
mHighBound (argument_1),
mBitsCount (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeDirectDomain * GGS_typeDirectDomain::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeDirectDomain) ;
    return (cPtr_typeDirectDomain *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeDirectDomain::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeDirectDomain * ptr = dynamic_cast <const cPtr_typeDirectDomain *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mLowBound.operator_isEqual (ptr->mLowBound).boolValue ()
         && mHighBound.operator_isEqual (ptr->mHighBound).boolValue ()
         && mBitsCount.operator_isEqual (ptr->mBitsCount).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeDirectDomain::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeDirectDomain:"
           << mLowBound.reader_description (inIndentation + 1)
           << mHighBound.reader_description (inIndentation + 1)
           << mBitsCount.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeDirectDomain::
static_string_message_messageDomainType (void) {
  return "an interval domain" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeDirectDomain::
message_messageDomainType (void) const {
  return "an interval domain" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeDirectDomain::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeDirectDomain::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeDirectDomain (& typeid (cPtr_typeDirectDomain), & typeid (cPtr_typeDomain), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeDirectDomain::galgasRTTI (void) const {
  return & gClassInfoFor__typeDirectDomain ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeDirectDomain::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeDirectDomain (mLowBound, mHighBound, mBitsCount COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeDirectDomain'                     *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeDirectDomain ("typeDirectDomain", true, & kTypeDescriptor_GGS_typeDomain) ;

//---------------------------------------------------------------------------*

GGS_typeDirectDomain::
GGS_typeDirectDomain (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeDirectDomain::
GGS_typeDirectDomain (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeDirectDomain GGS_typeDirectDomain::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeDirectDomain result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeDirectDomain *> (inPointer) != NULL)
      : (typeid (cPtr_typeDirectDomain) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeDirectDomain (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeDirectDomain),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeDirectDomain GGS_typeDirectDomain::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_luint & argument_0,
                 const GGS_luint & argument_1,
                 const GGS_luint & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeDirectDomain result ;
  macroMyNew (result.mPointer, cPtr_typeDirectDomain (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeDirectDomain::
reader_messageDomainType (C_Compiler & /* inLexique */
                            COMMA_LOCATION_ARGS) const {
  GGS_string result ;
  if (mPointer != NULL) {
    macroValidObjectThere (mPointer, cPtr_typeDirectDomain) ;
    cPtr_typeDirectDomain * p = (cPtr_typeDirectDomain *) mPointer ;
    result = GGS_string (true, p->message_messageDomainType ()) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_typeDirectDomain::
reader_mLowBound (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeDirectDomain *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeDirectDomain *) mPointer)->mLowBound ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_typeDirectDomain::
reader_mHighBound (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeDirectDomain *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeDirectDomain *) mPointer)->mHighBound ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_typeDirectDomain::
reader_mBitsCount (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeDirectDomain *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeDirectDomain *) mPointer)->mBitsCount ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeDirectDomain::actualTypeName (void) const {
  return "typeDirectDomain" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeDirectDomain ("typeDirectDomain", gClassInfoFor__typeDomain, & kTypeDescriptor_GGS_typeDirectDomain) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeDirectDomain::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeDirectDomain * p = NULL ;
    macroMyNew (p, GGS_typeDirectDomain (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeDirectDomain GGS_typeDirectDomain::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeDirectDomain result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeDirectDomain * p = dynamic_cast <const GGS_typeDirectDomain *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeDirectDomain, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeDirectDomain::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeDirectDomain ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'e_typeDomainMap'                           *
//                                                                           *
//---------------------------------------------------------------------------*

e_typeDomainMap::e_typeDomainMap (void) :
mDomain () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class map '@typeDomainMap'                         *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeDomainMap ("typeDomainMap", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_typeDomainMap::
elementOf_GGS_typeDomainMap (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_typeDomainMap & inInfo,
              const PMUInt32 inInitialState) :
AC_galgas_map_element (inKey, inIndex, inInitialState),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeDomainMap::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << (mIsDefined ? "" : "(not solved)") ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mDomain.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_typeDomainMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_typeDomainMap * ptr = dynamic_cast <const elementOf_GGS_typeDomainMap *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mDomain.operator_isEqual (ptr->mInfo.mDomain)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_typeDomainMap::
new_element (const GGS_lstring & inKey, void * inInfo, const PMUInt32 inInitialState) {
  MF_Assert (reinterpret_cast <e_typeDomainMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_typeDomainMap * info = (e_typeDomainMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info, inInitialState)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_typeDomainMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_typeDomainMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_typeDomainMap * info = (e_typeDomainMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_typeDomainMap GGS_typeDomainMap::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeDomainMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeDomainMap::
enterIndex (const GGS_string & inKey,
            AC_galgas_index_core & outIndex) {
  e_typeDomainMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeDomainMap::
operator_isEqual (const GGS_typeDomainMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeDomainMap::
operator_isNotEqual (const GGS_typeDomainMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_typeDomainMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation, p->mIsDefined, p->mCurrentState) ;
}

//---------------------------------------------------------------------------*

void GGS_typeDomainMap::
insertElement (C_Compiler & inLexique,
               const PMUInt32 inInitialState,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_typeDomain & inParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap (THERE) ;
    e_typeDomainMap info  ;
    info.mDomain = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation, true, inInitialState) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeDomainMap::
searchElement (C_Compiler & inLexique,
               const PMUInt32 /* inActionIndex */,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_typeDomain   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      inLexique.semanticErrorUsingPerCentK (inKey.string (), inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
    }
  }else{
    outParameter0 = node->mInfo.mDomain ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_typeDomainMap::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('o'),
  TO_UNICODE ('m'),
  TO_UNICODE ('a'),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_typeDomainMap::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_typeDomain   & outParameter0 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 0,
                 kSearchMessage_searchKey,
                 inKey,
                 outParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_typeDomainMap::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('o'),
  TO_UNICODE ('m'),
  TO_UNICODE ('a'),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('h'),
  TO_UNICODE ('a'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('b'),
  TO_UNICODE ('e'),
  TO_UNICODE ('e'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_typeDomainMap::
modifier_insertKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_typeDomain & inParameter0 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 0,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                NULL
                COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_typeDomainMap GGS_typeDomainMap::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_typeDomainMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeDomainMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeDomainMap GGS_typeDomainMap::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeDomainMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeDomainMap::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @typeDomainMap " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_typeDomain  & GGS_typeDomainMap::cEnumerator::_mDomain (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mDomain ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_typeDomainMap::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeDomainMap * p = NULL ;
    macroMyNew (p, GGS_typeDomainMap (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeDomainMap GGS_typeDomainMap::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeDomainMap result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeDomainMap * p = dynamic_cast <const GGS_typeDomainMap *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeDomainMap, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeDomainMap::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeDomainMap ;
}

//--- 'mapWithKeyAndValue' constructor
GGS_typeDomainMap GGS_typeDomainMap::constructor_mapWithKeyAndValue (C_Compiler & inLexique,
                                             const GGS_lstring & inKey,
                                             const GGS_typeDomain & inValue0
                                             COMMA_LOCATION_ARGS) {
  GGS_typeDomainMap result = constructor_emptyMap (inLexique COMMA_THERE) ;
  result.insertElement (inLexique,
                        0,
                        NULL,
                        inKey,
                        inValue0,
                        NULL
                        COMMA_THERE) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_typeRecordDomain'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeRecordDomain::
cPtr_typeRecordDomain (const GGS_typeDomainMap & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_typeDomain (THERE),
mRecordMap (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeRecordDomain * GGS_typeRecordDomain::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeRecordDomain) ;
    return (cPtr_typeRecordDomain *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeRecordDomain::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeRecordDomain * ptr = dynamic_cast <const cPtr_typeRecordDomain *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mRecordMap.operator_isEqual (ptr->mRecordMap).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeRecordDomain::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeRecordDomain:"
           << mRecordMap.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeRecordDomain::
static_string_message_messageDomainType (void) {
  return "a record domain" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeRecordDomain::
message_messageDomainType (void) const {
  return "a record domain" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeRecordDomain::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeRecordDomain::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeRecordDomain (& typeid (cPtr_typeRecordDomain), & typeid (cPtr_typeDomain), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeRecordDomain::galgasRTTI (void) const {
  return & gClassInfoFor__typeRecordDomain ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeRecordDomain::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeRecordDomain (mRecordMap COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeRecordDomain'                     *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeRecordDomain ("typeRecordDomain", true, & kTypeDescriptor_GGS_typeDomain) ;

//---------------------------------------------------------------------------*

GGS_typeRecordDomain::
GGS_typeRecordDomain (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeRecordDomain::
GGS_typeRecordDomain (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeRecordDomain GGS_typeRecordDomain::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeRecordDomain result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeRecordDomain *> (inPointer) != NULL)
      : (typeid (cPtr_typeRecordDomain) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeRecordDomain (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeRecordDomain),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeRecordDomain GGS_typeRecordDomain::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_typeDomainMap & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_typeRecordDomain result ;
  macroMyNew (result.mPointer, cPtr_typeRecordDomain (argument_0 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeRecordDomain::
reader_messageDomainType (C_Compiler & /* inLexique */
                            COMMA_LOCATION_ARGS) const {
  GGS_string result ;
  if (mPointer != NULL) {
    macroValidObjectThere (mPointer, cPtr_typeRecordDomain) ;
    cPtr_typeRecordDomain * p = (cPtr_typeRecordDomain *) mPointer ;
    result = GGS_string (true, p->message_messageDomainType ()) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeDomainMap  GGS_typeRecordDomain::
reader_mRecordMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeDomainMap   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeRecordDomain *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeRecordDomain *) mPointer)->mRecordMap ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeRecordDomain::actualTypeName (void) const {
  return "typeRecordDomain" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeRecordDomain ("typeRecordDomain", gClassInfoFor__typeDomain, & kTypeDescriptor_GGS_typeRecordDomain) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeRecordDomain::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeRecordDomain * p = NULL ;
    macroMyNew (p, GGS_typeRecordDomain (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeRecordDomain GGS_typeRecordDomain::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeRecordDomain result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeRecordDomain * p = dynamic_cast <const GGS_typeRecordDomain *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeRecordDomain, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeRecordDomain::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeRecordDomain ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@typeFormalArgumentsList'                 *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeFormalArgumentsList::
elementOf_GGS_typeFormalArgumentsList (const GGS_luint & argument_0,
                                const GGS_luint & argument_1,
                                const GGS_luint & argument_2,
                                const GGS_luint & argument_3
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mVariableIndex (argument_0),
mVariableBitSize (argument_1),
mLowBound (argument_2),
mHighBound (argument_3) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_typeFormalArgumentsList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_typeFormalArgumentsList * ptr = dynamic_cast <const elementOf_GGS_typeFormalArgumentsList *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mVariableIndex.operator_isEqual (ptr->mVariableIndex).boolValue ()
         && mVariableBitSize.operator_isEqual (ptr->mVariableBitSize).boolValue ()
         && mLowBound.operator_isEqual (ptr->mLowBound).boolValue ()
         && mHighBound.operator_isEqual (ptr->mHighBound).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeFormalArgumentsList::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mVariableIndex.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mVariableBitSize.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLowBound.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mHighBound.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     List '@typeFormalArgumentsList'                       *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeFormalArgumentsList ("typeFormalArgumentsList", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_typeFormalArgumentsList::
internalAppendValues (const GGS_luint & argument_0,
                    const GGS_luint & argument_1,
                    const GGS_luint & argument_2,
                    const GGS_luint & argument_3
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeFormalArgumentsList::
internalPrependValues (const GGS_luint & argument_0,
                    const GGS_luint & argument_1,
                    const GGS_luint & argument_2,
                    const GGS_luint & argument_3
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeFormalArgumentsList::
addAssign_operation (const GGS_luint & argument_0,
                                const GGS_luint & argument_1,
                                const GGS_luint & argument_2,
                                const GGS_luint & argument_3) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()&& argument_2.isBuilt ()&& argument_3.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_typeFormalArgumentsList GGS_typeFormalArgumentsList::
operator_concat (const GGS_typeFormalArgumentsList & inOperand) const {
  GGS_typeFormalArgumentsList result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeFormalArgumentsList::
dotAssign_operation (const GGS_typeFormalArgumentsList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_typeFormalArgumentsList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_luint  p_0 = p->mVariableIndex ;
          GGS_luint  p_1 = p->mVariableBitSize ;
          GGS_luint  p_2 = p->mLowBound ;
          GGS_luint  p_3 = p->mHighBound ;
          internalAppendValues (p_0, p_1, p_2, p_3 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeFormalArgumentsList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_luint & argument_0,
                     const GGS_luint & argument_1,
                     const GGS_luint & argument_2,
                     const GGS_luint & argument_3
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeFormalArgumentsList::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mVariableIndex,
                                ptr->mVariableBitSize,
                                ptr->mLowBound,
                                ptr->mHighBound
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeFormalArgumentsList  GGS_typeFormalArgumentsList::
constructor_emptyList (void) {
  GGS_typeFormalArgumentsList result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeFormalArgumentsList  GGS_typeFormalArgumentsList::
constructor_listWithValue (const GGS_luint & argument_0,
                                const GGS_luint & argument_1,
                                const GGS_luint & argument_2,
                                const GGS_luint & argument_3) {
  GGS_typeFormalArgumentsList result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1, argument_2, argument_3) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeFormalArgumentsList::
internalSubListWithRange (GGS_typeFormalArgumentsList & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mVariableIndex, ptr->mVariableBitSize, ptr->mLowBound, ptr->mHighBound) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeFormalArgumentsList GGS_typeFormalArgumentsList::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_typeFormalArgumentsList result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeFormalArgumentsList GGS_typeFormalArgumentsList::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_typeFormalArgumentsList result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeFormalArgumentsList::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@typeFormalArgumentsList", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_typeFormalArgumentsList::
method_first (C_Compiler & inLexique,
              GGS_luint & _out_0,
              GGS_luint & _out_1,
              GGS_luint & _out_2,
              GGS_luint & _out_3
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mVariableIndex ;
    _out_1 = ptr->mVariableBitSize ;
    _out_2 = ptr->mLowBound ;
    _out_3 = ptr->mHighBound ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeFormalArgumentsList::
method_last (C_Compiler & inLexique,
             GGS_luint & _out_0,
             GGS_luint & _out_1,
             GGS_luint & _out_2,
             GGS_luint & _out_3
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mVariableIndex ;
    _out_1 = ptr->mVariableBitSize ;
    _out_2 = ptr->mLowBound ;
    _out_3 = ptr->mHighBound ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeFormalArgumentsList::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_luint & _out_0,
                 GGS_luint & _out_1,
                 GGS_luint & _out_2,
                 GGS_luint & _out_3
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mVariableIndex ;
    _out_1 = ptr->mVariableBitSize ;
    _out_2 = ptr->mLowBound ;
    _out_3 = ptr->mHighBound ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeFormalArgumentsList::
modifier_popLast (C_Compiler & inLexique,
                GGS_luint & _out_0,
                GGS_luint & _out_1,
                GGS_luint & _out_2,
                GGS_luint & _out_3
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mVariableIndex ;
    _out_1 = ptr->mVariableBitSize ;
    _out_2 = ptr->mLowBound ;
    _out_3 = ptr->mHighBound ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_typeFormalArgumentsList::
reader_mVariableIndexAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_luint  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mVariableIndex ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_typeFormalArgumentsList::
reader_mVariableBitSizeAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_luint  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mVariableBitSize ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_typeFormalArgumentsList::
reader_mLowBoundAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_luint  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mLowBound ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_typeFormalArgumentsList::
reader_mHighBoundAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_luint  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mHighBound ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeFormalArgumentsList::
modifier_setMVariableIndexAtIndex (C_Compiler & inLexique,
                              const GGS_luint  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mVariableIndex = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeFormalArgumentsList::
modifier_setMVariableBitSizeAtIndex (C_Compiler & inLexique,
                              const GGS_luint  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mVariableBitSize = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeFormalArgumentsList::
modifier_setMLowBoundAtIndex (C_Compiler & inLexique,
                              const GGS_luint  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mLowBound = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeFormalArgumentsList::
modifier_setMHighBoundAtIndex (C_Compiler & inLexique,
                              const GGS_luint  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mHighBound = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_luint  & GGS_typeFormalArgumentsList::cEnumerator::_mVariableIndex (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mVariableIndex ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_luint  & GGS_typeFormalArgumentsList::cEnumerator::_mVariableBitSize (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mVariableBitSize ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_luint  & GGS_typeFormalArgumentsList::cEnumerator::_mLowBound (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mLowBound ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_luint  & GGS_typeFormalArgumentsList::cEnumerator::_mHighBound (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mHighBound ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_typeFormalArgumentsList::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeFormalArgumentsList * p = NULL ;
    macroMyNew (p, GGS_typeFormalArgumentsList (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeFormalArgumentsList GGS_typeFormalArgumentsList::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeFormalArgumentsList result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeFormalArgumentsList * p = dynamic_cast <const GGS_typeFormalArgumentsList *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeFormalArgumentsList, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeFormalArgumentsList::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeFormalArgumentsList ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@typeActualArgumentsList'                 *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeActualArgumentsList::
elementOf_GGS_typeActualArgumentsList (const GGS_luint & argument_0,
                                const GGS_luint & argument_1,
                                const GGS_luint & argument_2,
                                const GGS_luint & argument_3,
                                const GGS_location & argument_4
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mVariableIndex (argument_0),
mVariableBitSize (argument_1),
mLowBound (argument_2),
mHighBound (argument_3),
mErrorLocation (argument_4) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_typeActualArgumentsList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_typeActualArgumentsList * ptr = dynamic_cast <const elementOf_GGS_typeActualArgumentsList *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mVariableIndex.operator_isEqual (ptr->mVariableIndex).boolValue ()
         && mVariableBitSize.operator_isEqual (ptr->mVariableBitSize).boolValue ()
         && mLowBound.operator_isEqual (ptr->mLowBound).boolValue ()
         && mHighBound.operator_isEqual (ptr->mHighBound).boolValue ()
         && mErrorLocation.operator_isEqual (ptr->mErrorLocation).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeActualArgumentsList::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mVariableIndex.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mVariableBitSize.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLowBound.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mHighBound.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mErrorLocation.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     List '@typeActualArgumentsList'                       *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeActualArgumentsList ("typeActualArgumentsList", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_typeActualArgumentsList::
internalAppendValues (const GGS_luint & argument_0,
                    const GGS_luint & argument_1,
                    const GGS_luint & argument_2,
                    const GGS_luint & argument_3,
                    const GGS_location & argument_4
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeActualArgumentsList::
internalPrependValues (const GGS_luint & argument_0,
                    const GGS_luint & argument_1,
                    const GGS_luint & argument_2,
                    const GGS_luint & argument_3,
                    const GGS_location & argument_4
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeActualArgumentsList::
addAssign_operation (const GGS_luint & argument_0,
                                const GGS_luint & argument_1,
                                const GGS_luint & argument_2,
                                const GGS_luint & argument_3,
                                const GGS_location & argument_4) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()&& argument_2.isBuilt ()&& argument_3.isBuilt ()&& argument_4.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_typeActualArgumentsList GGS_typeActualArgumentsList::
operator_concat (const GGS_typeActualArgumentsList & inOperand) const {
  GGS_typeActualArgumentsList result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeActualArgumentsList::
dotAssign_operation (const GGS_typeActualArgumentsList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_typeActualArgumentsList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_luint  p_0 = p->mVariableIndex ;
          GGS_luint  p_1 = p->mVariableBitSize ;
          GGS_luint  p_2 = p->mLowBound ;
          GGS_luint  p_3 = p->mHighBound ;
          GGS_location  p_4 = p->mErrorLocation ;
          internalAppendValues (p_0, p_1, p_2, p_3, p_4 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeActualArgumentsList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_luint & argument_0,
                     const GGS_luint & argument_1,
                     const GGS_luint & argument_2,
                     const GGS_luint & argument_3,
                     const GGS_location & argument_4
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeActualArgumentsList::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mVariableIndex,
                                ptr->mVariableBitSize,
                                ptr->mLowBound,
                                ptr->mHighBound,
                                ptr->mErrorLocation
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeActualArgumentsList  GGS_typeActualArgumentsList::
constructor_emptyList (void) {
  GGS_typeActualArgumentsList result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeActualArgumentsList  GGS_typeActualArgumentsList::
constructor_listWithValue (const GGS_luint & argument_0,
                                const GGS_luint & argument_1,
                                const GGS_luint & argument_2,
                                const GGS_luint & argument_3,
                                const GGS_location & argument_4) {
  GGS_typeActualArgumentsList result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1, argument_2, argument_3, argument_4) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeActualArgumentsList::
internalSubListWithRange (GGS_typeActualArgumentsList & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mVariableIndex, ptr->mVariableBitSize, ptr->mLowBound, ptr->mHighBound, ptr->mErrorLocation) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeActualArgumentsList GGS_typeActualArgumentsList::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_typeActualArgumentsList result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeActualArgumentsList GGS_typeActualArgumentsList::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_typeActualArgumentsList result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeActualArgumentsList::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@typeActualArgumentsList", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_typeActualArgumentsList::
method_first (C_Compiler & inLexique,
              GGS_luint & _out_0,
              GGS_luint & _out_1,
              GGS_luint & _out_2,
              GGS_luint & _out_3,
              GGS_location & _out_4
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mVariableIndex ;
    _out_1 = ptr->mVariableBitSize ;
    _out_2 = ptr->mLowBound ;
    _out_3 = ptr->mHighBound ;
    _out_4 = ptr->mErrorLocation ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeActualArgumentsList::
method_last (C_Compiler & inLexique,
             GGS_luint & _out_0,
             GGS_luint & _out_1,
             GGS_luint & _out_2,
             GGS_luint & _out_3,
             GGS_location & _out_4
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mVariableIndex ;
    _out_1 = ptr->mVariableBitSize ;
    _out_2 = ptr->mLowBound ;
    _out_3 = ptr->mHighBound ;
    _out_4 = ptr->mErrorLocation ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeActualArgumentsList::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_luint & _out_0,
                 GGS_luint & _out_1,
                 GGS_luint & _out_2,
                 GGS_luint & _out_3,
                 GGS_location & _out_4
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mVariableIndex ;
    _out_1 = ptr->mVariableBitSize ;
    _out_2 = ptr->mLowBound ;
    _out_3 = ptr->mHighBound ;
    _out_4 = ptr->mErrorLocation ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeActualArgumentsList::
modifier_popLast (C_Compiler & inLexique,
                GGS_luint & _out_0,
                GGS_luint & _out_1,
                GGS_luint & _out_2,
                GGS_luint & _out_3,
                GGS_location & _out_4
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mVariableIndex ;
    _out_1 = ptr->mVariableBitSize ;
    _out_2 = ptr->mLowBound ;
    _out_3 = ptr->mHighBound ;
    _out_4 = ptr->mErrorLocation ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_typeActualArgumentsList::
reader_mVariableIndexAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_luint  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mVariableIndex ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_typeActualArgumentsList::
reader_mVariableBitSizeAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_luint  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mVariableBitSize ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_typeActualArgumentsList::
reader_mLowBoundAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_luint  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mLowBound ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_typeActualArgumentsList::
reader_mHighBoundAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_luint  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mHighBound ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_typeActualArgumentsList::
reader_mErrorLocationAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_location  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mErrorLocation ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeActualArgumentsList::
modifier_setMVariableIndexAtIndex (C_Compiler & inLexique,
                              const GGS_luint  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mVariableIndex = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeActualArgumentsList::
modifier_setMVariableBitSizeAtIndex (C_Compiler & inLexique,
                              const GGS_luint  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mVariableBitSize = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeActualArgumentsList::
modifier_setMLowBoundAtIndex (C_Compiler & inLexique,
                              const GGS_luint  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mLowBound = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeActualArgumentsList::
modifier_setMHighBoundAtIndex (C_Compiler & inLexique,
                              const GGS_luint  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mHighBound = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeActualArgumentsList::
modifier_setMErrorLocationAtIndex (C_Compiler & inLexique,
                              const GGS_location  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mErrorLocation = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_luint  & GGS_typeActualArgumentsList::cEnumerator::_mVariableIndex (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mVariableIndex ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_luint  & GGS_typeActualArgumentsList::cEnumerator::_mVariableBitSize (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mVariableBitSize ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_luint  & GGS_typeActualArgumentsList::cEnumerator::_mLowBound (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mLowBound ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_luint  & GGS_typeActualArgumentsList::cEnumerator::_mHighBound (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mHighBound ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_location  & GGS_typeActualArgumentsList::cEnumerator::_mErrorLocation (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mErrorLocation ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_typeActualArgumentsList::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeActualArgumentsList * p = NULL ;
    macroMyNew (p, GGS_typeActualArgumentsList (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeActualArgumentsList GGS_typeActualArgumentsList::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeActualArgumentsList result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeActualArgumentsList * p = dynamic_cast <const GGS_typeActualArgumentsList *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeActualArgumentsList, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeActualArgumentsList::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeActualArgumentsList ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_typeVariableDescriptor'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeVariableDescriptor::
cPtr_typeVariableDescriptor (LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeVariableDescriptor * GGS_typeVariableDescriptor::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeVariableDescriptor) ;
    return (cPtr_typeVariableDescriptor *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_typeVariableDescriptor::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@typeVariableDescriptor:" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeVariableDescriptor::
static_string_message_variableDescriptorErrorMessage (void) {
  return "any variable" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeVariableDescriptor::
message_variableDescriptorErrorMessage (void) const {
  return "any variable" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeVariableDescriptor::
instanceMessage (void) const {
  return "any variable" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeVariableDescriptor::
_static_message (void) {
  return "any variable" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeVariableDescriptor (& typeid (cPtr_typeVariableDescriptor), NULL, "any variable") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeVariableDescriptor::galgasRTTI (void) const {
  return & gClassInfoFor__typeVariableDescriptor ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_typeVariableDescriptor'                  *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeVariableDescriptor ("typeVariableDescriptor", true, NULL) ;

//---------------------------------------------------------------------------*

GGS_typeVariableDescriptor::
GGS_typeVariableDescriptor (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeVariableDescriptor::
GGS_typeVariableDescriptor (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeVariableDescriptor GGS_typeVariableDescriptor::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeVariableDescriptor result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeVariableDescriptor *> (inPointer) != NULL)
      : (typeid (cPtr_typeVariableDescriptor) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeVariableDescriptor (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeVariableDescriptor),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeVariableDescriptor::
reader_variableDescriptorErrorMessage (C_Compiler & /* inLexique */
                            COMMA_LOCATION_ARGS) const {
  GGS_string result ;
  if (mPointer != NULL) {
    macroValidObjectThere (mPointer, cPtr_typeVariableDescriptor) ;
    cPtr_typeVariableDescriptor * p = (cPtr_typeVariableDescriptor *) mPointer ;
    result = GGS_string (true, p->message_variableDescriptorErrorMessage ()) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeVariableDescriptor::actualTypeName (void) const {
  return "typeVariableDescriptor" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * GGS_typeVariableDescriptor::galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformationEX * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformationEX gClassInfoFor__typeVariableDescriptor ("typeVariableDescriptor", & kTypeDescriptor_GGS_typeVariableDescriptor) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeVariableDescriptor::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeVariableDescriptor * p = NULL ;
    macroMyNew (p, GGS_typeVariableDescriptor (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeVariableDescriptor GGS_typeVariableDescriptor::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeVariableDescriptor result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeVariableDescriptor * p = dynamic_cast <const GGS_typeVariableDescriptor *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeVariableDescriptor, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeVariableDescriptor::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeVariableDescriptor ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_typeDirectVariable'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeDirectVariable::
cPtr_typeDirectVariable (const GGS_luint & argument_0,
                                const GGS_luint & argument_1,
                                const GGS_luint & argument_2,
                                const GGS_luint & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_typeVariableDescriptor (THERE),
mIndex (argument_0),
mBitSize (argument_1),
mLowBound (argument_2),
mHighBound (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeDirectVariable * GGS_typeDirectVariable::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeDirectVariable) ;
    return (cPtr_typeDirectVariable *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeDirectVariable::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeDirectVariable * ptr = dynamic_cast <const cPtr_typeDirectVariable *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mIndex.operator_isEqual (ptr->mIndex).boolValue ()
         && mBitSize.operator_isEqual (ptr->mBitSize).boolValue ()
         && mLowBound.operator_isEqual (ptr->mLowBound).boolValue ()
         && mHighBound.operator_isEqual (ptr->mHighBound).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeDirectVariable::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeDirectVariable:"
           << mIndex.reader_description (inIndentation + 1)
           << mBitSize.reader_description (inIndentation + 1)
           << mLowBound.reader_description (inIndentation + 1)
           << mHighBound.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeDirectVariable::
static_string_message_variableDescriptorErrorMessage (void) {
  return "a direct domain variable" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeDirectVariable::
message_variableDescriptorErrorMessage (void) const {
  return "a direct domain variable" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeDirectVariable::
instanceMessage (void) const {
  return "a direct domain variable" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeDirectVariable::
_static_message (void) {
  return "a direct domain variable" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeDirectVariable (& typeid (cPtr_typeDirectVariable), & typeid (cPtr_typeVariableDescriptor), "a direct domain variable") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeDirectVariable::galgasRTTI (void) const {
  return & gClassInfoFor__typeDirectVariable ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeDirectVariable::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeDirectVariable (mIndex, mBitSize, mLowBound, mHighBound COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeDirectVariable'                    *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeDirectVariable ("typeDirectVariable", true, & kTypeDescriptor_GGS_typeVariableDescriptor) ;

//---------------------------------------------------------------------------*

GGS_typeDirectVariable::
GGS_typeDirectVariable (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeDirectVariable::
GGS_typeDirectVariable (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeDirectVariable GGS_typeDirectVariable::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeDirectVariable result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeDirectVariable *> (inPointer) != NULL)
      : (typeid (cPtr_typeDirectVariable) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeDirectVariable (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeDirectVariable),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeDirectVariable GGS_typeDirectVariable::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_luint & argument_0,
                 const GGS_luint & argument_1,
                 const GGS_luint & argument_2,
                 const GGS_luint & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_typeDirectVariable result ;
  macroMyNew (result.mPointer, cPtr_typeDirectVariable (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeDirectVariable::
reader_variableDescriptorErrorMessage (C_Compiler & /* inLexique */
                            COMMA_LOCATION_ARGS) const {
  GGS_string result ;
  if (mPointer != NULL) {
    macroValidObjectThere (mPointer, cPtr_typeDirectVariable) ;
    cPtr_typeDirectVariable * p = (cPtr_typeDirectVariable *) mPointer ;
    result = GGS_string (true, p->message_variableDescriptorErrorMessage ()) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_typeDirectVariable::
reader_mIndex (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeDirectVariable *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeDirectVariable *) mPointer)->mIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_typeDirectVariable::
reader_mBitSize (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeDirectVariable *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeDirectVariable *) mPointer)->mBitSize ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_typeDirectVariable::
reader_mLowBound (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeDirectVariable *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeDirectVariable *) mPointer)->mLowBound ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_typeDirectVariable::
reader_mHighBound (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeDirectVariable *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeDirectVariable *) mPointer)->mHighBound ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeDirectVariable::actualTypeName (void) const {
  return "typeDirectVariable" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeDirectVariable ("typeDirectVariable", gClassInfoFor__typeVariableDescriptor, & kTypeDescriptor_GGS_typeDirectVariable) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeDirectVariable::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeDirectVariable * p = NULL ;
    macroMyNew (p, GGS_typeDirectVariable (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeDirectVariable GGS_typeDirectVariable::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeDirectVariable result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeDirectVariable * p = dynamic_cast <const GGS_typeDirectVariable *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeDirectVariable, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeDirectVariable::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeDirectVariable ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'e_typeTableVariablesBool'                      *
//                                                                           *
//---------------------------------------------------------------------------*

e_typeTableVariablesBool::e_typeTableVariablesBool (void) :
mVariableDescriptor () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class map '@typeTableVariablesBool'                     *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeTableVariablesBool ("typeTableVariablesBool", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_typeTableVariablesBool::
elementOf_GGS_typeTableVariablesBool (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_typeTableVariablesBool & inInfo,
              const PMUInt32 inInitialState) :
AC_galgas_map_element (inKey, inIndex, inInitialState),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeTableVariablesBool::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << (mIsDefined ? "" : "(not solved)") ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mVariableDescriptor.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_typeTableVariablesBool::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_typeTableVariablesBool * ptr = dynamic_cast <const elementOf_GGS_typeTableVariablesBool *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mVariableDescriptor.operator_isEqual (ptr->mInfo.mVariableDescriptor)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_typeTableVariablesBool::
new_element (const GGS_lstring & inKey, void * inInfo, const PMUInt32 inInitialState) {
  MF_Assert (reinterpret_cast <e_typeTableVariablesBool *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_typeTableVariablesBool * info = (e_typeTableVariablesBool *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info, inInitialState)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableVariablesBool::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_typeTableVariablesBool *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_typeTableVariablesBool * info = (e_typeTableVariablesBool *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_typeTableVariablesBool GGS_typeTableVariablesBool::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeTableVariablesBool result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableVariablesBool::
enterIndex (const GGS_string & inKey,
            AC_galgas_index_core & outIndex) {
  e_typeTableVariablesBool info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeTableVariablesBool::
operator_isEqual (const GGS_typeTableVariablesBool & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeTableVariablesBool::
operator_isNotEqual (const GGS_typeTableVariablesBool & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableVariablesBool::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation, p->mIsDefined, p->mCurrentState) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableVariablesBool::
insertElement (C_Compiler & inLexique,
               const PMUInt32 inInitialState,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_typeVariableDescriptor & inParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap (THERE) ;
    e_typeTableVariablesBool info  ;
    info.mVariableDescriptor = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation, true, inInitialState) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTableVariablesBool::
searchElement (C_Compiler & inLexique,
               const PMUInt32 /* inActionIndex */,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_typeVariableDescriptor   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      inLexique.semanticErrorUsingPerCentK (inKey.string (), inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
    }
  }else{
    outParameter0 = node->mInfo.mVariableDescriptor ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_typeTableVariablesBool::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('v'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('i'),
  TO_UNICODE ('a'),
  TO_UNICODE ('b'),
  TO_UNICODE ('l'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_typeTableVariablesBool::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_typeVariableDescriptor   & outParameter0 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 0,
                 kSearchMessage_searchKey,
                 inKey,
                 outParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_typeTableVariablesBool::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('v'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('i'),
  TO_UNICODE ('a'),
  TO_UNICODE ('b'),
  TO_UNICODE ('l'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('h'),
  TO_UNICODE ('a'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('b'),
  TO_UNICODE ('e'),
  TO_UNICODE ('e'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_typeTableVariablesBool::
modifier_insertKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_typeVariableDescriptor & inParameter0 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 0,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                NULL
                COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_typeTableVariablesBool GGS_typeTableVariablesBool::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_typeTableVariablesBool & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeTableVariablesBool result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeTableVariablesBool GGS_typeTableVariablesBool::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeTableVariablesBool result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeTableVariablesBool::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @typeTableVariablesBool " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_typeVariableDescriptor  & GGS_typeTableVariablesBool::cEnumerator::_mVariableDescriptor (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mVariableDescriptor ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_typeTableVariablesBool::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeTableVariablesBool * p = NULL ;
    macroMyNew (p, GGS_typeTableVariablesBool (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeTableVariablesBool GGS_typeTableVariablesBool::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeTableVariablesBool result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeTableVariablesBool * p = dynamic_cast <const GGS_typeTableVariablesBool *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeTableVariablesBool, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeTableVariablesBool::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeTableVariablesBool ;
}

//--- 'mapWithKeyAndValue' constructor
GGS_typeTableVariablesBool GGS_typeTableVariablesBool::constructor_mapWithKeyAndValue (C_Compiler & inLexique,
                                             const GGS_lstring & inKey,
                                             const GGS_typeVariableDescriptor & inValue0
                                             COMMA_LOCATION_ARGS) {
  GGS_typeTableVariablesBool result = constructor_emptyMap (inLexique COMMA_THERE) ;
  result.insertElement (inLexique,
                        0,
                        NULL,
                        inKey,
                        inValue0,
                        NULL
                        COMMA_THERE) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_typeRecordVariable'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeRecordVariable::
cPtr_typeRecordVariable (const GGS_typeTableVariablesBool & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_typeVariableDescriptor (THERE),
mMap (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeRecordVariable * GGS_typeRecordVariable::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeRecordVariable) ;
    return (cPtr_typeRecordVariable *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeRecordVariable::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeRecordVariable * ptr = dynamic_cast <const cPtr_typeRecordVariable *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mMap.operator_isEqual (ptr->mMap).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeRecordVariable::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeRecordVariable:"
           << mMap.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeRecordVariable::
static_string_message_variableDescriptorErrorMessage (void) {
  return "a record domain variable" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeRecordVariable::
message_variableDescriptorErrorMessage (void) const {
  return "a record domain variable" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeRecordVariable::
instanceMessage (void) const {
  return "a record domain variable" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeRecordVariable::
_static_message (void) {
  return "a record domain variable" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeRecordVariable (& typeid (cPtr_typeRecordVariable), & typeid (cPtr_typeVariableDescriptor), "a record domain variable") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeRecordVariable::galgasRTTI (void) const {
  return & gClassInfoFor__typeRecordVariable ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeRecordVariable::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeRecordVariable (mMap COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeRecordVariable'                    *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeRecordVariable ("typeRecordVariable", true, & kTypeDescriptor_GGS_typeVariableDescriptor) ;

//---------------------------------------------------------------------------*

GGS_typeRecordVariable::
GGS_typeRecordVariable (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeRecordVariable::
GGS_typeRecordVariable (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeRecordVariable GGS_typeRecordVariable::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeRecordVariable result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeRecordVariable *> (inPointer) != NULL)
      : (typeid (cPtr_typeRecordVariable) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeRecordVariable (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeRecordVariable),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeRecordVariable GGS_typeRecordVariable::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_typeTableVariablesBool & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_typeRecordVariable result ;
  macroMyNew (result.mPointer, cPtr_typeRecordVariable (argument_0 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeRecordVariable::
reader_variableDescriptorErrorMessage (C_Compiler & /* inLexique */
                            COMMA_LOCATION_ARGS) const {
  GGS_string result ;
  if (mPointer != NULL) {
    macroValidObjectThere (mPointer, cPtr_typeRecordVariable) ;
    cPtr_typeRecordVariable * p = (cPtr_typeRecordVariable *) mPointer ;
    result = GGS_string (true, p->message_variableDescriptorErrorMessage ()) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeTableVariablesBool  GGS_typeRecordVariable::
reader_mMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeTableVariablesBool   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeRecordVariable *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeRecordVariable *) mPointer)->mMap ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeRecordVariable::actualTypeName (void) const {
  return "typeRecordVariable" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeRecordVariable ("typeRecordVariable", gClassInfoFor__typeVariableDescriptor, & kTypeDescriptor_GGS_typeRecordVariable) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeRecordVariable::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeRecordVariable * p = NULL ;
    macroMyNew (p, GGS_typeRecordVariable (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeRecordVariable GGS_typeRecordVariable::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeRecordVariable result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeRecordVariable * p = dynamic_cast <const GGS_typeRecordVariable *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeRecordVariable, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeRecordVariable::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeRecordVariable ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'e_typeTableFormules'                         *
//                                                                           *
//---------------------------------------------------------------------------*

e_typeTableFormules::e_typeTableFormules (void) :
mIndex (),
aListeArgsFormelsBool (),
aBDD () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class map '@typeTableFormules'                       *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeTableFormules ("typeTableFormules", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_typeTableFormules::
elementOf_GGS_typeTableFormules (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_typeTableFormules & inInfo,
              const PMUInt32 inInitialState) :
AC_galgas_map_element (inKey, inIndex, inInitialState),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeTableFormules::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << (mIsDefined ? "" : "(not solved)") ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mIndex.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.aListeArgsFormelsBool.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.aBDD.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_typeTableFormules::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_typeTableFormules * ptr = dynamic_cast <const elementOf_GGS_typeTableFormules *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mIndex.operator_isEqual (ptr->mInfo.mIndex)).boolValue ()
           && (mInfo.aListeArgsFormelsBool.operator_isEqual (ptr->mInfo.aListeArgsFormelsBool)).boolValue ()
           && (mInfo.aBDD.operator_isEqual (ptr->mInfo.aBDD)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_typeTableFormules::
new_element (const GGS_lstring & inKey, void * inInfo, const PMUInt32 inInitialState) {
  MF_Assert (reinterpret_cast <e_typeTableFormules *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_typeTableFormules * info = (e_typeTableFormules *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info, inInitialState)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableFormules::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_typeTableFormules *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_typeTableFormules * info = (e_typeTableFormules *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_typeTableFormules GGS_typeTableFormules::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeTableFormules result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableFormules::
enterIndex (const GGS_string & inKey,
            AC_galgas_index_core & outIndex) {
  e_typeTableFormules info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeTableFormules::
operator_isEqual (const GGS_typeTableFormules & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeTableFormules::
operator_isNotEqual (const GGS_typeTableFormules & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableFormules::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation, p->mIsDefined, p->mCurrentState) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableFormules::
insertElement (C_Compiler & inLexique,
               const PMUInt32 inInitialState,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_uint & inParameter0,
               const GGS_typeFormalArgumentsList & inParameter1,
               const GGS_extern_bdd& inParameter2,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inParameter1.isBuilt ()
   && inParameter2.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap (THERE) ;
    e_typeTableFormules info  ;
    info.mIndex = inParameter0 ;
    info.aListeArgsFormelsBool = inParameter1 ;
    info.aBDD = inParameter2 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation, true, inInitialState) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTableFormules::
searchElement (C_Compiler & inLexique,
               const PMUInt32 /* inActionIndex */,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_uint   & outParameter0,
               GGS_typeFormalArgumentsList   & outParameter1,
               GGS_extern_bdd  & outParameter2,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      inLexique.semanticErrorUsingPerCentK (inKey.string (), inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    outParameter1.drop () ;
    outParameter2.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
    }
  }else{
    outParameter0 = node->mInfo.mIndex ;
    outParameter1 = node->mInfo.aListeArgsFormelsBool ;
    outParameter2 = node->mInfo.aBDD ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_typeTableFormules::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('#'),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('f'),
  TO_UNICODE ('o'),
  TO_UNICODE ('r'),
  TO_UNICODE ('m'),
  TO_UNICODE ('u'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('f'),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_typeTableFormules::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_uint   & outParameter0,
                                GGS_typeFormalArgumentsList   & outParameter1,
                                GGS_extern_bdd  & outParameter2 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 0,
                 kSearchMessage_searchKey,
                 inKey,
                 outParameter0,
                 outParameter1,
                 outParameter2,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_typeTableFormules::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('#'),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('f'),
  TO_UNICODE ('o'),
  TO_UNICODE ('r'),
  TO_UNICODE ('m'),
  TO_UNICODE ('u'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('f'),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_typeTableFormules::
modifier_insertKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_uint & inParameter0,
                                const GGS_typeFormalArgumentsList & inParameter1,
                                const GGS_extern_bdd& inParameter2 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 0,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                 inParameter1,
                 inParameter2,
                NULL
                COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_typeTableFormules GGS_typeTableFormules::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_typeTableFormules & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeTableFormules result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeTableFormules GGS_typeTableFormules::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeTableFormules result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeTableFormules::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @typeTableFormules " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_uint  & GGS_typeTableFormules::cEnumerator::_mIndex (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mIndex ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_typeFormalArgumentsList  & GGS_typeTableFormules::cEnumerator::_aListeArgsFormelsBool (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.aListeArgsFormelsBool ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_extern_bdd & GGS_typeTableFormules::cEnumerator::_aBDD (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.aBDD ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_typeTableFormules::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeTableFormules * p = NULL ;
    macroMyNew (p, GGS_typeTableFormules (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeTableFormules GGS_typeTableFormules::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeTableFormules result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeTableFormules * p = dynamic_cast <const GGS_typeTableFormules *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeTableFormules, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeTableFormules::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeTableFormules ;
}

//--- 'mapWithKeyAndValue' constructor
GGS_typeTableFormules GGS_typeTableFormules::constructor_mapWithKeyAndValue (C_Compiler & inLexique,
                                             const GGS_lstring & inKey,
                                             const GGS_uint & inValue0,
                                             const GGS_typeFormalArgumentsList & inValue1,
                                             const GGS_extern_bdd& inValue2
                                             COMMA_LOCATION_ARGS) {
  GGS_typeTableFormules result = constructor_emptyMap (inLexique COMMA_THERE) ;
  result.insertElement (inLexique,
                        0,
                        NULL,
                        inKey,
                        inValue0,
                        inValue1,
                        inValue2,
                        NULL
                        COMMA_THERE) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'cPtr_typeFormule'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeFormule::
cPtr_typeFormule (LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeFormule * GGS_typeFormule::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeFormule) ;
    return (cPtr_typeFormule *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_typeFormule::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@typeFormule:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeFormule::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeFormule::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeFormule (& typeid (cPtr_typeFormule), NULL, "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeFormule::galgasRTTI (void) const {
  return & gClassInfoFor__typeFormule ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_typeFormule'                       *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeFormule ("typeFormule", true, NULL) ;

//---------------------------------------------------------------------------*

GGS_typeFormule::
GGS_typeFormule (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeFormule::
GGS_typeFormule (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeFormule GGS_typeFormule::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeFormule result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeFormule *> (inPointer) != NULL)
      : (typeid (cPtr_typeFormule) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeFormule (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeFormule),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeFormule::actualTypeName (void) const {
  return "typeFormule" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * GGS_typeFormule::galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformationEX * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformationEX gClassInfoFor__typeFormule ("typeFormule", & kTypeDescriptor_GGS_typeFormule) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeFormule::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeFormule * p = NULL ;
    macroMyNew (p, GGS_typeFormule (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeFormule GGS_typeFormule::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeFormule result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeFormule * p = dynamic_cast <const GGS_typeFormule *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeFormule, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeFormule::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeFormule ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_typeFormuleTrue'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeFormuleTrue::
cPtr_typeFormuleTrue (LOCATION_ARGS)
:cPtr_typeFormule (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeFormuleTrue * GGS_typeFormuleTrue::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeFormuleTrue) ;
    return (cPtr_typeFormuleTrue *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeFormuleTrue::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeFormuleTrue::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@typeFormuleTrue:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeFormuleTrue::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeFormuleTrue::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeFormuleTrue (& typeid (cPtr_typeFormuleTrue), & typeid (cPtr_typeFormule), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeFormuleTrue::galgasRTTI (void) const {
  return & gClassInfoFor__typeFormuleTrue ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeFormuleTrue'                     *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeFormuleTrue ("typeFormuleTrue", true, & kTypeDescriptor_GGS_typeFormule) ;

//---------------------------------------------------------------------------*

GGS_typeFormuleTrue::
GGS_typeFormuleTrue (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeFormuleTrue::
GGS_typeFormuleTrue (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeFormuleTrue GGS_typeFormuleTrue::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeFormuleTrue result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeFormuleTrue *> (inPointer) != NULL)
      : (typeid (cPtr_typeFormuleTrue) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeFormuleTrue (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeFormuleTrue),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

static cPtr_typeFormuleTrue * gSingleton_typeFormuleTrue = NULL ;

//---------------------------------------------------------------------------*

GGS_typeFormuleTrue GGS_typeFormuleTrue::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_typeFormuleTrue result ;
  if (NULL == gSingleton_typeFormuleTrue) {
    macroMyNew (gSingleton_typeFormuleTrue, cPtr_typeFormuleTrue (THERE)) ;
    macroRetainObject (gSingleton_typeFormuleTrue) ;
  }
  macroAssignObject (result.mPointer, gSingleton_typeFormuleTrue) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeFormuleTrue::actualTypeName (void) const {
  return "typeFormuleTrue" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeFormuleTrue ("typeFormuleTrue", gClassInfoFor__typeFormule, & kTypeDescriptor_GGS_typeFormuleTrue) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeFormuleTrue::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeFormuleTrue * p = NULL ;
    macroMyNew (p, GGS_typeFormuleTrue (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeFormuleTrue GGS_typeFormuleTrue::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeFormuleTrue result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeFormuleTrue * p = dynamic_cast <const GGS_typeFormuleTrue *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeFormuleTrue, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeFormuleTrue::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeFormuleTrue ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_typeFormuleFalse'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeFormuleFalse::
cPtr_typeFormuleFalse (LOCATION_ARGS)
:cPtr_typeFormule (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeFormuleFalse * GGS_typeFormuleFalse::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeFormuleFalse) ;
    return (cPtr_typeFormuleFalse *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeFormuleFalse::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeFormuleFalse::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@typeFormuleFalse:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeFormuleFalse::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeFormuleFalse::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeFormuleFalse (& typeid (cPtr_typeFormuleFalse), & typeid (cPtr_typeFormule), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeFormuleFalse::galgasRTTI (void) const {
  return & gClassInfoFor__typeFormuleFalse ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeFormuleFalse'                     *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeFormuleFalse ("typeFormuleFalse", true, & kTypeDescriptor_GGS_typeFormule) ;

//---------------------------------------------------------------------------*

GGS_typeFormuleFalse::
GGS_typeFormuleFalse (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeFormuleFalse::
GGS_typeFormuleFalse (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeFormuleFalse GGS_typeFormuleFalse::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeFormuleFalse result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeFormuleFalse *> (inPointer) != NULL)
      : (typeid (cPtr_typeFormuleFalse) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeFormuleFalse (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeFormuleFalse),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

static cPtr_typeFormuleFalse * gSingleton_typeFormuleFalse = NULL ;

//---------------------------------------------------------------------------*

GGS_typeFormuleFalse GGS_typeFormuleFalse::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_typeFormuleFalse result ;
  if (NULL == gSingleton_typeFormuleFalse) {
    macroMyNew (gSingleton_typeFormuleFalse, cPtr_typeFormuleFalse (THERE)) ;
    macroRetainObject (gSingleton_typeFormuleFalse) ;
  }
  macroAssignObject (result.mPointer, gSingleton_typeFormuleFalse) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeFormuleFalse::actualTypeName (void) const {
  return "typeFormuleFalse" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeFormuleFalse ("typeFormuleFalse", gClassInfoFor__typeFormule, & kTypeDescriptor_GGS_typeFormuleFalse) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeFormuleFalse::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeFormuleFalse * p = NULL ;
    macroMyNew (p, GGS_typeFormuleFalse (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeFormuleFalse GGS_typeFormuleFalse::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeFormuleFalse result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeFormuleFalse * p = dynamic_cast <const GGS_typeFormuleFalse *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeFormuleFalse, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeFormuleFalse::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeFormuleFalse ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_typeFormuleVar'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeFormuleVar::
cPtr_typeFormuleVar (const GGS_luint & argument_0,
                                const GGS_luint & argument_1,
                                const GGS_luint & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeFormule (THERE),
mNumeroVariable (argument_0),
mLowBound (argument_1),
mHighBound (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeFormuleVar * GGS_typeFormuleVar::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeFormuleVar) ;
    return (cPtr_typeFormuleVar *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeFormuleVar::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeFormuleVar * ptr = dynamic_cast <const cPtr_typeFormuleVar *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mNumeroVariable.operator_isEqual (ptr->mNumeroVariable).boolValue ()
         && mLowBound.operator_isEqual (ptr->mLowBound).boolValue ()
         && mHighBound.operator_isEqual (ptr->mHighBound).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeFormuleVar::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeFormuleVar:"
           << mNumeroVariable.reader_description (inIndentation + 1)
           << mLowBound.reader_description (inIndentation + 1)
           << mHighBound.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeFormuleVar::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeFormuleVar::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeFormuleVar (& typeid (cPtr_typeFormuleVar), & typeid (cPtr_typeFormule), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeFormuleVar::galgasRTTI (void) const {
  return & gClassInfoFor__typeFormuleVar ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeFormuleVar::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeFormuleVar (mNumeroVariable, mLowBound, mHighBound COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeFormuleVar'                      *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeFormuleVar ("typeFormuleVar", true, & kTypeDescriptor_GGS_typeFormule) ;

//---------------------------------------------------------------------------*

GGS_typeFormuleVar::
GGS_typeFormuleVar (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeFormuleVar::
GGS_typeFormuleVar (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeFormuleVar GGS_typeFormuleVar::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeFormuleVar result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeFormuleVar *> (inPointer) != NULL)
      : (typeid (cPtr_typeFormuleVar) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeFormuleVar (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeFormuleVar),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeFormuleVar GGS_typeFormuleVar::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_luint & argument_0,
                 const GGS_luint & argument_1,
                 const GGS_luint & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeFormuleVar result ;
  macroMyNew (result.mPointer, cPtr_typeFormuleVar (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_typeFormuleVar::
reader_mNumeroVariable (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFormuleVar *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeFormuleVar *) mPointer)->mNumeroVariable ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_typeFormuleVar::
reader_mLowBound (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFormuleVar *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeFormuleVar *) mPointer)->mLowBound ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_typeFormuleVar::
reader_mHighBound (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFormuleVar *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeFormuleVar *) mPointer)->mHighBound ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeFormuleVar::actualTypeName (void) const {
  return "typeFormuleVar" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeFormuleVar ("typeFormuleVar", gClassInfoFor__typeFormule, & kTypeDescriptor_GGS_typeFormuleVar) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeFormuleVar::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeFormuleVar * p = NULL ;
    macroMyNew (p, GGS_typeFormuleVar (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeFormuleVar GGS_typeFormuleVar::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeFormuleVar result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeFormuleVar * p = dynamic_cast <const GGS_typeFormuleVar *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeFormuleVar, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeFormuleVar::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeFormuleVar ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_typeFormuleFor'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeFormuleFor::
cPtr_typeFormuleFor (const GGS_uint & argument_0,
                                const GGS_typeActualArgumentsList & argument_1,
                                const GGS_extern_bdd& argument_2,
                                const GGS_lbool & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_typeFormule (THERE),
mNumeroFormule (argument_0),
mListeArgsBool (argument_1),
mFormuleTraduite (argument_2),
mEstFormuleCourante (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeFormuleFor * GGS_typeFormuleFor::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeFormuleFor) ;
    return (cPtr_typeFormuleFor *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeFormuleFor::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeFormuleFor * ptr = dynamic_cast <const cPtr_typeFormuleFor *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mNumeroFormule.operator_isEqual (ptr->mNumeroFormule).boolValue ()
         && mListeArgsBool.operator_isEqual (ptr->mListeArgsBool).boolValue ()
         && mFormuleTraduite.operator_isEqual (ptr->mFormuleTraduite).boolValue ()
         && mEstFormuleCourante.operator_isEqual (ptr->mEstFormuleCourante).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeFormuleFor::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeFormuleFor:"
           << mNumeroFormule.reader_description (inIndentation + 1)
           << mListeArgsBool.reader_description (inIndentation + 1)
           << mFormuleTraduite.reader_description (inIndentation + 1)
           << mEstFormuleCourante.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeFormuleFor::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeFormuleFor::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeFormuleFor (& typeid (cPtr_typeFormuleFor), & typeid (cPtr_typeFormule), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeFormuleFor::galgasRTTI (void) const {
  return & gClassInfoFor__typeFormuleFor ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeFormuleFor::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeFormuleFor (mNumeroFormule, mListeArgsBool, mFormuleTraduite, mEstFormuleCourante COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeFormuleFor'                      *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeFormuleFor ("typeFormuleFor", true, & kTypeDescriptor_GGS_typeFormule) ;

//---------------------------------------------------------------------------*

GGS_typeFormuleFor::
GGS_typeFormuleFor (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeFormuleFor::
GGS_typeFormuleFor (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeFormuleFor GGS_typeFormuleFor::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeFormuleFor result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeFormuleFor *> (inPointer) != NULL)
      : (typeid (cPtr_typeFormuleFor) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeFormuleFor (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeFormuleFor),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeFormuleFor GGS_typeFormuleFor::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_uint & argument_0,
                 const GGS_typeActualArgumentsList & argument_1,
                 const GGS_extern_bdd& argument_2,
                 const GGS_lbool & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_typeFormuleFor result ;
  macroMyNew (result.mPointer, cPtr_typeFormuleFor (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint  GGS_typeFormuleFor::
reader_mNumeroFormule (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_uint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFormuleFor *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeFormuleFor *) mPointer)->mNumeroFormule ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeActualArgumentsList  GGS_typeFormuleFor::
reader_mListeArgsBool (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeActualArgumentsList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFormuleFor *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeFormuleFor *) mPointer)->mListeArgsBool ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_extern_bdd GGS_typeFormuleFor::
reader_mFormuleTraduite (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_extern_bdd  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFormuleFor *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeFormuleFor *) mPointer)->mFormuleTraduite ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lbool  GGS_typeFormuleFor::
reader_mEstFormuleCourante (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lbool   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFormuleFor *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeFormuleFor *) mPointer)->mEstFormuleCourante ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeFormuleFor::actualTypeName (void) const {
  return "typeFormuleFor" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeFormuleFor ("typeFormuleFor", gClassInfoFor__typeFormule, & kTypeDescriptor_GGS_typeFormuleFor) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeFormuleFor::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeFormuleFor * p = NULL ;
    macroMyNew (p, GGS_typeFormuleFor (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeFormuleFor GGS_typeFormuleFor::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeFormuleFor result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeFormuleFor * p = dynamic_cast <const GGS_typeFormuleFor *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeFormuleFor, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeFormuleFor::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeFormuleFor ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_typeFormuleNon'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeFormuleNon::
cPtr_typeFormuleNon (const GGS_typeFormule & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_typeFormule (THERE),
mOperand (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeFormuleNon * GGS_typeFormuleNon::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeFormuleNon) ;
    return (cPtr_typeFormuleNon *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeFormuleNon::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeFormuleNon * ptr = dynamic_cast <const cPtr_typeFormuleNon *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOperand.operator_isEqual (ptr->mOperand).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeFormuleNon::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeFormuleNon:"
           << mOperand.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeFormuleNon::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeFormuleNon::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeFormuleNon (& typeid (cPtr_typeFormuleNon), & typeid (cPtr_typeFormule), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeFormuleNon::galgasRTTI (void) const {
  return & gClassInfoFor__typeFormuleNon ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeFormuleNon::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeFormuleNon (mOperand COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeFormuleNon'                      *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeFormuleNon ("typeFormuleNon", true, & kTypeDescriptor_GGS_typeFormule) ;

//---------------------------------------------------------------------------*

GGS_typeFormuleNon::
GGS_typeFormuleNon (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeFormuleNon::
GGS_typeFormuleNon (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeFormuleNon GGS_typeFormuleNon::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeFormuleNon result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeFormuleNon *> (inPointer) != NULL)
      : (typeid (cPtr_typeFormuleNon) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeFormuleNon (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeFormuleNon),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeFormuleNon GGS_typeFormuleNon::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_typeFormule & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_typeFormuleNon result ;
  macroMyNew (result.mPointer, cPtr_typeFormuleNon (argument_0 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeFormule  GGS_typeFormuleNon::
reader_mOperand (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeFormule   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFormuleNon *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeFormuleNon *) mPointer)->mOperand ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeFormuleNon::actualTypeName (void) const {
  return "typeFormuleNon" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeFormuleNon ("typeFormuleNon", gClassInfoFor__typeFormule, & kTypeDescriptor_GGS_typeFormuleNon) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeFormuleNon::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeFormuleNon * p = NULL ;
    macroMyNew (p, GGS_typeFormuleNon (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeFormuleNon GGS_typeFormuleNon::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeFormuleNon result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeFormuleNon * p = dynamic_cast <const GGS_typeFormuleNon *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeFormuleNon, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeFormuleNon::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeFormuleNon ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'cPtr_typeFormuleEt'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeFormuleEt::
cPtr_typeFormuleEt (const GGS_typeFormule & argument_0,
                                const GGS_typeFormule & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_typeFormule (THERE),
mOperand1 (argument_0),
mOperand2 (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeFormuleEt * GGS_typeFormuleEt::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeFormuleEt) ;
    return (cPtr_typeFormuleEt *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeFormuleEt::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeFormuleEt * ptr = dynamic_cast <const cPtr_typeFormuleEt *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOperand1.operator_isEqual (ptr->mOperand1).boolValue ()
         && mOperand2.operator_isEqual (ptr->mOperand2).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeFormuleEt::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeFormuleEt:"
           << mOperand1.reader_description (inIndentation + 1)
           << mOperand2.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeFormuleEt::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeFormuleEt::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeFormuleEt (& typeid (cPtr_typeFormuleEt), & typeid (cPtr_typeFormule), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeFormuleEt::galgasRTTI (void) const {
  return & gClassInfoFor__typeFormuleEt ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeFormuleEt::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeFormuleEt (mOperand1, mOperand2 COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_typeFormuleEt'                      *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeFormuleEt ("typeFormuleEt", true, & kTypeDescriptor_GGS_typeFormule) ;

//---------------------------------------------------------------------------*

GGS_typeFormuleEt::
GGS_typeFormuleEt (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeFormuleEt::
GGS_typeFormuleEt (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeFormuleEt GGS_typeFormuleEt::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeFormuleEt result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeFormuleEt *> (inPointer) != NULL)
      : (typeid (cPtr_typeFormuleEt) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeFormuleEt (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeFormuleEt),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeFormuleEt GGS_typeFormuleEt::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_typeFormule & argument_0,
                 const GGS_typeFormule & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_typeFormuleEt result ;
  macroMyNew (result.mPointer, cPtr_typeFormuleEt (argument_0,
                                argument_1 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeFormule  GGS_typeFormuleEt::
reader_mOperand1 (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeFormule   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFormuleEt *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeFormuleEt *) mPointer)->mOperand1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeFormule  GGS_typeFormuleEt::
reader_mOperand2 (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeFormule   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFormuleEt *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeFormuleEt *) mPointer)->mOperand2 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeFormuleEt::actualTypeName (void) const {
  return "typeFormuleEt" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeFormuleEt ("typeFormuleEt", gClassInfoFor__typeFormule, & kTypeDescriptor_GGS_typeFormuleEt) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeFormuleEt::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeFormuleEt * p = NULL ;
    macroMyNew (p, GGS_typeFormuleEt (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeFormuleEt GGS_typeFormuleEt::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeFormuleEt result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeFormuleEt * p = dynamic_cast <const GGS_typeFormuleEt *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeFormuleEt, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeFormuleEt::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeFormuleEt ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_typeFormuleIte'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeFormuleIte::
cPtr_typeFormuleIte (const GGS_typeFormule & argument_0,
                                const GGS_typeFormule & argument_1,
                                const GGS_typeFormule & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeFormule (THERE),
mOperand1 (argument_0),
mOperand2 (argument_1),
mOperand3 (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeFormuleIte * GGS_typeFormuleIte::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeFormuleIte) ;
    return (cPtr_typeFormuleIte *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeFormuleIte::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeFormuleIte * ptr = dynamic_cast <const cPtr_typeFormuleIte *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOperand1.operator_isEqual (ptr->mOperand1).boolValue ()
         && mOperand2.operator_isEqual (ptr->mOperand2).boolValue ()
         && mOperand3.operator_isEqual (ptr->mOperand3).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeFormuleIte::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeFormuleIte:"
           << mOperand1.reader_description (inIndentation + 1)
           << mOperand2.reader_description (inIndentation + 1)
           << mOperand3.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeFormuleIte::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeFormuleIte::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeFormuleIte (& typeid (cPtr_typeFormuleIte), & typeid (cPtr_typeFormule), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeFormuleIte::galgasRTTI (void) const {
  return & gClassInfoFor__typeFormuleIte ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeFormuleIte::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeFormuleIte (mOperand1, mOperand2, mOperand3 COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeFormuleIte'                      *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeFormuleIte ("typeFormuleIte", true, & kTypeDescriptor_GGS_typeFormule) ;

//---------------------------------------------------------------------------*

GGS_typeFormuleIte::
GGS_typeFormuleIte (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeFormuleIte::
GGS_typeFormuleIte (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeFormuleIte GGS_typeFormuleIte::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeFormuleIte result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeFormuleIte *> (inPointer) != NULL)
      : (typeid (cPtr_typeFormuleIte) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeFormuleIte (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeFormuleIte),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeFormuleIte GGS_typeFormuleIte::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_typeFormule & argument_0,
                 const GGS_typeFormule & argument_1,
                 const GGS_typeFormule & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeFormuleIte result ;
  macroMyNew (result.mPointer, cPtr_typeFormuleIte (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeFormule  GGS_typeFormuleIte::
reader_mOperand1 (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeFormule   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFormuleIte *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeFormuleIte *) mPointer)->mOperand1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeFormule  GGS_typeFormuleIte::
reader_mOperand2 (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeFormule   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFormuleIte *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeFormuleIte *) mPointer)->mOperand2 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeFormule  GGS_typeFormuleIte::
reader_mOperand3 (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeFormule   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFormuleIte *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeFormuleIte *) mPointer)->mOperand3 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeFormuleIte::actualTypeName (void) const {
  return "typeFormuleIte" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeFormuleIte ("typeFormuleIte", gClassInfoFor__typeFormule, & kTypeDescriptor_GGS_typeFormuleIte) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeFormuleIte::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeFormuleIte * p = NULL ;
    macroMyNew (p, GGS_typeFormuleIte (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeFormuleIte GGS_typeFormuleIte::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeFormuleIte result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeFormuleIte * p = dynamic_cast <const GGS_typeFormuleIte *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeFormuleIte, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeFormuleIte::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeFormuleIte ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'cPtr_typeFormuleOu'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeFormuleOu::
cPtr_typeFormuleOu (const GGS_typeFormule & argument_0,
                                const GGS_typeFormule & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_typeFormule (THERE),
mOperand1 (argument_0),
mOperand2 (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeFormuleOu * GGS_typeFormuleOu::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeFormuleOu) ;
    return (cPtr_typeFormuleOu *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeFormuleOu::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeFormuleOu * ptr = dynamic_cast <const cPtr_typeFormuleOu *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOperand1.operator_isEqual (ptr->mOperand1).boolValue ()
         && mOperand2.operator_isEqual (ptr->mOperand2).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeFormuleOu::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeFormuleOu:"
           << mOperand1.reader_description (inIndentation + 1)
           << mOperand2.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeFormuleOu::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeFormuleOu::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeFormuleOu (& typeid (cPtr_typeFormuleOu), & typeid (cPtr_typeFormule), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeFormuleOu::galgasRTTI (void) const {
  return & gClassInfoFor__typeFormuleOu ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeFormuleOu::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeFormuleOu (mOperand1, mOperand2 COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_typeFormuleOu'                      *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeFormuleOu ("typeFormuleOu", true, & kTypeDescriptor_GGS_typeFormule) ;

//---------------------------------------------------------------------------*

GGS_typeFormuleOu::
GGS_typeFormuleOu (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeFormuleOu::
GGS_typeFormuleOu (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeFormuleOu GGS_typeFormuleOu::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeFormuleOu result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeFormuleOu *> (inPointer) != NULL)
      : (typeid (cPtr_typeFormuleOu) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeFormuleOu (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeFormuleOu),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeFormuleOu GGS_typeFormuleOu::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_typeFormule & argument_0,
                 const GGS_typeFormule & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_typeFormuleOu result ;
  macroMyNew (result.mPointer, cPtr_typeFormuleOu (argument_0,
                                argument_1 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeFormule  GGS_typeFormuleOu::
reader_mOperand1 (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeFormule   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFormuleOu *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeFormuleOu *) mPointer)->mOperand1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeFormule  GGS_typeFormuleOu::
reader_mOperand2 (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeFormule   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFormuleOu *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeFormuleOu *) mPointer)->mOperand2 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeFormuleOu::actualTypeName (void) const {
  return "typeFormuleOu" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeFormuleOu ("typeFormuleOu", gClassInfoFor__typeFormule, & kTypeDescriptor_GGS_typeFormuleOu) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeFormuleOu::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeFormuleOu * p = NULL ;
    macroMyNew (p, GGS_typeFormuleOu (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeFormuleOu GGS_typeFormuleOu::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeFormuleOu result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeFormuleOu * p = dynamic_cast <const GGS_typeFormuleOu *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeFormuleOu, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeFormuleOu::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeFormuleOu ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_typeFormuleImplique'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeFormuleImplique::
cPtr_typeFormuleImplique (const GGS_typeFormule & argument_0,
                                const GGS_typeFormule & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_typeFormule (THERE),
mOperand1 (argument_0),
mOperand2 (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeFormuleImplique * GGS_typeFormuleImplique::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeFormuleImplique) ;
    return (cPtr_typeFormuleImplique *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeFormuleImplique::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeFormuleImplique * ptr = dynamic_cast <const cPtr_typeFormuleImplique *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOperand1.operator_isEqual (ptr->mOperand1).boolValue ()
         && mOperand2.operator_isEqual (ptr->mOperand2).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeFormuleImplique::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeFormuleImplique:"
           << mOperand1.reader_description (inIndentation + 1)
           << mOperand2.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeFormuleImplique::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeFormuleImplique::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeFormuleImplique (& typeid (cPtr_typeFormuleImplique), & typeid (cPtr_typeFormule), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeFormuleImplique::galgasRTTI (void) const {
  return & gClassInfoFor__typeFormuleImplique ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeFormuleImplique::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeFormuleImplique (mOperand1, mOperand2 COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeFormuleImplique'                   *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeFormuleImplique ("typeFormuleImplique", true, & kTypeDescriptor_GGS_typeFormule) ;

//---------------------------------------------------------------------------*

GGS_typeFormuleImplique::
GGS_typeFormuleImplique (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeFormuleImplique::
GGS_typeFormuleImplique (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeFormuleImplique GGS_typeFormuleImplique::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeFormuleImplique result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeFormuleImplique *> (inPointer) != NULL)
      : (typeid (cPtr_typeFormuleImplique) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeFormuleImplique (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeFormuleImplique),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeFormuleImplique GGS_typeFormuleImplique::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_typeFormule & argument_0,
                 const GGS_typeFormule & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_typeFormuleImplique result ;
  macroMyNew (result.mPointer, cPtr_typeFormuleImplique (argument_0,
                                argument_1 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeFormule  GGS_typeFormuleImplique::
reader_mOperand1 (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeFormule   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFormuleImplique *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeFormuleImplique *) mPointer)->mOperand1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeFormule  GGS_typeFormuleImplique::
reader_mOperand2 (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeFormule   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFormuleImplique *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeFormuleImplique *) mPointer)->mOperand2 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeFormuleImplique::actualTypeName (void) const {
  return "typeFormuleImplique" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeFormuleImplique ("typeFormuleImplique", gClassInfoFor__typeFormule, & kTypeDescriptor_GGS_typeFormuleImplique) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeFormuleImplique::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeFormuleImplique * p = NULL ;
    macroMyNew (p, GGS_typeFormuleImplique (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeFormuleImplique GGS_typeFormuleImplique::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeFormuleImplique result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeFormuleImplique * p = dynamic_cast <const GGS_typeFormuleImplique *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeFormuleImplique, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeFormuleImplique::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeFormuleImplique ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_typeComparaisonFormules'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeComparaisonFormules::
cPtr_typeComparaisonFormules (const GGS_luint & argument_0,
                                const GGS_typeFormule & argument_1,
                                const GGS_typeFormule & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeFormule (THERE),
mComparaison (argument_0),
mOperand1 (argument_1),
mOperand2 (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeComparaisonFormules * GGS_typeComparaisonFormules::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeComparaisonFormules) ;
    return (cPtr_typeComparaisonFormules *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeComparaisonFormules::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeComparaisonFormules * ptr = dynamic_cast <const cPtr_typeComparaisonFormules *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mComparaison.operator_isEqual (ptr->mComparaison).boolValue ()
         && mOperand1.operator_isEqual (ptr->mOperand1).boolValue ()
         && mOperand2.operator_isEqual (ptr->mOperand2).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeComparaisonFormules::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeComparaisonFormules:"
           << mComparaison.reader_description (inIndentation + 1)
           << mOperand1.reader_description (inIndentation + 1)
           << mOperand2.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeComparaisonFormules::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeComparaisonFormules::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeComparaisonFormules (& typeid (cPtr_typeComparaisonFormules), & typeid (cPtr_typeFormule), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeComparaisonFormules::galgasRTTI (void) const {
  return & gClassInfoFor__typeComparaisonFormules ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeComparaisonFormules::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeComparaisonFormules (mComparaison, mOperand1, mOperand2 COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_typeComparaisonFormules'                 *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeComparaisonFormules ("typeComparaisonFormules", true, & kTypeDescriptor_GGS_typeFormule) ;

//---------------------------------------------------------------------------*

GGS_typeComparaisonFormules::
GGS_typeComparaisonFormules (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeComparaisonFormules::
GGS_typeComparaisonFormules (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeComparaisonFormules GGS_typeComparaisonFormules::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeComparaisonFormules result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeComparaisonFormules *> (inPointer) != NULL)
      : (typeid (cPtr_typeComparaisonFormules) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeComparaisonFormules (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeComparaisonFormules),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeComparaisonFormules GGS_typeComparaisonFormules::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_luint & argument_0,
                 const GGS_typeFormule & argument_1,
                 const GGS_typeFormule & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeComparaisonFormules result ;
  macroMyNew (result.mPointer, cPtr_typeComparaisonFormules (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_typeComparaisonFormules::
reader_mComparaison (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeComparaisonFormules *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeComparaisonFormules *) mPointer)->mComparaison ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeFormule  GGS_typeComparaisonFormules::
reader_mOperand1 (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeFormule   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeComparaisonFormules *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeComparaisonFormules *) mPointer)->mOperand1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeFormule  GGS_typeComparaisonFormules::
reader_mOperand2 (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeFormule   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeComparaisonFormules *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeComparaisonFormules *) mPointer)->mOperand2 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeComparaisonFormules::actualTypeName (void) const {
  return "typeComparaisonFormules" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeComparaisonFormules ("typeComparaisonFormules", gClassInfoFor__typeFormule, & kTypeDescriptor_GGS_typeComparaisonFormules) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeComparaisonFormules::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeComparaisonFormules * p = NULL ;
    macroMyNew (p, GGS_typeComparaisonFormules (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeComparaisonFormules GGS_typeComparaisonFormules::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeComparaisonFormules result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeComparaisonFormules * p = dynamic_cast <const GGS_typeComparaisonFormules *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeComparaisonFormules, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeComparaisonFormules::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeComparaisonFormules ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_typeFormuleExist'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeFormuleExist::
cPtr_typeFormuleExist (const GGS_typeFormalArgumentsList & argument_0,
                                const GGS_typeFormule & argument_1,
                                const GGS_extern_bdd& argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeFormule (THERE),
mListeArgsBooleens (argument_0),
mOperand (argument_1),
mContraints (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeFormuleExist * GGS_typeFormuleExist::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeFormuleExist) ;
    return (cPtr_typeFormuleExist *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeFormuleExist::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeFormuleExist * ptr = dynamic_cast <const cPtr_typeFormuleExist *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mListeArgsBooleens.operator_isEqual (ptr->mListeArgsBooleens).boolValue ()
         && mOperand.operator_isEqual (ptr->mOperand).boolValue ()
         && mContraints.operator_isEqual (ptr->mContraints).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeFormuleExist::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeFormuleExist:"
           << mListeArgsBooleens.reader_description (inIndentation + 1)
           << mOperand.reader_description (inIndentation + 1)
           << mContraints.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeFormuleExist::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeFormuleExist::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeFormuleExist (& typeid (cPtr_typeFormuleExist), & typeid (cPtr_typeFormule), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeFormuleExist::galgasRTTI (void) const {
  return & gClassInfoFor__typeFormuleExist ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeFormuleExist::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeFormuleExist (mListeArgsBooleens, mOperand, mContraints COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeFormuleExist'                     *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeFormuleExist ("typeFormuleExist", true, & kTypeDescriptor_GGS_typeFormule) ;

//---------------------------------------------------------------------------*

GGS_typeFormuleExist::
GGS_typeFormuleExist (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeFormuleExist::
GGS_typeFormuleExist (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeFormuleExist GGS_typeFormuleExist::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeFormuleExist result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeFormuleExist *> (inPointer) != NULL)
      : (typeid (cPtr_typeFormuleExist) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeFormuleExist (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeFormuleExist),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeFormuleExist GGS_typeFormuleExist::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_typeFormalArgumentsList & argument_0,
                 const GGS_typeFormule & argument_1,
                 const GGS_extern_bdd& argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeFormuleExist result ;
  macroMyNew (result.mPointer, cPtr_typeFormuleExist (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeFormalArgumentsList  GGS_typeFormuleExist::
reader_mListeArgsBooleens (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeFormalArgumentsList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFormuleExist *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeFormuleExist *) mPointer)->mListeArgsBooleens ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeFormule  GGS_typeFormuleExist::
reader_mOperand (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeFormule   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFormuleExist *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeFormuleExist *) mPointer)->mOperand ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_extern_bdd GGS_typeFormuleExist::
reader_mContraints (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_extern_bdd  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFormuleExist *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeFormuleExist *) mPointer)->mContraints ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeFormuleExist::actualTypeName (void) const {
  return "typeFormuleExist" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeFormuleExist ("typeFormuleExist", gClassInfoFor__typeFormule, & kTypeDescriptor_GGS_typeFormuleExist) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeFormuleExist::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeFormuleExist * p = NULL ;
    macroMyNew (p, GGS_typeFormuleExist (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeFormuleExist GGS_typeFormuleExist::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeFormuleExist result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeFormuleExist * p = dynamic_cast <const GGS_typeFormuleExist *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeFormuleExist, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeFormuleExist::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeFormuleExist ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                class 'cPtr_typeFormuleComparaisonValeur'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeFormuleComparaisonValeur::
cPtr_typeFormuleComparaisonValeur (const GGS_luint & argument_0,
                                const GGS_luint & argument_1,
                                const GGS_luint & argument_2,
                                const GGS_luint & argument_3,
                                const GGS_luint & argument_4,
                                const GGS_luint & argument_5
                                COMMA_LOCATION_ARGS)
:cPtr_typeFormule (THERE),
mIndiceBDD (argument_0),
mDimension (argument_1),
mLowBound (argument_2),
mHighBound (argument_3),
mComparaison (argument_4),
mValeur (argument_5) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeFormuleComparaisonValeur * GGS_typeFormuleComparaisonValeur::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeFormuleComparaisonValeur) ;
    return (cPtr_typeFormuleComparaisonValeur *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeFormuleComparaisonValeur::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeFormuleComparaisonValeur * ptr = dynamic_cast <const cPtr_typeFormuleComparaisonValeur *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mIndiceBDD.operator_isEqual (ptr->mIndiceBDD).boolValue ()
         && mDimension.operator_isEqual (ptr->mDimension).boolValue ()
         && mLowBound.operator_isEqual (ptr->mLowBound).boolValue ()
         && mHighBound.operator_isEqual (ptr->mHighBound).boolValue ()
         && mComparaison.operator_isEqual (ptr->mComparaison).boolValue ()
         && mValeur.operator_isEqual (ptr->mValeur).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeFormuleComparaisonValeur::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeFormuleComparaisonValeur:"
           << mIndiceBDD.reader_description (inIndentation + 1)
           << mDimension.reader_description (inIndentation + 1)
           << mLowBound.reader_description (inIndentation + 1)
           << mHighBound.reader_description (inIndentation + 1)
           << mComparaison.reader_description (inIndentation + 1)
           << mValeur.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeFormuleComparaisonValeur::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeFormuleComparaisonValeur::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeFormuleComparaisonValeur (& typeid (cPtr_typeFormuleComparaisonValeur), & typeid (cPtr_typeFormule), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeFormuleComparaisonValeur::galgasRTTI (void) const {
  return & gClassInfoFor__typeFormuleComparaisonValeur ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeFormuleComparaisonValeur::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeFormuleComparaisonValeur (mIndiceBDD, mDimension, mLowBound, mHighBound, mComparaison, mValeur COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_typeFormuleComparaisonValeur'               *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeFormuleComparaisonValeur ("typeFormuleComparaisonValeur", true, & kTypeDescriptor_GGS_typeFormule) ;

//---------------------------------------------------------------------------*

GGS_typeFormuleComparaisonValeur::
GGS_typeFormuleComparaisonValeur (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeFormuleComparaisonValeur::
GGS_typeFormuleComparaisonValeur (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeFormuleComparaisonValeur GGS_typeFormuleComparaisonValeur::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeFormuleComparaisonValeur result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeFormuleComparaisonValeur *> (inPointer) != NULL)
      : (typeid (cPtr_typeFormuleComparaisonValeur) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeFormuleComparaisonValeur (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeFormuleComparaisonValeur),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeFormuleComparaisonValeur GGS_typeFormuleComparaisonValeur::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_luint & argument_0,
                 const GGS_luint & argument_1,
                 const GGS_luint & argument_2,
                 const GGS_luint & argument_3,
                 const GGS_luint & argument_4,
                 const GGS_luint & argument_5
                                COMMA_LOCATION_ARGS) {
  GGS_typeFormuleComparaisonValeur result ;
  macroMyNew (result.mPointer, cPtr_typeFormuleComparaisonValeur (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_typeFormuleComparaisonValeur::
reader_mIndiceBDD (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFormuleComparaisonValeur *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeFormuleComparaisonValeur *) mPointer)->mIndiceBDD ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_typeFormuleComparaisonValeur::
reader_mDimension (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFormuleComparaisonValeur *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeFormuleComparaisonValeur *) mPointer)->mDimension ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_typeFormuleComparaisonValeur::
reader_mLowBound (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFormuleComparaisonValeur *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeFormuleComparaisonValeur *) mPointer)->mLowBound ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_typeFormuleComparaisonValeur::
reader_mHighBound (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFormuleComparaisonValeur *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeFormuleComparaisonValeur *) mPointer)->mHighBound ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_typeFormuleComparaisonValeur::
reader_mComparaison (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFormuleComparaisonValeur *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeFormuleComparaisonValeur *) mPointer)->mComparaison ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_typeFormuleComparaisonValeur::
reader_mValeur (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFormuleComparaisonValeur *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeFormuleComparaisonValeur *) mPointer)->mValeur ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeFormuleComparaisonValeur::actualTypeName (void) const {
  return "typeFormuleComparaisonValeur" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeFormuleComparaisonValeur ("typeFormuleComparaisonValeur", gClassInfoFor__typeFormule, & kTypeDescriptor_GGS_typeFormuleComparaisonValeur) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeFormuleComparaisonValeur::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeFormuleComparaisonValeur * p = NULL ;
    macroMyNew (p, GGS_typeFormuleComparaisonValeur (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeFormuleComparaisonValeur GGS_typeFormuleComparaisonValeur::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeFormuleComparaisonValeur result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeFormuleComparaisonValeur * p = dynamic_cast <const GGS_typeFormuleComparaisonValeur *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeFormuleComparaisonValeur, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeFormuleComparaisonValeur::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeFormuleComparaisonValeur ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               class 'cPtr_typeFormuleComparaisonVariable'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeFormuleComparaisonVariable::
cPtr_typeFormuleComparaisonVariable (const GGS_luint & argument_0,
                                const GGS_luint & argument_1,
                                const GGS_luint & argument_2,
                                const GGS_luint & argument_3,
                                const GGS_luint & argument_4,
                                const GGS_luint & argument_5,
                                const GGS_luint & argument_6,
                                const GGS_luint & argument_7
                                COMMA_LOCATION_ARGS)
:cPtr_typeFormule (THERE),
mIndiceBDDgauche (argument_0),
mDimension (argument_1),
mLeftLowBound (argument_2),
mLeftHighBound (argument_3),
mComparaison (argument_4),
mIndiceBDDdroite (argument_5),
mRightLowBound (argument_6),
mRightHighBound (argument_7) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeFormuleComparaisonVariable * GGS_typeFormuleComparaisonVariable::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeFormuleComparaisonVariable) ;
    return (cPtr_typeFormuleComparaisonVariable *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeFormuleComparaisonVariable::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeFormuleComparaisonVariable * ptr = dynamic_cast <const cPtr_typeFormuleComparaisonVariable *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mIndiceBDDgauche.operator_isEqual (ptr->mIndiceBDDgauche).boolValue ()
         && mDimension.operator_isEqual (ptr->mDimension).boolValue ()
         && mLeftLowBound.operator_isEqual (ptr->mLeftLowBound).boolValue ()
         && mLeftHighBound.operator_isEqual (ptr->mLeftHighBound).boolValue ()
         && mComparaison.operator_isEqual (ptr->mComparaison).boolValue ()
         && mIndiceBDDdroite.operator_isEqual (ptr->mIndiceBDDdroite).boolValue ()
         && mRightLowBound.operator_isEqual (ptr->mRightLowBound).boolValue ()
         && mRightHighBound.operator_isEqual (ptr->mRightHighBound).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeFormuleComparaisonVariable::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeFormuleComparaisonVariable:"
           << mIndiceBDDgauche.reader_description (inIndentation + 1)
           << mDimension.reader_description (inIndentation + 1)
           << mLeftLowBound.reader_description (inIndentation + 1)
           << mLeftHighBound.reader_description (inIndentation + 1)
           << mComparaison.reader_description (inIndentation + 1)
           << mIndiceBDDdroite.reader_description (inIndentation + 1)
           << mRightLowBound.reader_description (inIndentation + 1)
           << mRightHighBound.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeFormuleComparaisonVariable::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeFormuleComparaisonVariable::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeFormuleComparaisonVariable (& typeid (cPtr_typeFormuleComparaisonVariable), & typeid (cPtr_typeFormule), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeFormuleComparaisonVariable::galgasRTTI (void) const {
  return & gClassInfoFor__typeFormuleComparaisonVariable ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeFormuleComparaisonVariable::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeFormuleComparaisonVariable (mIndiceBDDgauche, mDimension, mLeftLowBound, mLeftHighBound, mComparaison, mIndiceBDDdroite, mRightLowBound, mRightHighBound COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            GALGAS class 'GGS_typeFormuleComparaisonVariable'              *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeFormuleComparaisonVariable ("typeFormuleComparaisonVariable", true, & kTypeDescriptor_GGS_typeFormule) ;

//---------------------------------------------------------------------------*

GGS_typeFormuleComparaisonVariable::
GGS_typeFormuleComparaisonVariable (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeFormuleComparaisonVariable::
GGS_typeFormuleComparaisonVariable (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeFormuleComparaisonVariable GGS_typeFormuleComparaisonVariable::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeFormuleComparaisonVariable result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeFormuleComparaisonVariable *> (inPointer) != NULL)
      : (typeid (cPtr_typeFormuleComparaisonVariable) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeFormuleComparaisonVariable (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeFormuleComparaisonVariable),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeFormuleComparaisonVariable GGS_typeFormuleComparaisonVariable::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_luint & argument_0,
                 const GGS_luint & argument_1,
                 const GGS_luint & argument_2,
                 const GGS_luint & argument_3,
                 const GGS_luint & argument_4,
                 const GGS_luint & argument_5,
                 const GGS_luint & argument_6,
                 const GGS_luint & argument_7
                                COMMA_LOCATION_ARGS) {
  GGS_typeFormuleComparaisonVariable result ;
  macroMyNew (result.mPointer, cPtr_typeFormuleComparaisonVariable (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6,
                                argument_7 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_typeFormuleComparaisonVariable::
reader_mIndiceBDDgauche (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFormuleComparaisonVariable *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeFormuleComparaisonVariable *) mPointer)->mIndiceBDDgauche ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_typeFormuleComparaisonVariable::
reader_mDimension (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFormuleComparaisonVariable *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeFormuleComparaisonVariable *) mPointer)->mDimension ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_typeFormuleComparaisonVariable::
reader_mLeftLowBound (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFormuleComparaisonVariable *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeFormuleComparaisonVariable *) mPointer)->mLeftLowBound ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_typeFormuleComparaisonVariable::
reader_mLeftHighBound (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFormuleComparaisonVariable *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeFormuleComparaisonVariable *) mPointer)->mLeftHighBound ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_typeFormuleComparaisonVariable::
reader_mComparaison (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFormuleComparaisonVariable *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeFormuleComparaisonVariable *) mPointer)->mComparaison ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_typeFormuleComparaisonVariable::
reader_mIndiceBDDdroite (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFormuleComparaisonVariable *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeFormuleComparaisonVariable *) mPointer)->mIndiceBDDdroite ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_typeFormuleComparaisonVariable::
reader_mRightLowBound (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFormuleComparaisonVariable *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeFormuleComparaisonVariable *) mPointer)->mRightLowBound ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_typeFormuleComparaisonVariable::
reader_mRightHighBound (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFormuleComparaisonVariable *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeFormuleComparaisonVariable *) mPointer)->mRightHighBound ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeFormuleComparaisonVariable::actualTypeName (void) const {
  return "typeFormuleComparaisonVariable" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeFormuleComparaisonVariable ("typeFormuleComparaisonVariable", gClassInfoFor__typeFormule, & kTypeDescriptor_GGS_typeFormuleComparaisonVariable) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeFormuleComparaisonVariable::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeFormuleComparaisonVariable * p = NULL ;
    macroMyNew (p, GGS_typeFormuleComparaisonVariable (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeFormuleComparaisonVariable GGS_typeFormuleComparaisonVariable::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeFormuleComparaisonVariable result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeFormuleComparaisonVariable * p = dynamic_cast <const GGS_typeFormuleComparaisonVariable *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeFormuleComparaisonVariable, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeFormuleComparaisonVariable::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeFormuleComparaisonVariable ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'cPtr_typeCalcul'                           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeCalcul::
cPtr_typeCalcul (LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeCalcul * GGS_typeCalcul::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeCalcul) ;
    return (cPtr_typeCalcul *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_typeCalcul::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@typeCalcul:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeCalcul::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeCalcul::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeCalcul (& typeid (cPtr_typeCalcul), NULL, "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeCalcul::galgasRTTI (void) const {
  return & gClassInfoFor__typeCalcul ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_typeCalcul'                        *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeCalcul ("typeCalcul", true, NULL) ;

//---------------------------------------------------------------------------*

GGS_typeCalcul::
GGS_typeCalcul (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeCalcul::
GGS_typeCalcul (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeCalcul GGS_typeCalcul::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeCalcul result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeCalcul *> (inPointer) != NULL)
      : (typeid (cPtr_typeCalcul) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeCalcul (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeCalcul),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeCalcul::actualTypeName (void) const {
  return "typeCalcul" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * GGS_typeCalcul::galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformationEX * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformationEX gClassInfoFor__typeCalcul ("typeCalcul", & kTypeDescriptor_GGS_typeCalcul) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeCalcul::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeCalcul * p = NULL ;
    macroMyNew (p, GGS_typeCalcul (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeCalcul GGS_typeCalcul::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeCalcul result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeCalcul * p = dynamic_cast <const GGS_typeCalcul *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeCalcul, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeCalcul::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeCalcul ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_typeCalculSimple'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeCalculSimple::
cPtr_typeCalculSimple (const GGS_uint & argument_0,
                                const GGS_typeFormule & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_typeTableVariablesBool & argument_3,
                                const GGS_luint & argument_4
                                COMMA_LOCATION_ARGS)
:cPtr_typeCalcul (THERE),
mNumeroFormule (argument_0),
mFormule (argument_1),
mNomFormule (argument_2),
mTableVariablesBool (argument_3),
mAfficher (argument_4) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeCalculSimple * GGS_typeCalculSimple::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeCalculSimple) ;
    return (cPtr_typeCalculSimple *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeCalculSimple::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeCalculSimple * ptr = dynamic_cast <const cPtr_typeCalculSimple *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mNumeroFormule.operator_isEqual (ptr->mNumeroFormule).boolValue ()
         && mFormule.operator_isEqual (ptr->mFormule).boolValue ()
         && mNomFormule.operator_isEqual (ptr->mNomFormule).boolValue ()
         && mTableVariablesBool.operator_isEqual (ptr->mTableVariablesBool).boolValue ()
         && mAfficher.operator_isEqual (ptr->mAfficher).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeCalculSimple::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeCalculSimple:"
           << mNumeroFormule.reader_description (inIndentation + 1)
           << mFormule.reader_description (inIndentation + 1)
           << mNomFormule.reader_description (inIndentation + 1)
           << mTableVariablesBool.reader_description (inIndentation + 1)
           << mAfficher.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeCalculSimple::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeCalculSimple::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeCalculSimple (& typeid (cPtr_typeCalculSimple), & typeid (cPtr_typeCalcul), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeCalculSimple::galgasRTTI (void) const {
  return & gClassInfoFor__typeCalculSimple ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeCalculSimple::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeCalculSimple (mNumeroFormule, mFormule, mNomFormule, mTableVariablesBool, mAfficher COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeCalculSimple'                     *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeCalculSimple ("typeCalculSimple", true, & kTypeDescriptor_GGS_typeCalcul) ;

//---------------------------------------------------------------------------*

GGS_typeCalculSimple::
GGS_typeCalculSimple (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeCalculSimple::
GGS_typeCalculSimple (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeCalculSimple GGS_typeCalculSimple::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeCalculSimple result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeCalculSimple *> (inPointer) != NULL)
      : (typeid (cPtr_typeCalculSimple) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeCalculSimple (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeCalculSimple),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeCalculSimple GGS_typeCalculSimple::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_uint & argument_0,
                 const GGS_typeFormule & argument_1,
                 const GGS_lstring & argument_2,
                 const GGS_typeTableVariablesBool & argument_3,
                 const GGS_luint & argument_4
                                COMMA_LOCATION_ARGS) {
  GGS_typeCalculSimple result ;
  macroMyNew (result.mPointer, cPtr_typeCalculSimple (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint  GGS_typeCalculSimple::
reader_mNumeroFormule (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_uint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeCalculSimple *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeCalculSimple *) mPointer)->mNumeroFormule ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeFormule  GGS_typeCalculSimple::
reader_mFormule (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeFormule   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeCalculSimple *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeCalculSimple *) mPointer)->mFormule ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeCalculSimple::
reader_mNomFormule (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeCalculSimple *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeCalculSimple *) mPointer)->mNomFormule ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeTableVariablesBool  GGS_typeCalculSimple::
reader_mTableVariablesBool (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeTableVariablesBool   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeCalculSimple *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeCalculSimple *) mPointer)->mTableVariablesBool ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_typeCalculSimple::
reader_mAfficher (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeCalculSimple *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeCalculSimple *) mPointer)->mAfficher ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeCalculSimple::actualTypeName (void) const {
  return "typeCalculSimple" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeCalculSimple ("typeCalculSimple", gClassInfoFor__typeCalcul, & kTypeDescriptor_GGS_typeCalculSimple) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeCalculSimple::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeCalculSimple * p = NULL ;
    macroMyNew (p, GGS_typeCalculSimple (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeCalculSimple GGS_typeCalculSimple::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeCalculSimple result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeCalculSimple * p = dynamic_cast <const GGS_typeCalculSimple *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeCalculSimple, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeCalculSimple::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeCalculSimple ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'cPtr_typeUse_AND'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeUse_AND::
cPtr_typeUse_AND (LOCATION_ARGS)
:cPtr_typeCalcul (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeUse_AND * GGS_typeUse_AND::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeUse_AND) ;
    return (cPtr_typeUse_AND *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeUse_AND::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeUse_AND::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@typeUse_AND:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeUse_AND::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeUse_AND::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeUse_AND (& typeid (cPtr_typeUse_AND), & typeid (cPtr_typeCalcul), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeUse_AND::galgasRTTI (void) const {
  return & gClassInfoFor__typeUse_AND ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_typeUse_AND'                       *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeUse_AND ("typeUse_AND", true, & kTypeDescriptor_GGS_typeCalcul) ;

//---------------------------------------------------------------------------*

GGS_typeUse_AND::
GGS_typeUse_AND (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeUse_AND::
GGS_typeUse_AND (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeUse_AND GGS_typeUse_AND::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeUse_AND result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeUse_AND *> (inPointer) != NULL)
      : (typeid (cPtr_typeUse_AND) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeUse_AND (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeUse_AND),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

static cPtr_typeUse_AND * gSingleton_typeUse_AND = NULL ;

//---------------------------------------------------------------------------*

GGS_typeUse_AND GGS_typeUse_AND::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_typeUse_AND result ;
  if (NULL == gSingleton_typeUse_AND) {
    macroMyNew (gSingleton_typeUse_AND, cPtr_typeUse_AND (THERE)) ;
    macroRetainObject (gSingleton_typeUse_AND) ;
  }
  macroAssignObject (result.mPointer, gSingleton_typeUse_AND) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeUse_AND::actualTypeName (void) const {
  return "typeUse_AND" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeUse_AND ("typeUse_AND", gClassInfoFor__typeCalcul, & kTypeDescriptor_GGS_typeUse_AND) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeUse_AND::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeUse_AND * p = NULL ;
    macroMyNew (p, GGS_typeUse_AND (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeUse_AND GGS_typeUse_AND::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeUse_AND result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeUse_AND * p = dynamic_cast <const GGS_typeUse_AND *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeUse_AND, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeUse_AND::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeUse_AND ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'cPtr_typeUse_ITE'                          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeUse_ITE::
cPtr_typeUse_ITE (LOCATION_ARGS)
:cPtr_typeCalcul (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeUse_ITE * GGS_typeUse_ITE::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeUse_ITE) ;
    return (cPtr_typeUse_ITE *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeUse_ITE::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeUse_ITE::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@typeUse_ITE:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeUse_ITE::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeUse_ITE::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeUse_ITE (& typeid (cPtr_typeUse_ITE), & typeid (cPtr_typeCalcul), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeUse_ITE::galgasRTTI (void) const {
  return & gClassInfoFor__typeUse_ITE ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_typeUse_ITE'                       *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeUse_ITE ("typeUse_ITE", true, & kTypeDescriptor_GGS_typeCalcul) ;

//---------------------------------------------------------------------------*

GGS_typeUse_ITE::
GGS_typeUse_ITE (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeUse_ITE::
GGS_typeUse_ITE (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeUse_ITE GGS_typeUse_ITE::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeUse_ITE result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeUse_ITE *> (inPointer) != NULL)
      : (typeid (cPtr_typeUse_ITE) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeUse_ITE (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeUse_ITE),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

static cPtr_typeUse_ITE * gSingleton_typeUse_ITE = NULL ;

//---------------------------------------------------------------------------*

GGS_typeUse_ITE GGS_typeUse_ITE::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_typeUse_ITE result ;
  if (NULL == gSingleton_typeUse_ITE) {
    macroMyNew (gSingleton_typeUse_ITE, cPtr_typeUse_ITE (THERE)) ;
    macroRetainObject (gSingleton_typeUse_ITE) ;
  }
  macroAssignObject (result.mPointer, gSingleton_typeUse_ITE) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeUse_ITE::actualTypeName (void) const {
  return "typeUse_ITE" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeUse_ITE ("typeUse_ITE", gClassInfoFor__typeCalcul, & kTypeDescriptor_GGS_typeUse_ITE) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeUse_ITE::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeUse_ITE * p = NULL ;
    macroMyNew (p, GGS_typeUse_ITE (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeUse_ITE GGS_typeUse_ITE::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeUse_ITE result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeUse_ITE * p = dynamic_cast <const GGS_typeUse_ITE *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeUse_ITE, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeUse_ITE::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeUse_ITE ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_typeUse_AND_ITE'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeUse_AND_ITE::
cPtr_typeUse_AND_ITE (LOCATION_ARGS)
:cPtr_typeCalcul (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeUse_AND_ITE * GGS_typeUse_AND_ITE::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeUse_AND_ITE) ;
    return (cPtr_typeUse_AND_ITE *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeUse_AND_ITE::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeUse_AND_ITE::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@typeUse_AND_ITE:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeUse_AND_ITE::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeUse_AND_ITE::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeUse_AND_ITE (& typeid (cPtr_typeUse_AND_ITE), & typeid (cPtr_typeCalcul), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeUse_AND_ITE::galgasRTTI (void) const {
  return & gClassInfoFor__typeUse_AND_ITE ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeUse_AND_ITE'                     *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeUse_AND_ITE ("typeUse_AND_ITE", true, & kTypeDescriptor_GGS_typeCalcul) ;

//---------------------------------------------------------------------------*

GGS_typeUse_AND_ITE::
GGS_typeUse_AND_ITE (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeUse_AND_ITE::
GGS_typeUse_AND_ITE (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeUse_AND_ITE GGS_typeUse_AND_ITE::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeUse_AND_ITE result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeUse_AND_ITE *> (inPointer) != NULL)
      : (typeid (cPtr_typeUse_AND_ITE) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeUse_AND_ITE (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeUse_AND_ITE),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

static cPtr_typeUse_AND_ITE * gSingleton_typeUse_AND_ITE = NULL ;

//---------------------------------------------------------------------------*

GGS_typeUse_AND_ITE GGS_typeUse_AND_ITE::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_typeUse_AND_ITE result ;
  if (NULL == gSingleton_typeUse_AND_ITE) {
    macroMyNew (gSingleton_typeUse_AND_ITE, cPtr_typeUse_AND_ITE (THERE)) ;
    macroRetainObject (gSingleton_typeUse_AND_ITE) ;
  }
  macroAssignObject (result.mPointer, gSingleton_typeUse_AND_ITE) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeUse_AND_ITE::actualTypeName (void) const {
  return "typeUse_AND_ITE" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeUse_AND_ITE ("typeUse_AND_ITE", gClassInfoFor__typeCalcul, & kTypeDescriptor_GGS_typeUse_AND_ITE) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeUse_AND_ITE::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeUse_AND_ITE * p = NULL ;
    macroMyNew (p, GGS_typeUse_AND_ITE (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeUse_AND_ITE GGS_typeUse_AND_ITE::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeUse_AND_ITE result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeUse_AND_ITE * p = dynamic_cast <const GGS_typeUse_AND_ITE *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeUse_AND_ITE, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeUse_AND_ITE::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeUse_AND_ITE ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_typeDimensionnerANDCache'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeDimensionnerANDCache::
cPtr_typeDimensionnerANDCache (const GGS_luint & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_typeCalcul (THERE),
mDimensionCache (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeDimensionnerANDCache * GGS_typeDimensionnerANDCache::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeDimensionnerANDCache) ;
    return (cPtr_typeDimensionnerANDCache *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeDimensionnerANDCache::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeDimensionnerANDCache * ptr = dynamic_cast <const cPtr_typeDimensionnerANDCache *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mDimensionCache.operator_isEqual (ptr->mDimensionCache).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeDimensionnerANDCache::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeDimensionnerANDCache:"
           << mDimensionCache.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeDimensionnerANDCache::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeDimensionnerANDCache::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeDimensionnerANDCache (& typeid (cPtr_typeDimensionnerANDCache), & typeid (cPtr_typeCalcul), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeDimensionnerANDCache::galgasRTTI (void) const {
  return & gClassInfoFor__typeDimensionnerANDCache ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeDimensionnerANDCache::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeDimensionnerANDCache (mDimensionCache COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeDimensionnerANDCache'                 *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeDimensionnerANDCache ("typeDimensionnerANDCache", true, & kTypeDescriptor_GGS_typeCalcul) ;

//---------------------------------------------------------------------------*

GGS_typeDimensionnerANDCache::
GGS_typeDimensionnerANDCache (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeDimensionnerANDCache::
GGS_typeDimensionnerANDCache (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeDimensionnerANDCache GGS_typeDimensionnerANDCache::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeDimensionnerANDCache result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeDimensionnerANDCache *> (inPointer) != NULL)
      : (typeid (cPtr_typeDimensionnerANDCache) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeDimensionnerANDCache (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeDimensionnerANDCache),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeDimensionnerANDCache GGS_typeDimensionnerANDCache::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_luint & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_typeDimensionnerANDCache result ;
  macroMyNew (result.mPointer, cPtr_typeDimensionnerANDCache (argument_0 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_typeDimensionnerANDCache::
reader_mDimensionCache (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeDimensionnerANDCache *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeDimensionnerANDCache *) mPointer)->mDimensionCache ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeDimensionnerANDCache::actualTypeName (void) const {
  return "typeDimensionnerANDCache" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeDimensionnerANDCache ("typeDimensionnerANDCache", gClassInfoFor__typeCalcul, & kTypeDescriptor_GGS_typeDimensionnerANDCache) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeDimensionnerANDCache::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeDimensionnerANDCache * p = NULL ;
    macroMyNew (p, GGS_typeDimensionnerANDCache (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeDimensionnerANDCache GGS_typeDimensionnerANDCache::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeDimensionnerANDCache result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeDimensionnerANDCache * p = dynamic_cast <const GGS_typeDimensionnerANDCache *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeDimensionnerANDCache, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeDimensionnerANDCache::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeDimensionnerANDCache ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_typeDimensionnerITECache'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeDimensionnerITECache::
cPtr_typeDimensionnerITECache (const GGS_luint & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_typeCalcul (THERE),
mDimensionCache (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeDimensionnerITECache * GGS_typeDimensionnerITECache::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeDimensionnerITECache) ;
    return (cPtr_typeDimensionnerITECache *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeDimensionnerITECache::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeDimensionnerITECache * ptr = dynamic_cast <const cPtr_typeDimensionnerITECache *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mDimensionCache.operator_isEqual (ptr->mDimensionCache).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeDimensionnerITECache::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeDimensionnerITECache:"
           << mDimensionCache.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeDimensionnerITECache::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeDimensionnerITECache::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeDimensionnerITECache (& typeid (cPtr_typeDimensionnerITECache), & typeid (cPtr_typeCalcul), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeDimensionnerITECache::galgasRTTI (void) const {
  return & gClassInfoFor__typeDimensionnerITECache ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeDimensionnerITECache::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeDimensionnerITECache (mDimensionCache COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeDimensionnerITECache'                 *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeDimensionnerITECache ("typeDimensionnerITECache", true, & kTypeDescriptor_GGS_typeCalcul) ;

//---------------------------------------------------------------------------*

GGS_typeDimensionnerITECache::
GGS_typeDimensionnerITECache (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeDimensionnerITECache::
GGS_typeDimensionnerITECache (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeDimensionnerITECache GGS_typeDimensionnerITECache::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeDimensionnerITECache result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeDimensionnerITECache *> (inPointer) != NULL)
      : (typeid (cPtr_typeDimensionnerITECache) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeDimensionnerITECache (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeDimensionnerITECache),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeDimensionnerITECache GGS_typeDimensionnerITECache::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_luint & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_typeDimensionnerITECache result ;
  macroMyNew (result.mPointer, cPtr_typeDimensionnerITECache (argument_0 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_typeDimensionnerITECache::
reader_mDimensionCache (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeDimensionnerITECache *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeDimensionnerITECache *) mPointer)->mDimensionCache ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeDimensionnerITECache::actualTypeName (void) const {
  return "typeDimensionnerITECache" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeDimensionnerITECache ("typeDimensionnerITECache", gClassInfoFor__typeCalcul, & kTypeDescriptor_GGS_typeDimensionnerITECache) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeDimensionnerITECache::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeDimensionnerITECache * p = NULL ;
    macroMyNew (p, GGS_typeDimensionnerITECache (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeDimensionnerITECache GGS_typeDimensionnerITECache::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeDimensionnerITECache result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeDimensionnerITECache * p = dynamic_cast <const GGS_typeDimensionnerITECache *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeDimensionnerITECache, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeDimensionnerITECache::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeDimensionnerITECache ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_typeDimensionnerTable'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeDimensionnerTable::
cPtr_typeDimensionnerTable (const GGS_luint & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_typeCalcul (THERE),
mDimensionTable (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeDimensionnerTable * GGS_typeDimensionnerTable::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeDimensionnerTable) ;
    return (cPtr_typeDimensionnerTable *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeDimensionnerTable::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeDimensionnerTable * ptr = dynamic_cast <const cPtr_typeDimensionnerTable *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mDimensionTable.operator_isEqual (ptr->mDimensionTable).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeDimensionnerTable::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeDimensionnerTable:"
           << mDimensionTable.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeDimensionnerTable::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeDimensionnerTable::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeDimensionnerTable (& typeid (cPtr_typeDimensionnerTable), & typeid (cPtr_typeCalcul), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeDimensionnerTable::galgasRTTI (void) const {
  return & gClassInfoFor__typeDimensionnerTable ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeDimensionnerTable::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeDimensionnerTable (mDimensionTable COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeDimensionnerTable'                  *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeDimensionnerTable ("typeDimensionnerTable", true, & kTypeDescriptor_GGS_typeCalcul) ;

//---------------------------------------------------------------------------*

GGS_typeDimensionnerTable::
GGS_typeDimensionnerTable (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeDimensionnerTable::
GGS_typeDimensionnerTable (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeDimensionnerTable GGS_typeDimensionnerTable::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeDimensionnerTable result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeDimensionnerTable *> (inPointer) != NULL)
      : (typeid (cPtr_typeDimensionnerTable) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeDimensionnerTable (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeDimensionnerTable),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeDimensionnerTable GGS_typeDimensionnerTable::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_luint & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_typeDimensionnerTable result ;
  macroMyNew (result.mPointer, cPtr_typeDimensionnerTable (argument_0 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_typeDimensionnerTable::
reader_mDimensionTable (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeDimensionnerTable *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeDimensionnerTable *) mPointer)->mDimensionTable ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeDimensionnerTable::actualTypeName (void) const {
  return "typeDimensionnerTable" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeDimensionnerTable ("typeDimensionnerTable", gClassInfoFor__typeCalcul, & kTypeDescriptor_GGS_typeDimensionnerTable) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeDimensionnerTable::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeDimensionnerTable * p = NULL ;
    macroMyNew (p, GGS_typeDimensionnerTable (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeDimensionnerTable GGS_typeDimensionnerTable::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeDimensionnerTable result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeDimensionnerTable * p = dynamic_cast <const GGS_typeDimensionnerTable *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeDimensionnerTable, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeDimensionnerTable::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeDimensionnerTable ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_typeAfficherBilan'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeAfficherBilan::
cPtr_typeAfficherBilan (LOCATION_ARGS)
:cPtr_typeCalcul (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeAfficherBilan * GGS_typeAfficherBilan::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeAfficherBilan) ;
    return (cPtr_typeAfficherBilan *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeAfficherBilan::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeAfficherBilan::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@typeAfficherBilan:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeAfficherBilan::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeAfficherBilan::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeAfficherBilan (& typeid (cPtr_typeAfficherBilan), & typeid (cPtr_typeCalcul), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeAfficherBilan::galgasRTTI (void) const {
  return & gClassInfoFor__typeAfficherBilan ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeAfficherBilan'                    *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeAfficherBilan ("typeAfficherBilan", true, & kTypeDescriptor_GGS_typeCalcul) ;

//---------------------------------------------------------------------------*

GGS_typeAfficherBilan::
GGS_typeAfficherBilan (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeAfficherBilan::
GGS_typeAfficherBilan (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeAfficherBilan GGS_typeAfficherBilan::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeAfficherBilan result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeAfficherBilan *> (inPointer) != NULL)
      : (typeid (cPtr_typeAfficherBilan) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeAfficherBilan (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeAfficherBilan),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

static cPtr_typeAfficherBilan * gSingleton_typeAfficherBilan = NULL ;

//---------------------------------------------------------------------------*

GGS_typeAfficherBilan GGS_typeAfficherBilan::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_typeAfficherBilan result ;
  if (NULL == gSingleton_typeAfficherBilan) {
    macroMyNew (gSingleton_typeAfficherBilan, cPtr_typeAfficherBilan (THERE)) ;
    macroRetainObject (gSingleton_typeAfficherBilan) ;
  }
  macroAssignObject (result.mPointer, gSingleton_typeAfficherBilan) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeAfficherBilan::actualTypeName (void) const {
  return "typeAfficherBilan" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeAfficherBilan ("typeAfficherBilan", gClassInfoFor__typeCalcul, & kTypeDescriptor_GGS_typeAfficherBilan) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeAfficherBilan::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeAfficherBilan * p = NULL ;
    macroMyNew (p, GGS_typeAfficherBilan (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeAfficherBilan GGS_typeAfficherBilan::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeAfficherBilan result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeAfficherBilan * p = dynamic_cast <const GGS_typeAfficherBilan *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeAfficherBilan, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeAfficherBilan::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeAfficherBilan ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_typeCalculIteratif'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeCalculIteratif::
cPtr_typeCalculIteratif (const GGS_uint & argument_0,
                                const GGS_typeFormule & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_typeTableVariablesBool & argument_3,
                                const GGS_lbool & argument_4,
                                const GGS_luint & argument_5
                                COMMA_LOCATION_ARGS)
:cPtr_typeCalcul (THERE),
mNumeroFormule (argument_0),
mFormule (argument_1),
mNomFormule (argument_2),
mTableVariablesBool (argument_3),
mSigne (argument_4),
mAfficher (argument_5) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeCalculIteratif * GGS_typeCalculIteratif::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeCalculIteratif) ;
    return (cPtr_typeCalculIteratif *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeCalculIteratif::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeCalculIteratif * ptr = dynamic_cast <const cPtr_typeCalculIteratif *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mNumeroFormule.operator_isEqual (ptr->mNumeroFormule).boolValue ()
         && mFormule.operator_isEqual (ptr->mFormule).boolValue ()
         && mNomFormule.operator_isEqual (ptr->mNomFormule).boolValue ()
         && mTableVariablesBool.operator_isEqual (ptr->mTableVariablesBool).boolValue ()
         && mSigne.operator_isEqual (ptr->mSigne).boolValue ()
         && mAfficher.operator_isEqual (ptr->mAfficher).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeCalculIteratif::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeCalculIteratif:"
           << mNumeroFormule.reader_description (inIndentation + 1)
           << mFormule.reader_description (inIndentation + 1)
           << mNomFormule.reader_description (inIndentation + 1)
           << mTableVariablesBool.reader_description (inIndentation + 1)
           << mSigne.reader_description (inIndentation + 1)
           << mAfficher.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeCalculIteratif::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeCalculIteratif::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeCalculIteratif (& typeid (cPtr_typeCalculIteratif), & typeid (cPtr_typeCalcul), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeCalculIteratif::galgasRTTI (void) const {
  return & gClassInfoFor__typeCalculIteratif ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeCalculIteratif::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeCalculIteratif (mNumeroFormule, mFormule, mNomFormule, mTableVariablesBool, mSigne, mAfficher COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeCalculIteratif'                    *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeCalculIteratif ("typeCalculIteratif", true, & kTypeDescriptor_GGS_typeCalcul) ;

//---------------------------------------------------------------------------*

GGS_typeCalculIteratif::
GGS_typeCalculIteratif (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeCalculIteratif::
GGS_typeCalculIteratif (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeCalculIteratif GGS_typeCalculIteratif::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeCalculIteratif result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeCalculIteratif *> (inPointer) != NULL)
      : (typeid (cPtr_typeCalculIteratif) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeCalculIteratif (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeCalculIteratif),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeCalculIteratif GGS_typeCalculIteratif::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_uint & argument_0,
                 const GGS_typeFormule & argument_1,
                 const GGS_lstring & argument_2,
                 const GGS_typeTableVariablesBool & argument_3,
                 const GGS_lbool & argument_4,
                 const GGS_luint & argument_5
                                COMMA_LOCATION_ARGS) {
  GGS_typeCalculIteratif result ;
  macroMyNew (result.mPointer, cPtr_typeCalculIteratif (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint  GGS_typeCalculIteratif::
reader_mNumeroFormule (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_uint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeCalculIteratif *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeCalculIteratif *) mPointer)->mNumeroFormule ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeFormule  GGS_typeCalculIteratif::
reader_mFormule (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeFormule   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeCalculIteratif *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeCalculIteratif *) mPointer)->mFormule ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeCalculIteratif::
reader_mNomFormule (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeCalculIteratif *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeCalculIteratif *) mPointer)->mNomFormule ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeTableVariablesBool  GGS_typeCalculIteratif::
reader_mTableVariablesBool (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeTableVariablesBool   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeCalculIteratif *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeCalculIteratif *) mPointer)->mTableVariablesBool ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lbool  GGS_typeCalculIteratif::
reader_mSigne (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lbool   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeCalculIteratif *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeCalculIteratif *) mPointer)->mSigne ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_typeCalculIteratif::
reader_mAfficher (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeCalculIteratif *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeCalculIteratif *) mPointer)->mAfficher ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeCalculIteratif::actualTypeName (void) const {
  return "typeCalculIteratif" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeCalculIteratif ("typeCalculIteratif", gClassInfoFor__typeCalcul, & kTypeDescriptor_GGS_typeCalculIteratif) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeCalculIteratif::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeCalculIteratif * p = NULL ;
    macroMyNew (p, GGS_typeCalculIteratif (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeCalculIteratif GGS_typeCalculIteratif::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeCalculIteratif result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeCalculIteratif * p = dynamic_cast <const GGS_typeCalculIteratif *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeCalculIteratif, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeCalculIteratif::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeCalculIteratif ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   Element of list '@typeListeCalculs'                     *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeListeCalculs::
elementOf_GGS_typeListeCalculs (const GGS_typeCalcul & argument_0
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mCalcul (argument_0) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_typeListeCalculs::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_typeListeCalculs * ptr = dynamic_cast <const elementOf_GGS_typeListeCalculs *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mCalcul.operator_isEqual (ptr->mCalcul).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeListeCalculs::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mCalcul.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         List '@typeListeCalculs'                          *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeListeCalculs ("typeListeCalculs", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_typeListeCalculs::
internalAppendValues (const GGS_typeCalcul & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeCalculs::
internalPrependValues (const GGS_typeCalcul & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeCalculs::
addAssign_operation (const GGS_typeCalcul & argument_0) {
  if (isBuilt ()&& argument_0.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_typeListeCalculs GGS_typeListeCalculs::
operator_concat (const GGS_typeListeCalculs & inOperand) const {
  GGS_typeListeCalculs result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeCalculs::
dotAssign_operation (const GGS_typeListeCalculs inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_typeListeCalculs * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_typeCalcul  p_0 = p->mCalcul ;
          internalAppendValues (p_0 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeCalculs::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_typeCalcul & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeCalculs::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mCalcul
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeListeCalculs  GGS_typeListeCalculs::
constructor_emptyList (void) {
  GGS_typeListeCalculs result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeListeCalculs  GGS_typeListeCalculs::
constructor_listWithValue (const GGS_typeCalcul & argument_0) {
  GGS_typeListeCalculs result ;
  result.alloc () ;
  result.addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeCalculs::
internalSubListWithRange (GGS_typeListeCalculs & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mCalcul) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeListeCalculs GGS_typeListeCalculs::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_typeListeCalculs result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeListeCalculs GGS_typeListeCalculs::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_typeListeCalculs result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeListeCalculs::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@typeListeCalculs", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeCalculs::
method_first (C_Compiler & inLexique,
              GGS_typeCalcul & _out_0
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mCalcul ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeCalculs::
method_last (C_Compiler & inLexique,
             GGS_typeCalcul & _out_0
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mCalcul ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeCalculs::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_typeCalcul & _out_0
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mCalcul ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeCalculs::
modifier_popLast (C_Compiler & inLexique,
                GGS_typeCalcul & _out_0
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mCalcul ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_typeCalcul  GGS_typeListeCalculs::
reader_mCalculAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_typeCalcul  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mCalcul ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeCalculs::
modifier_setMCalculAtIndex (C_Compiler & inLexique,
                              const GGS_typeCalcul  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mCalcul = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_typeCalcul  & GGS_typeListeCalculs::cEnumerator::_mCalcul (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mCalcul ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_typeListeCalculs::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeListeCalculs * p = NULL ;
    macroMyNew (p, GGS_typeListeCalculs (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeListeCalculs GGS_typeListeCalculs::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeListeCalculs result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeListeCalculs * p = dynamic_cast <const GGS_typeListeCalculs *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeListeCalculs, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeListeCalculs::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeListeCalculs ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//         Implementation of routine "verifierNombreArgumentsBool"           *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_verifierNombreArgumentsBool (C_Compiler & inLexique,
                                const GGS_typeFormalArgumentsList   var_cas_t1,
                                const GGS_typeActualArgumentsList   var_cas_t2,
                                const GGS_location   var_cas_positionFinListe
                        COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_verifierNombreArgumentsBool at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  const GGS_bool cond_7818 = (var_cas_t1.reader_length ()).operator_strictInf (var_cas_t2.reader_length ()) ;
  if (cond_7818.isBuiltAndTrue ()) {
    var_cas_positionFinListe.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("too much actual arguments") COMMA_SOURCE_FILE_AT_LINE (263)) ;
  }else if (cond_7818.isBuiltAndFalse ()) {
    const GGS_bool cond_7925 = (var_cas_t1.reader_length ()).operator_strictSup (var_cas_t2.reader_length ()) ;
    if (cond_7925.isBuiltAndTrue ()) {
      var_cas_positionFinListe.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("one or more actual arguments missing") COMMA_SOURCE_FILE_AT_LINE (265)) ;
    }
  }
  {
    GGS_typeFormalArgumentsList::cEnumerator enumerator_7943 (var_cas_t1, true) ;
    const GGS_typeFormalArgumentsList::cElement * operand_7943 = NULL ;
    GGS_typeActualArgumentsList::cEnumerator enumerator_7947 (var_cas_t2, true) ;
    const GGS_typeActualArgumentsList::cElement * operand_7947 = NULL ;
    while (((operand_7943 = enumerator_7943.nextObject ()))
        && ((operand_7947 = enumerator_7947.nextObject ()))) {
      macroValidPointer (operand_7943) ;
      macroValidPointer (operand_7947) ;
      const GGS_bool cond_8385 = (operand_7943->mVariableBitSize.reader_uint (inLexique COMMA_SOURCE_FILE_AT_LINE (267))).operator_isEqual (operand_7947->mVariableBitSize.reader_uint (inLexique COMMA_SOURCE_FILE_AT_LINE (267))) ;
      if (cond_8385.isBuiltAndTrue ()) {
        const GGS_bool cond_8274 = (operand_7943->mLowBound.reader_uint (inLexique COMMA_SOURCE_FILE_AT_LINE (268))).operator_isEqual (operand_7947->mLowBound.reader_uint (inLexique COMMA_SOURCE_FILE_AT_LINE (268))) ;
        if (cond_8274.isBuiltAndTrue ()) {
          const GGS_bool cond_8156 = (operand_7943->mHighBound.reader_uint (inLexique COMMA_SOURCE_FILE_AT_LINE (269))).operator_isEqual (operand_7947->mHighBound.reader_uint (inLexique COMMA_SOURCE_FILE_AT_LINE (269))) ;
          if (cond_8156.isBuiltAndTrue ()) {
          }else if (cond_8156.isBuiltAndFalse ()) {
            operand_7947->mErrorLocation.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("the actual high bound is different the formal one") COMMA_SOURCE_FILE_AT_LINE (272)) ;
          }
        }else if (cond_8274.isBuiltAndFalse ()) {
          operand_7947->mErrorLocation.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("the actual low bound is different the formal one") COMMA_SOURCE_FILE_AT_LINE (275)) ;
        }
      }else if (cond_8385.isBuiltAndFalse ()) {
        operand_7947->mErrorLocation.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("the actual dimension is different from the formal one") COMMA_SOURCE_FILE_AT_LINE (278)) ;
      }
    }
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_verifierNombreArgumentsBool\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//             Implementation of routine "buildFormalArgsList"               *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_buildFormalArgsList (C_Compiler & inLexique,
                                const GGS_typeVariableDescriptor   var_cas_inVariableDescriptor,
                                GGS_typeFormalArgumentsList  & var_cas_ioFormalArgsList,
                                const GGS_location   var_cas_inErrorLocation
                        COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_buildFormalArgsList at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  { const GGS_typeVariableDescriptor _var_9222 = var_cas_inVariableDescriptor ; // CAST instruction
    if (_var_9222.getPtr () != NULL) {
      macroValidPointer (_var_9222.getPtr ()) ;
      if (dynamic_cast <cPtr_typeDirectVariable *> (_var_9222.getPtr ()) != NULL) {
        const GGS_typeDirectVariable var_cas_v (_var_9222.getPtr ()) ;
        var_cas_ioFormalArgsList.addAssign_operation (var_cas_v.reader_mIndex (inLexique COMMA_SOURCE_FILE_AT_LINE (291)), var_cas_v.reader_mBitSize (inLexique COMMA_SOURCE_FILE_AT_LINE (291)), var_cas_v.reader_mLowBound (inLexique COMMA_SOURCE_FILE_AT_LINE (291)), var_cas_v.reader_mHighBound (inLexique COMMA_SOURCE_FILE_AT_LINE (291))) ;
      }else if (dynamic_cast <cPtr_typeRecordVariable *> (_var_9222.getPtr ()) != NULL) {
        const GGS_typeRecordVariable var_cas_r (_var_9222.getPtr ()) ;
        {
          GGS_typeTableVariablesBool::cEnumerator enumerator_9071 (var_cas_r.reader_mMap (inLexique COMMA_SOURCE_FILE_AT_LINE (293)), true) ;
          const GGS_typeTableVariablesBool::cElement * operand_9071 = NULL ;
          while (((operand_9071 = enumerator_9071.nextObject ()))) {
            macroValidPointer (operand_9071) ;
            ::routine_buildFormalArgsList (inLexique,  operand_9071->mInfo.mVariableDescriptor,  var_cas_ioFormalArgsList,  var_cas_inErrorLocation COMMA_SOURCE_FILE_AT_LINE (294)) ;
          }
        }
      }else{
      const castBranchDescriptorType _castBranchDescriptor [2] = {
        castBranchDescriptorType (& typeid (cPtr_typeDirectVariable), true),
        castBranchDescriptorType (& typeid (cPtr_typeRecordVariable), true)
      } ;
      var_cas_inErrorLocation.castDefaultErrorMessage (inLexique, _castBranchDescriptor, 2, & typeid (* (_var_9222.getPtr ())) COMMA_SOURCE_FILE_AT_LINE (297)) ;
      }
    }
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_buildFormalArgsList\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//             Implementation of routine "buildActualArgsList"               *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_buildActualArgsList (C_Compiler & inLexique,
                                const GGS_typeTableVariablesBool   var_cas_inDomainMap,
                                GGS_typeActualArgumentsList  & var_cas_ioActualArgsList,
                                const GGS_location   var_cas_inErrorLocation
                        COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_buildActualArgsList at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  {
    GGS_typeTableVariablesBool::cEnumerator enumerator_9482 (var_cas_inDomainMap, true) ;
    const GGS_typeTableVariablesBool::cElement * operand_9482 = NULL ;
    while (((operand_9482 = enumerator_9482.nextObject ()))) {
      macroValidPointer (operand_9482) ;
      { const GGS_typeVariableDescriptor _var_9808 = operand_9482->mInfo.mVariableDescriptor ; // CAST instruction
        if (_var_9808.getPtr () != NULL) {
          macroValidPointer (_var_9808.getPtr ()) ;
          if (dynamic_cast <cPtr_typeDirectVariable *> (_var_9808.getPtr ()) != NULL) {
            const GGS_typeDirectVariable var_cas_v (_var_9808.getPtr ()) ;
            var_cas_ioActualArgsList.addAssign_operation (var_cas_v.reader_mIndex (inLexique COMMA_SOURCE_FILE_AT_LINE (310)), var_cas_v.reader_mBitSize (inLexique COMMA_SOURCE_FILE_AT_LINE (310)), var_cas_v.reader_mLowBound (inLexique COMMA_SOURCE_FILE_AT_LINE (310)), var_cas_v.reader_mHighBound (inLexique COMMA_SOURCE_FILE_AT_LINE (310)), var_cas_inErrorLocation) ;
          }else if (dynamic_cast <cPtr_typeRecordVariable *> (_var_9808.getPtr ()) != NULL) {
            const GGS_typeRecordVariable var_cas_r (_var_9808.getPtr ()) ;
            ::routine_buildActualArgsList (inLexique,  var_cas_r.reader_mMap (inLexique COMMA_SOURCE_FILE_AT_LINE (312)),  var_cas_ioActualArgsList,  var_cas_inErrorLocation COMMA_SOURCE_FILE_AT_LINE (312)) ;
          }else{
          const castBranchDescriptorType _castBranchDescriptor [2] = {
            castBranchDescriptorType (& typeid (cPtr_typeDirectVariable), true),
            castBranchDescriptorType (& typeid (cPtr_typeRecordVariable), true)
          } ;
          var_cas_inErrorLocation.castDefaultErrorMessage (inLexique, _castBranchDescriptor, 2, & typeid (* (_var_9808.getPtr ())) COMMA_SOURCE_FILE_AT_LINE (314)) ;
          }
        }
      }
    }
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_buildActualArgsList\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      Prologue and epilogue actions                        *
//                                                                           *
//---------------------------------------------------------------------------*

static void epilogueRoutineFor_semantiqueBDD (void) {
  macroReleaseObject (gSingleton_typeFormuleTrue) ;
  macroReleaseObject (gSingleton_typeFormuleFalse) ;
  macroReleaseObject (gSingleton_typeUse_AND) ;
  macroReleaseObject (gSingleton_typeUse_ITE) ;
  macroReleaseObject (gSingleton_typeUse_AND_ITE) ;
  macroReleaseObject (gSingleton_typeAfficherBilan) ;
}

//---------------------------------------------------------------------------*

C_PrologueEpilogue prologueEpilogueObjectFor_semantiqueBDD (NULL, epilogueRoutineFor_semantiqueBDD) ;

//---------------------------------------------------------------------------*

