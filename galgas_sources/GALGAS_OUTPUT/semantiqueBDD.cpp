//---------------------------------------------------------------------------*
//                                                                           *
//                         File 'semantiqueBDD.cpp'                          *
//         Generated by version GALGAS_BETA_VERSION (LL(1) grammar)          *
//                     february 8th, 2007, at 17h27'52"                      *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

//---------------------------------------------------------------------------*

#include "version_libpm.h"
#if LIBPM_VERSION != THE_LIBPM_VERSION
  #error "This file has been compiled with a version of GALGAS different than the version of libpm"
#endif

//---------------------------------------------------------------------------*

#include <typeinfo>
#include "utilities/MF_MemoryControl.h"
#include "files/C_TextFileWrite.h"
#include "semantiqueBDD.h"

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  static const char gGGSsourceFile [] = "semantiqueBDD.ggs" ;
  #define SOURCE_FILE_AT_LINE(line) , gGGSsourceFile, line
#else
  #define SOURCE_FILE_AT_LINE(line) 
#endif


//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//                     abstract class 'cPtr_typeDomain'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeDomain::
cPtr_typeDomain (LOCATION_ARGS)
:C_GGS_Object (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeDomain * GGS_typeDomain::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
      return mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_typeDomain::
appendForDescription (C_Lexique & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeDomain:" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeDomain
::static_string_message_messageDomainType (void) {
  return "any domain" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeDomain::
message_messageDomainType (void) const {
  return "any domain" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_typeDomain'                        *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeDomain::
GGS_typeDomain (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeDomain::
GGS_typeDomain (const GGS_typeDomain & inOperand) {
  mPointer = (cPtr_typeDomain *) NULL ;
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeDomain::
~GGS_typeDomain (void) {
  macroDetachPointer (mPointer, cPtr_typeDomain) ;
}

//---------------------------------------------------------------------------*

void GGS_typeDomain::
operator = (const GGS_typeDomain & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeDomain::
reader_messageDomainType (C_Lexique & /* _inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  return GGS_string (mPointer != NULL, C_String ((mPointer == NULL) ? "" : mPointer->message_messageDomainType ())) ;
}

//---------------------------------------------------------------------------*

void GGS_typeDomain::
_drop_operation (void) {
  macroDetachPointer (mPointer, cPtr_typeDomain) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeDomain::
operator == (const GGS_typeDomain & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeDomain::
operator != (const GGS_typeDomain & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeDomain::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeDomain" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  abstract class 'cPtr_typeDirectDomain'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeDirectDomain::
cPtr_typeDirectDomain (const GGS_luint & argument_0,
                                const GGS_luint & argument_1,
                                const GGS_luint & argument_2 COMMA_LOCATION_ARGS)
:cPtr_typeDomain (THERE),
mLowBound (argument_0),
mHighBound (argument_1),
mBitsCount (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeDirectDomain * GGS_typeDirectDomain::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeDirectDomain *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeDirectDomain *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeDirectDomain::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeDirectDomain * _p = dynamic_cast <const cPtr_typeDirectDomain *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mLowBound == _p->mLowBound).boolValue ()
         && (mHighBound == _p->mHighBound).boolValue ()
         && (mBitsCount == _p->mBitsCount).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeDirectDomain::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeDirectDomain:"
           << mLowBound.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mHighBound.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mBitsCount.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeDirectDomain
::static_string_message_messageDomainType (void) {
  return "an interval domain" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeDirectDomain::
message_messageDomainType (void) const {
  return "an interval domain" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeDirectDomain'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeDirectDomain::
GGS_typeDirectDomain (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeDirectDomain::
GGS_typeDirectDomain (const GGS_typeDirectDomain & inOperand)
:GGS_typeDomain () {
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeDirectDomain::
~GGS_typeDirectDomain (void) {
  macroDetachPointer (mPointer, cPtr_typeDirectDomain) ;
}

//---------------------------------------------------------------------------*

void GGS_typeDirectDomain::
operator = (const GGS_typeDirectDomain & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeDirectDomain GGS_typeDirectDomain::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_luint & argument_0,
                 const GGS_luint & argument_1,
                 const GGS_luint & argument_2 COMMA_LOCATION_ARGS) {
  GGS_typeDirectDomain result ;
  macroMyNew (result.mPointer, cPtr_typeDirectDomain (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeDirectDomain::
reader_messageDomainType (C_Lexique & /* _inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  return GGS_string (mPointer != NULL, C_String ((mPointer == NULL) ? "" : mPointer->message_messageDomainType ())) ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_typeDirectDomain::
reader_mLowBound (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeDirectDomain *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeDirectDomain *) mPointer)->mLowBound ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_typeDirectDomain::
reader_mHighBound (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeDirectDomain *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeDirectDomain *) mPointer)->mHighBound ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_typeDirectDomain::
reader_mBitsCount (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeDirectDomain *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeDirectDomain *) mPointer)->mBitsCount ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeDirectDomain::
operator == (const GGS_typeDirectDomain & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeDirectDomain::
operator != (const GGS_typeDirectDomain & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeDirectDomain::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeDirectDomain" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class map 'typeDomainMap'                          *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeDomainMap::
elementOf_GGS_typeDomainMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_typeDomainMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeDomainMap::
appendForMapDescription (C_Lexique & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mDomain.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_typeDomainMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_typeDomainMap * _p = dynamic_cast <const elementOf_GGS_typeDomainMap *> (inOperand) ;
  macroValidPointer (_p) ;
  return (mInfo.mDomain == _p->mInfo.mDomain).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_typeDomainMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_typeDomainMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_typeDomainMap * info = (e_typeDomainMap *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_typeDomainMap GGS_typeDomainMap::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeDomainMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeDomainMap::
operator == (const GGS_typeDomainMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeDomainMap::
operator != (const GGS_typeDomainMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_typeDomainMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  const uint32 h = inPtr->mKey.hash () % MAP_ROOT_SIZE ;
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->_mRoot [h], extension, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_typeDomainMap::
_insertElement (C_Lexique & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_typeDomain & inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementIndex = - 1 ;
  if (_isBuilt ()
   && inParameter0._isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_typeDomainMap info  ;
    info.mDomain = inParameter0 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    const uint32 h = inKey.hash () % MAP_ROOT_SIZE ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->_mRoot [h], extension, elementIndex, existingKeyLocation) ;
    if (elementIndex < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementIndex >= 0, (uint32) elementIndex), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeDomainMap::
_searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_typeDomain   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0._drop_operation () ;
    if (outIndex != NULL) {
      outIndex->_drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mDomain ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeDomainMap::
method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_typeDomain   & outParameter0 COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "the '%K' domain is not declared",
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeDomainMap::
modifier_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_typeDomain & inParameter0 COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "the '%K' domain has been already declared",
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_typeDomainMap GGS_typeDomainMap::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_typeDomainMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeDomainMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeDomainMap GGS_typeDomainMap::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeDomainMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeDomainMap::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @typeDomainMap " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    sint32 elementIndex = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementIndex, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementIndex ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  abstract class 'cPtr_typeRecordDomain'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeRecordDomain::
cPtr_typeRecordDomain (const GGS_typeDomainMap & argument_0 COMMA_LOCATION_ARGS)
:cPtr_typeDomain (THERE),
mRecordMap (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeRecordDomain * GGS_typeRecordDomain::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeRecordDomain *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeRecordDomain *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeRecordDomain::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeRecordDomain * _p = dynamic_cast <const cPtr_typeRecordDomain *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mRecordMap == _p->mRecordMap).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeRecordDomain::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeRecordDomain:"
           << mRecordMap.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeRecordDomain
::static_string_message_messageDomainType (void) {
  return "a record domain" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeRecordDomain::
message_messageDomainType (void) const {
  return "a record domain" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeRecordDomain'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeRecordDomain::
GGS_typeRecordDomain (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeRecordDomain::
GGS_typeRecordDomain (const GGS_typeRecordDomain & inOperand)
:GGS_typeDomain () {
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeRecordDomain::
~GGS_typeRecordDomain (void) {
  macroDetachPointer (mPointer, cPtr_typeRecordDomain) ;
}

//---------------------------------------------------------------------------*

void GGS_typeRecordDomain::
operator = (const GGS_typeRecordDomain & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeRecordDomain GGS_typeRecordDomain::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_typeDomainMap & argument_0 COMMA_LOCATION_ARGS) {
  GGS_typeRecordDomain result ;
  macroMyNew (result.mPointer, cPtr_typeRecordDomain (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeRecordDomain::
reader_messageDomainType (C_Lexique & /* _inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  return GGS_string (mPointer != NULL, C_String ((mPointer == NULL) ? "" : mPointer->message_messageDomainType ())) ;
}

//---------------------------------------------------------------------------*

GGS_typeDomainMap  GGS_typeRecordDomain::
reader_mRecordMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeDomainMap   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeRecordDomain *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeRecordDomain *) mPointer)->mRecordMap ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeRecordDomain::
operator == (const GGS_typeRecordDomain & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeRecordDomain::
operator != (const GGS_typeRecordDomain & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeRecordDomain::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeRecordDomain" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@typeFormalArgumentsList'                 *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeFormalArgumentsList::
elementOf_GGS_typeFormalArgumentsList (const GGS_luint & argument_0,
                                const GGS_luint & argument_1,
                                const GGS_luint & argument_2,
                                const GGS_luint & argument_3):
mVariableIndex (argument_0),
mVariableBitSize (argument_1),
mLowBound (argument_2),
mHighBound (argument_3) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_typeFormalArgumentsList::
isEqualToElement (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_typeFormalArgumentsList * _p = dynamic_cast <const elementOf_GGS_typeFormalArgumentsList *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mVariableIndex == _p->mVariableIndex).boolValue ()
         && (mVariableBitSize == _p->mVariableBitSize).boolValue ()
         && (mLowBound == _p->mLowBound).boolValue ()
         && (mHighBound == _p->mHighBound).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeFormalArgumentsList::
appendForListDescription (C_Lexique & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mVariableIndex.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mVariableBitSize.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLowBound.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mHighBound.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     List '@typeFormalArgumentsList'                       *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeFormalArgumentsList::GGS_typeFormalArgumentsList (void): AC_galgas_list () { // Default Constructor
}

//---------------------------------------------------------------------------*

GGS_typeFormalArgumentsList::
GGS_typeFormalArgumentsList (const GGS_typeFormalArgumentsList & inSource): AC_galgas_list (inSource) {
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeFormalArgumentsList::
operator == (const GGS_typeFormalArgumentsList & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeFormalArgumentsList::
operator != (const GGS_typeFormalArgumentsList & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_typeFormalArgumentsList::
_internalAppendValues (const GGS_luint & argument_0,
                    const GGS_luint & argument_1,
                    const GGS_luint & argument_2,
                    const GGS_luint & argument_3) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2,
                                argument_3)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeFormalArgumentsList::
_internalPrependValues (const GGS_luint & argument_0,
                    const GGS_luint & argument_1,
                    const GGS_luint & argument_2,
                    const GGS_luint & argument_3) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2,
                                argument_3)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeFormalArgumentsList::
_addAssign_operation (const GGS_luint & argument_0,
                                const GGS_luint & argument_1,
                                const GGS_luint & argument_2,
                                const GGS_luint & argument_3) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3) ;
  }
}

//---------------------------------------------------------------------------*

GGS_typeFormalArgumentsList GGS_typeFormalArgumentsList::
operator + (const GGS_typeFormalArgumentsList & inOperand) const {
  GGS_typeFormalArgumentsList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        elementOf_GGS_typeFormalArgumentsList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_luint  p_0 = p->mVariableIndex ;
          GGS_luint  p_1 = p->mVariableBitSize ;
          GGS_luint  p_2 = p->mLowBound ;
          GGS_luint  p_3 = p->mHighBound ;
          result._internalAppendValues (p_0, p_1, p_2, p_3) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeFormalArgumentsList::
modifier_prependValue (C_Lexique & /* inLexique */,
                     const GGS_luint & argument_0,
                     const GGS_luint & argument_1,
                     const GGS_luint & argument_2,
                     const GGS_luint & argument_3
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeFormalArgumentsList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mVariableIndex,
                                _p->mVariableBitSize,
                                _p->mLowBound,
                                _p->mHighBound) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeFormalArgumentsList  GGS_typeFormalArgumentsList::
constructor_emptyList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeFormalArgumentsList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeFormalArgumentsList  GGS_typeFormalArgumentsList::
constructor_listWithValue (C_Lexique & /* _inLexique */,
                           const GGS_luint & argument_0,
                           const GGS_luint & argument_1,
                           const GGS_luint & argument_2,
                           const GGS_luint & argument_3
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeFormalArgumentsList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1, argument_2, argument_3) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeFormalArgumentsList::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@typeFormalArgumentsList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeFormalArgumentsList::
method_first (C_Lexique & _inLexique,
              GGS_luint & _out_0,
              GGS_luint & _out_1,
              GGS_luint & _out_2,
              GGS_luint & _out_3
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mVariableIndex ;
    _out_1 = _p->mVariableBitSize ;
    _out_2 = _p->mLowBound ;
    _out_3 = _p->mHighBound ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
    _out_3._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeFormalArgumentsList::
method_last (C_Lexique & _inLexique,
             GGS_luint & _out_0,
             GGS_luint & _out_1,
             GGS_luint & _out_2,
             GGS_luint & _out_3
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mVariableIndex ;
    _out_1 = _p->mVariableBitSize ;
    _out_2 = _p->mLowBound ;
    _out_3 = _p->mHighBound ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
    _out_3._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeFormalArgumentsList::
modifier_popFirst (C_Lexique & _inLexique,
                 GGS_luint & _out_0,
                 GGS_luint & _out_1,
                 GGS_luint & _out_2,
                 GGS_luint & _out_3
                 COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mVariableIndex ;
    _out_1 = _p->mVariableBitSize ;
    _out_2 = _p->mLowBound ;
    _out_3 = _p->mHighBound ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
    _out_3._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeFormalArgumentsList::
modifier_popLast (C_Lexique & _inLexique,
                GGS_luint & _out_0,
                GGS_luint & _out_1,
                GGS_luint & _out_2,
                GGS_luint & _out_3
                COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mVariableIndex ;
    _out_1 = _p->mVariableBitSize ;
    _out_2 = _p->mLowBound ;
    _out_3 = _p->mHighBound ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
    _out_3._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@typeActualArgumentsList'                 *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeActualArgumentsList::
elementOf_GGS_typeActualArgumentsList (const GGS_luint & argument_0,
                                const GGS_luint & argument_1,
                                const GGS_luint & argument_2,
                                const GGS_luint & argument_3,
                                const GGS_location & argument_4):
mVariableIndex (argument_0),
mVariableBitSize (argument_1),
mLowBound (argument_2),
mHighBound (argument_3),
mErrorLocation (argument_4) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_typeActualArgumentsList::
isEqualToElement (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_typeActualArgumentsList * _p = dynamic_cast <const elementOf_GGS_typeActualArgumentsList *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mVariableIndex == _p->mVariableIndex).boolValue ()
         && (mVariableBitSize == _p->mVariableBitSize).boolValue ()
         && (mLowBound == _p->mLowBound).boolValue ()
         && (mHighBound == _p->mHighBound).boolValue ()
         && (mErrorLocation == _p->mErrorLocation).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeActualArgumentsList::
appendForListDescription (C_Lexique & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mVariableIndex.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mVariableBitSize.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLowBound.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mHighBound.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mErrorLocation.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     List '@typeActualArgumentsList'                       *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeActualArgumentsList::GGS_typeActualArgumentsList (void): AC_galgas_list () { // Default Constructor
}

//---------------------------------------------------------------------------*

GGS_typeActualArgumentsList::
GGS_typeActualArgumentsList (const GGS_typeActualArgumentsList & inSource): AC_galgas_list (inSource) {
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeActualArgumentsList::
operator == (const GGS_typeActualArgumentsList & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeActualArgumentsList::
operator != (const GGS_typeActualArgumentsList & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_typeActualArgumentsList::
_internalAppendValues (const GGS_luint & argument_0,
                    const GGS_luint & argument_1,
                    const GGS_luint & argument_2,
                    const GGS_luint & argument_3,
                    const GGS_location & argument_4) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeActualArgumentsList::
_internalPrependValues (const GGS_luint & argument_0,
                    const GGS_luint & argument_1,
                    const GGS_luint & argument_2,
                    const GGS_luint & argument_3,
                    const GGS_location & argument_4) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeActualArgumentsList::
_addAssign_operation (const GGS_luint & argument_0,
                                const GGS_luint & argument_1,
                                const GGS_luint & argument_2,
                                const GGS_luint & argument_3,
                                const GGS_location & argument_4) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4) ;
  }
}

//---------------------------------------------------------------------------*

GGS_typeActualArgumentsList GGS_typeActualArgumentsList::
operator + (const GGS_typeActualArgumentsList & inOperand) const {
  GGS_typeActualArgumentsList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        elementOf_GGS_typeActualArgumentsList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_luint  p_0 = p->mVariableIndex ;
          GGS_luint  p_1 = p->mVariableBitSize ;
          GGS_luint  p_2 = p->mLowBound ;
          GGS_luint  p_3 = p->mHighBound ;
          GGS_location  p_4 = p->mErrorLocation ;
          result._internalAppendValues (p_0, p_1, p_2, p_3, p_4) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeActualArgumentsList::
modifier_prependValue (C_Lexique & /* inLexique */,
                     const GGS_luint & argument_0,
                     const GGS_luint & argument_1,
                     const GGS_luint & argument_2,
                     const GGS_luint & argument_3,
                     const GGS_location & argument_4
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeActualArgumentsList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mVariableIndex,
                                _p->mVariableBitSize,
                                _p->mLowBound,
                                _p->mHighBound,
                                _p->mErrorLocation) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeActualArgumentsList  GGS_typeActualArgumentsList::
constructor_emptyList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeActualArgumentsList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeActualArgumentsList  GGS_typeActualArgumentsList::
constructor_listWithValue (C_Lexique & /* _inLexique */,
                           const GGS_luint & argument_0,
                           const GGS_luint & argument_1,
                           const GGS_luint & argument_2,
                           const GGS_luint & argument_3,
                           const GGS_location & argument_4
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeActualArgumentsList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1, argument_2, argument_3, argument_4) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeActualArgumentsList::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@typeActualArgumentsList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeActualArgumentsList::
method_first (C_Lexique & _inLexique,
              GGS_luint & _out_0,
              GGS_luint & _out_1,
              GGS_luint & _out_2,
              GGS_luint & _out_3,
              GGS_location & _out_4
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mVariableIndex ;
    _out_1 = _p->mVariableBitSize ;
    _out_2 = _p->mLowBound ;
    _out_3 = _p->mHighBound ;
    _out_4 = _p->mErrorLocation ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
    _out_3._drop_operation () ;
    _out_4._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeActualArgumentsList::
method_last (C_Lexique & _inLexique,
             GGS_luint & _out_0,
             GGS_luint & _out_1,
             GGS_luint & _out_2,
             GGS_luint & _out_3,
             GGS_location & _out_4
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mVariableIndex ;
    _out_1 = _p->mVariableBitSize ;
    _out_2 = _p->mLowBound ;
    _out_3 = _p->mHighBound ;
    _out_4 = _p->mErrorLocation ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
    _out_3._drop_operation () ;
    _out_4._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeActualArgumentsList::
modifier_popFirst (C_Lexique & _inLexique,
                 GGS_luint & _out_0,
                 GGS_luint & _out_1,
                 GGS_luint & _out_2,
                 GGS_luint & _out_3,
                 GGS_location & _out_4
                 COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mVariableIndex ;
    _out_1 = _p->mVariableBitSize ;
    _out_2 = _p->mLowBound ;
    _out_3 = _p->mHighBound ;
    _out_4 = _p->mErrorLocation ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
    _out_3._drop_operation () ;
    _out_4._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeActualArgumentsList::
modifier_popLast (C_Lexique & _inLexique,
                GGS_luint & _out_0,
                GGS_luint & _out_1,
                GGS_luint & _out_2,
                GGS_luint & _out_3,
                GGS_location & _out_4
                COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mVariableIndex ;
    _out_1 = _p->mVariableBitSize ;
    _out_2 = _p->mLowBound ;
    _out_3 = _p->mHighBound ;
    _out_4 = _p->mErrorLocation ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
    _out_3._drop_operation () ;
    _out_4._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*
//                                                                           *
//               abstract class 'cPtr_typeVariableDescriptor'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeVariableDescriptor::
cPtr_typeVariableDescriptor (LOCATION_ARGS)
:C_GGS_Object (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeVariableDescriptor * GGS_typeVariableDescriptor::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
      return mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_typeVariableDescriptor::
appendForDescription (C_Lexique & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeVariableDescriptor:" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeVariableDescriptor
::static_string_message_variableDescriptorErrorMessage (void) {
  return "any variable" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeVariableDescriptor::
message_variableDescriptorErrorMessage (void) const {
  return "any variable" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_typeVariableDescriptor'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeVariableDescriptor::
GGS_typeVariableDescriptor (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeVariableDescriptor::
GGS_typeVariableDescriptor (const GGS_typeVariableDescriptor & inOperand) {
  mPointer = (cPtr_typeVariableDescriptor *) NULL ;
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeVariableDescriptor::
~GGS_typeVariableDescriptor (void) {
  macroDetachPointer (mPointer, cPtr_typeVariableDescriptor) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariableDescriptor::
operator = (const GGS_typeVariableDescriptor & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeVariableDescriptor::
reader_variableDescriptorErrorMessage (C_Lexique & /* _inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  return GGS_string (mPointer != NULL, C_String ((mPointer == NULL) ? "" : mPointer->message_variableDescriptorErrorMessage ())) ;
}

//---------------------------------------------------------------------------*

void GGS_typeVariableDescriptor::
_drop_operation (void) {
  macroDetachPointer (mPointer, cPtr_typeVariableDescriptor) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeVariableDescriptor::
operator == (const GGS_typeVariableDescriptor & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeVariableDescriptor::
operator != (const GGS_typeVariableDescriptor & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeVariableDescriptor::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeVariableDescriptor" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 abstract class 'cPtr_typeDirectVariable'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeDirectVariable::
cPtr_typeDirectVariable (const GGS_luint & argument_0,
                                const GGS_luint & argument_1,
                                const GGS_luint & argument_2,
                                const GGS_luint & argument_3 COMMA_LOCATION_ARGS)
:cPtr_typeVariableDescriptor (THERE),
mIndex (argument_0),
mBitSize (argument_1),
mLowBound (argument_2),
mHighBound (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeDirectVariable * GGS_typeDirectVariable::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeDirectVariable *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeDirectVariable *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeDirectVariable::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeDirectVariable * _p = dynamic_cast <const cPtr_typeDirectVariable *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mIndex == _p->mIndex).boolValue ()
         && (mBitSize == _p->mBitSize).boolValue ()
         && (mLowBound == _p->mLowBound).boolValue ()
         && (mHighBound == _p->mHighBound).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeDirectVariable::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeDirectVariable:"
           << mIndex.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mBitSize.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mLowBound.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mHighBound.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeDirectVariable
::static_string_message_variableDescriptorErrorMessage (void) {
  return "a direct domain variable" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeDirectVariable::
message_variableDescriptorErrorMessage (void) const {
  return "a direct domain variable" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeDirectVariable'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeDirectVariable::
GGS_typeDirectVariable (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeDirectVariable::
GGS_typeDirectVariable (const GGS_typeDirectVariable & inOperand)
:GGS_typeVariableDescriptor () {
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeDirectVariable::
~GGS_typeDirectVariable (void) {
  macroDetachPointer (mPointer, cPtr_typeDirectVariable) ;
}

//---------------------------------------------------------------------------*

void GGS_typeDirectVariable::
operator = (const GGS_typeDirectVariable & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeDirectVariable GGS_typeDirectVariable::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_luint & argument_0,
                 const GGS_luint & argument_1,
                 const GGS_luint & argument_2,
                 const GGS_luint & argument_3 COMMA_LOCATION_ARGS) {
  GGS_typeDirectVariable result ;
  macroMyNew (result.mPointer, cPtr_typeDirectVariable (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeDirectVariable::
reader_variableDescriptorErrorMessage (C_Lexique & /* _inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  return GGS_string (mPointer != NULL, C_String ((mPointer == NULL) ? "" : mPointer->message_variableDescriptorErrorMessage ())) ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_typeDirectVariable::
reader_mIndex (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeDirectVariable *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeDirectVariable *) mPointer)->mIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_typeDirectVariable::
reader_mBitSize (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeDirectVariable *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeDirectVariable *) mPointer)->mBitSize ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_typeDirectVariable::
reader_mLowBound (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeDirectVariable *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeDirectVariable *) mPointer)->mLowBound ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_typeDirectVariable::
reader_mHighBound (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeDirectVariable *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeDirectVariable *) mPointer)->mHighBound ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeDirectVariable::
operator == (const GGS_typeDirectVariable & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeDirectVariable::
operator != (const GGS_typeDirectVariable & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeDirectVariable::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeDirectVariable" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class map 'typeTableVariablesBool'                     *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeTableVariablesBool::
elementOf_GGS_typeTableVariablesBool (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_typeTableVariablesBool & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeTableVariablesBool::
appendForMapDescription (C_Lexique & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mVariableDescriptor.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_typeTableVariablesBool::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_typeTableVariablesBool * _p = dynamic_cast <const elementOf_GGS_typeTableVariablesBool *> (inOperand) ;
  macroValidPointer (_p) ;
  return (mInfo.mVariableDescriptor == _p->mInfo.mVariableDescriptor).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_typeTableVariablesBool::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_typeTableVariablesBool *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_typeTableVariablesBool * info = (e_typeTableVariablesBool *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_typeTableVariablesBool GGS_typeTableVariablesBool::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeTableVariablesBool result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeTableVariablesBool::
operator == (const GGS_typeTableVariablesBool & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeTableVariablesBool::
operator != (const GGS_typeTableVariablesBool & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableVariablesBool::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  const uint32 h = inPtr->mKey.hash () % MAP_ROOT_SIZE ;
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->_mRoot [h], extension, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableVariablesBool::
_insertElement (C_Lexique & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_typeVariableDescriptor & inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementIndex = - 1 ;
  if (_isBuilt ()
   && inParameter0._isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_typeTableVariablesBool info  ;
    info.mVariableDescriptor = inParameter0 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    const uint32 h = inKey.hash () % MAP_ROOT_SIZE ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->_mRoot [h], extension, elementIndex, existingKeyLocation) ;
    if (elementIndex < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementIndex >= 0, (uint32) elementIndex), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTableVariablesBool::
_searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_typeVariableDescriptor   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0._drop_operation () ;
    if (outIndex != NULL) {
      outIndex->_drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mVariableDescriptor ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTableVariablesBool::
method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_typeVariableDescriptor   & outParameter0 COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "the '%K' variable is not declared",
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableVariablesBool::
modifier_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_typeVariableDescriptor & inParameter0 COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "the '%K' variable has been already declared",
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_typeTableVariablesBool GGS_typeTableVariablesBool::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_typeTableVariablesBool & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeTableVariablesBool result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeTableVariablesBool GGS_typeTableVariablesBool::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeTableVariablesBool result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeTableVariablesBool::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @typeTableVariablesBool " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    sint32 elementIndex = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementIndex, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementIndex ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 abstract class 'cPtr_typeRecordVariable'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeRecordVariable::
cPtr_typeRecordVariable (const GGS_typeTableVariablesBool & argument_0 COMMA_LOCATION_ARGS)
:cPtr_typeVariableDescriptor (THERE),
mMap (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeRecordVariable * GGS_typeRecordVariable::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeRecordVariable *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeRecordVariable *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeRecordVariable::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeRecordVariable * _p = dynamic_cast <const cPtr_typeRecordVariable *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mMap == _p->mMap).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeRecordVariable::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeRecordVariable:"
           << mMap.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeRecordVariable
::static_string_message_variableDescriptorErrorMessage (void) {
  return "a record domain variable" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeRecordVariable::
message_variableDescriptorErrorMessage (void) const {
  return "a record domain variable" ;
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeRecordVariable'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeRecordVariable::
GGS_typeRecordVariable (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeRecordVariable::
GGS_typeRecordVariable (const GGS_typeRecordVariable & inOperand)
:GGS_typeVariableDescriptor () {
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeRecordVariable::
~GGS_typeRecordVariable (void) {
  macroDetachPointer (mPointer, cPtr_typeRecordVariable) ;
}

//---------------------------------------------------------------------------*

void GGS_typeRecordVariable::
operator = (const GGS_typeRecordVariable & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeRecordVariable GGS_typeRecordVariable::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_typeTableVariablesBool & argument_0 COMMA_LOCATION_ARGS) {
  GGS_typeRecordVariable result ;
  macroMyNew (result.mPointer, cPtr_typeRecordVariable (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeRecordVariable::
reader_variableDescriptorErrorMessage (C_Lexique & /* _inLexique */
                            COMMA_UNUSED_LOCATION_ARGS) const {
  return GGS_string (mPointer != NULL, C_String ((mPointer == NULL) ? "" : mPointer->message_variableDescriptorErrorMessage ())) ;
}

//---------------------------------------------------------------------------*

GGS_typeTableVariablesBool  GGS_typeRecordVariable::
reader_mMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeTableVariablesBool   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeRecordVariable *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeRecordVariable *) mPointer)->mMap ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeRecordVariable::
operator == (const GGS_typeRecordVariable & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeRecordVariable::
operator != (const GGS_typeRecordVariable & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeRecordVariable::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeRecordVariable" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class map 'typeTableFormules'                        *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeTableFormules::
elementOf_GGS_typeTableFormules (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_typeTableFormules & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeTableFormules::
appendForMapDescription (C_Lexique & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.aListeArgsFormelsBool.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.aBDD.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_typeTableFormules::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_typeTableFormules * _p = dynamic_cast <const elementOf_GGS_typeTableFormules *> (inOperand) ;
  macroValidPointer (_p) ;
  return (mInfo.aListeArgsFormelsBool == _p->mInfo.aListeArgsFormelsBool).boolValue ()
           && (mInfo.aBDD == _p->mInfo.aBDD).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_typeTableFormules::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_typeTableFormules *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_typeTableFormules * info = (e_typeTableFormules *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_typeTableFormules GGS_typeTableFormules::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeTableFormules result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeTableFormules::
operator == (const GGS_typeTableFormules & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeTableFormules::
operator != (const GGS_typeTableFormules & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableFormules::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  const uint32 h = inPtr->mKey.hash () % MAP_ROOT_SIZE ;
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->_mRoot [h], extension, attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableFormules::
_insertElement (C_Lexique & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_typeFormalArgumentsList & inParameter0,
                const GGS_extern_bdd& inParameter1,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementIndex = - 1 ;
  if (_isBuilt ()
   && inParameter0._isBuilt ()
   && inParameter1._isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_typeTableFormules info  ;
    info.aListeArgsFormelsBool = inParameter0 ;
    info.aBDD = inParameter1 ;
    bool extension = false ; // Unused here
    GGS_location existingKeyLocation ;
    const uint32 h = inKey.hash () % MAP_ROOT_SIZE ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->_mRoot [h], extension, elementIndex, existingKeyLocation) ;
    if (elementIndex < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementIndex >= 0, (uint32) elementIndex), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTableFormules::
_searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_typeFormalArgumentsList   & outParameter0,
               GGS_extern_bdd  & outParameter1,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0._drop_operation () ;
    outParameter1._drop_operation () ;
    if (outIndex != NULL) {
      outIndex->_drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.aListeArgsFormelsBool ;
    outParameter1 = node->mInfo.aBDD ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTableFormules::
method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_typeFormalArgumentsList   & outParameter0,
                                GGS_extern_bdd  & outParameter1 COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "the '#%K' formula is not defined",
                  inKey,
                  outParameter0,
                  outParameter1,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableFormules::
method_searchKeyGetIndex (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                GGS_typeFormalArgumentsList   & outParameter0,
                                GGS_extern_bdd  & outParameter1 COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "the '#%K' formula is not defined",
                  inKey,
                  outParameter0,
                  outParameter1,
                  & outIndex
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableFormules::
modifier_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_typeFormalArgumentsList & inParameter0,
                                const GGS_extern_bdd& inParameter1 COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "the '#%K' formula is already defined",
                 inKey,
                 inParameter0,
                 inParameter1,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableFormules::
modifier_insertKeyGetIndex (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                const GGS_typeFormalArgumentsList & inParameter0,
                                const GGS_extern_bdd& inParameter1 COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "the '#%K' formula is already defined",
                 inKey,
                 inParameter0,
                 inParameter1,
                 & outIndex
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_typeTableFormules GGS_typeTableFormules::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_typeTableFormules & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeTableFormules result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeTableFormules GGS_typeTableFormules::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeTableFormules result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeTableFormules::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @typeTableFormules " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    sint32 elementIndex = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementIndex, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementIndex ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    abstract class 'cPtr_typeFormule'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeFormule::
cPtr_typeFormule (LOCATION_ARGS)
:C_GGS_Object (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeFormule * GGS_typeFormule::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
      return mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_typeFormule::
appendForDescription (C_Lexique & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeFormule:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_typeFormule'                       *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeFormule::
GGS_typeFormule (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeFormule::
GGS_typeFormule (const GGS_typeFormule & inOperand) {
  mPointer = (cPtr_typeFormule *) NULL ;
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeFormule::
~GGS_typeFormule (void) {
  macroDetachPointer (mPointer, cPtr_typeFormule) ;
}

//---------------------------------------------------------------------------*

void GGS_typeFormule::
operator = (const GGS_typeFormule & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

void GGS_typeFormule::
_drop_operation (void) {
  macroDetachPointer (mPointer, cPtr_typeFormule) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeFormule::
operator == (const GGS_typeFormule & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeFormule::
operator != (const GGS_typeFormule & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeFormule::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeFormule" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  abstract class 'cPtr_typeFormuleTrue'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeFormuleTrue::
cPtr_typeFormuleTrue (LOCATION_ARGS)
:cPtr_typeFormule (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeFormuleTrue * GGS_typeFormuleTrue::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFormuleTrue *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeFormuleTrue *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeFormuleTrue::
isEqualToObject (const C_GGS_Object * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeFormuleTrue::
appendForDescription (C_Lexique & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeFormuleTrue:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeFormuleTrue'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeFormuleTrue::
GGS_typeFormuleTrue (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeFormuleTrue::
GGS_typeFormuleTrue (const GGS_typeFormuleTrue & inOperand)
:GGS_typeFormule () {
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeFormuleTrue::
~GGS_typeFormuleTrue (void) {
  macroDetachPointer (mPointer, cPtr_typeFormuleTrue) ;
}

//---------------------------------------------------------------------------*

void GGS_typeFormuleTrue::
operator = (const GGS_typeFormuleTrue & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeFormuleTrue GGS_typeFormuleTrue::
constructor_new (C_Lexique & /* inLexique */ COMMA_LOCATION_ARGS) {
  GGS_typeFormuleTrue result ;
  macroMyNew (result.mPointer, cPtr_typeFormuleTrue (THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeFormuleTrue::
operator == (const GGS_typeFormuleTrue & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeFormuleTrue::
operator != (const GGS_typeFormuleTrue & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeFormuleTrue::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeFormuleTrue" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  abstract class 'cPtr_typeFormuleFalse'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeFormuleFalse::
cPtr_typeFormuleFalse (LOCATION_ARGS)
:cPtr_typeFormule (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeFormuleFalse * GGS_typeFormuleFalse::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFormuleFalse *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeFormuleFalse *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeFormuleFalse::
isEqualToObject (const C_GGS_Object * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeFormuleFalse::
appendForDescription (C_Lexique & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeFormuleFalse:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeFormuleFalse'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeFormuleFalse::
GGS_typeFormuleFalse (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeFormuleFalse::
GGS_typeFormuleFalse (const GGS_typeFormuleFalse & inOperand)
:GGS_typeFormule () {
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeFormuleFalse::
~GGS_typeFormuleFalse (void) {
  macroDetachPointer (mPointer, cPtr_typeFormuleFalse) ;
}

//---------------------------------------------------------------------------*

void GGS_typeFormuleFalse::
operator = (const GGS_typeFormuleFalse & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeFormuleFalse GGS_typeFormuleFalse::
constructor_new (C_Lexique & /* inLexique */ COMMA_LOCATION_ARGS) {
  GGS_typeFormuleFalse result ;
  macroMyNew (result.mPointer, cPtr_typeFormuleFalse (THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeFormuleFalse::
operator == (const GGS_typeFormuleFalse & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeFormuleFalse::
operator != (const GGS_typeFormuleFalse & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeFormuleFalse::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeFormuleFalse" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   abstract class 'cPtr_typeFormuleVar'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeFormuleVar::
cPtr_typeFormuleVar (const GGS_luint & argument_0,
                                const GGS_luint & argument_1,
                                const GGS_luint & argument_2 COMMA_LOCATION_ARGS)
:cPtr_typeFormule (THERE),
mNumeroVariable (argument_0),
mLowBound (argument_1),
mHighBound (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeFormuleVar * GGS_typeFormuleVar::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFormuleVar *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeFormuleVar *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeFormuleVar::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeFormuleVar * _p = dynamic_cast <const cPtr_typeFormuleVar *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mNumeroVariable == _p->mNumeroVariable).boolValue ()
         && (mLowBound == _p->mLowBound).boolValue ()
         && (mHighBound == _p->mHighBound).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeFormuleVar::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeFormuleVar:"
           << mNumeroVariable.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mLowBound.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mHighBound.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeFormuleVar'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeFormuleVar::
GGS_typeFormuleVar (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeFormuleVar::
GGS_typeFormuleVar (const GGS_typeFormuleVar & inOperand)
:GGS_typeFormule () {
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeFormuleVar::
~GGS_typeFormuleVar (void) {
  macroDetachPointer (mPointer, cPtr_typeFormuleVar) ;
}

//---------------------------------------------------------------------------*

void GGS_typeFormuleVar::
operator = (const GGS_typeFormuleVar & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeFormuleVar GGS_typeFormuleVar::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_luint & argument_0,
                 const GGS_luint & argument_1,
                 const GGS_luint & argument_2 COMMA_LOCATION_ARGS) {
  GGS_typeFormuleVar result ;
  macroMyNew (result.mPointer, cPtr_typeFormuleVar (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_typeFormuleVar::
reader_mNumeroVariable (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFormuleVar *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeFormuleVar *) mPointer)->mNumeroVariable ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_typeFormuleVar::
reader_mLowBound (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFormuleVar *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeFormuleVar *) mPointer)->mLowBound ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_typeFormuleVar::
reader_mHighBound (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFormuleVar *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeFormuleVar *) mPointer)->mHighBound ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeFormuleVar::
operator == (const GGS_typeFormuleVar & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeFormuleVar::
operator != (const GGS_typeFormuleVar & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeFormuleVar::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeFormuleVar" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   abstract class 'cPtr_typeFormuleFor'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeFormuleFor::
cPtr_typeFormuleFor (const GGS_luint & argument_0,
                                const GGS_typeActualArgumentsList & argument_1,
                                const GGS_extern_bdd& argument_2,
                                const GGS_lbool & argument_3 COMMA_LOCATION_ARGS)
:cPtr_typeFormule (THERE),
mNumeroFormule (argument_0),
mListeArgsBool (argument_1),
mFormuleTraduite (argument_2),
mEstFormuleCourante (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeFormuleFor * GGS_typeFormuleFor::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFormuleFor *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeFormuleFor *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeFormuleFor::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeFormuleFor * _p = dynamic_cast <const cPtr_typeFormuleFor *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mNumeroFormule == _p->mNumeroFormule).boolValue ()
         && (mListeArgsBool == _p->mListeArgsBool).boolValue ()
         && (mFormuleTraduite == _p->mFormuleTraduite).boolValue ()
         && (mEstFormuleCourante == _p->mEstFormuleCourante).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeFormuleFor::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeFormuleFor:"
           << mNumeroFormule.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mListeArgsBool.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mFormuleTraduite.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mEstFormuleCourante.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeFormuleFor'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeFormuleFor::
GGS_typeFormuleFor (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeFormuleFor::
GGS_typeFormuleFor (const GGS_typeFormuleFor & inOperand)
:GGS_typeFormule () {
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeFormuleFor::
~GGS_typeFormuleFor (void) {
  macroDetachPointer (mPointer, cPtr_typeFormuleFor) ;
}

//---------------------------------------------------------------------------*

void GGS_typeFormuleFor::
operator = (const GGS_typeFormuleFor & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeFormuleFor GGS_typeFormuleFor::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_luint & argument_0,
                 const GGS_typeActualArgumentsList & argument_1,
                 const GGS_extern_bdd& argument_2,
                 const GGS_lbool & argument_3 COMMA_LOCATION_ARGS) {
  GGS_typeFormuleFor result ;
  macroMyNew (result.mPointer, cPtr_typeFormuleFor (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_typeFormuleFor::
reader_mNumeroFormule (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFormuleFor *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeFormuleFor *) mPointer)->mNumeroFormule ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeActualArgumentsList  GGS_typeFormuleFor::
reader_mListeArgsBool (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeActualArgumentsList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFormuleFor *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeFormuleFor *) mPointer)->mListeArgsBool ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_extern_bdd GGS_typeFormuleFor::
reader_mFormuleTraduite (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_extern_bdd  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFormuleFor *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeFormuleFor *) mPointer)->mFormuleTraduite ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lbool  GGS_typeFormuleFor::
reader_mEstFormuleCourante (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lbool   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFormuleFor *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeFormuleFor *) mPointer)->mEstFormuleCourante ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeFormuleFor::
operator == (const GGS_typeFormuleFor & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeFormuleFor::
operator != (const GGS_typeFormuleFor & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeFormuleFor::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeFormuleFor" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   abstract class 'cPtr_typeFormuleNon'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeFormuleNon::
cPtr_typeFormuleNon (const GGS_typeFormule & argument_0 COMMA_LOCATION_ARGS)
:cPtr_typeFormule (THERE),
mOperand (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeFormuleNon * GGS_typeFormuleNon::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFormuleNon *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeFormuleNon *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeFormuleNon::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeFormuleNon * _p = dynamic_cast <const cPtr_typeFormuleNon *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mOperand == _p->mOperand).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeFormuleNon::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeFormuleNon:"
           << mOperand.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeFormuleNon'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeFormuleNon::
GGS_typeFormuleNon (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeFormuleNon::
GGS_typeFormuleNon (const GGS_typeFormuleNon & inOperand)
:GGS_typeFormule () {
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeFormuleNon::
~GGS_typeFormuleNon (void) {
  macroDetachPointer (mPointer, cPtr_typeFormuleNon) ;
}

//---------------------------------------------------------------------------*

void GGS_typeFormuleNon::
operator = (const GGS_typeFormuleNon & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeFormuleNon GGS_typeFormuleNon::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_typeFormule & argument_0 COMMA_LOCATION_ARGS) {
  GGS_typeFormuleNon result ;
  macroMyNew (result.mPointer, cPtr_typeFormuleNon (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeFormule  GGS_typeFormuleNon::
reader_mOperand (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeFormule   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFormuleNon *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeFormuleNon *) mPointer)->mOperand ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeFormuleNon::
operator == (const GGS_typeFormuleNon & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeFormuleNon::
operator != (const GGS_typeFormuleNon & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeFormuleNon::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeFormuleNon" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   abstract class 'cPtr_typeFormuleEt'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeFormuleEt::
cPtr_typeFormuleEt (const GGS_typeFormule & argument_0,
                                const GGS_typeFormule & argument_1 COMMA_LOCATION_ARGS)
:cPtr_typeFormule (THERE),
mOperand1 (argument_0),
mOperand2 (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeFormuleEt * GGS_typeFormuleEt::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFormuleEt *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeFormuleEt *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeFormuleEt::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeFormuleEt * _p = dynamic_cast <const cPtr_typeFormuleEt *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mOperand1 == _p->mOperand1).boolValue ()
         && (mOperand2 == _p->mOperand2).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeFormuleEt::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeFormuleEt:"
           << mOperand1.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mOperand2.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_typeFormuleEt'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeFormuleEt::
GGS_typeFormuleEt (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeFormuleEt::
GGS_typeFormuleEt (const GGS_typeFormuleEt & inOperand)
:GGS_typeFormule () {
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeFormuleEt::
~GGS_typeFormuleEt (void) {
  macroDetachPointer (mPointer, cPtr_typeFormuleEt) ;
}

//---------------------------------------------------------------------------*

void GGS_typeFormuleEt::
operator = (const GGS_typeFormuleEt & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeFormuleEt GGS_typeFormuleEt::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_typeFormule & argument_0,
                 const GGS_typeFormule & argument_1 COMMA_LOCATION_ARGS) {
  GGS_typeFormuleEt result ;
  macroMyNew (result.mPointer, cPtr_typeFormuleEt (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeFormule  GGS_typeFormuleEt::
reader_mOperand1 (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeFormule   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFormuleEt *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeFormuleEt *) mPointer)->mOperand1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeFormule  GGS_typeFormuleEt::
reader_mOperand2 (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeFormule   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFormuleEt *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeFormuleEt *) mPointer)->mOperand2 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeFormuleEt::
operator == (const GGS_typeFormuleEt & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeFormuleEt::
operator != (const GGS_typeFormuleEt & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeFormuleEt::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeFormuleEt" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   abstract class 'cPtr_typeFormuleIte'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeFormuleIte::
cPtr_typeFormuleIte (const GGS_typeFormule & argument_0,
                                const GGS_typeFormule & argument_1,
                                const GGS_typeFormule & argument_2 COMMA_LOCATION_ARGS)
:cPtr_typeFormule (THERE),
mOperand1 (argument_0),
mOperand2 (argument_1),
mOperand3 (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeFormuleIte * GGS_typeFormuleIte::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFormuleIte *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeFormuleIte *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeFormuleIte::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeFormuleIte * _p = dynamic_cast <const cPtr_typeFormuleIte *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mOperand1 == _p->mOperand1).boolValue ()
         && (mOperand2 == _p->mOperand2).boolValue ()
         && (mOperand3 == _p->mOperand3).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeFormuleIte::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeFormuleIte:"
           << mOperand1.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mOperand2.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mOperand3.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeFormuleIte'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeFormuleIte::
GGS_typeFormuleIte (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeFormuleIte::
GGS_typeFormuleIte (const GGS_typeFormuleIte & inOperand)
:GGS_typeFormule () {
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeFormuleIte::
~GGS_typeFormuleIte (void) {
  macroDetachPointer (mPointer, cPtr_typeFormuleIte) ;
}

//---------------------------------------------------------------------------*

void GGS_typeFormuleIte::
operator = (const GGS_typeFormuleIte & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeFormuleIte GGS_typeFormuleIte::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_typeFormule & argument_0,
                 const GGS_typeFormule & argument_1,
                 const GGS_typeFormule & argument_2 COMMA_LOCATION_ARGS) {
  GGS_typeFormuleIte result ;
  macroMyNew (result.mPointer, cPtr_typeFormuleIte (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeFormule  GGS_typeFormuleIte::
reader_mOperand1 (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeFormule   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFormuleIte *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeFormuleIte *) mPointer)->mOperand1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeFormule  GGS_typeFormuleIte::
reader_mOperand2 (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeFormule   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFormuleIte *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeFormuleIte *) mPointer)->mOperand2 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeFormule  GGS_typeFormuleIte::
reader_mOperand3 (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeFormule   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFormuleIte *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeFormuleIte *) mPointer)->mOperand3 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeFormuleIte::
operator == (const GGS_typeFormuleIte & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeFormuleIte::
operator != (const GGS_typeFormuleIte & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeFormuleIte::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeFormuleIte" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   abstract class 'cPtr_typeFormuleOu'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeFormuleOu::
cPtr_typeFormuleOu (const GGS_typeFormule & argument_0,
                                const GGS_typeFormule & argument_1 COMMA_LOCATION_ARGS)
:cPtr_typeFormule (THERE),
mOperand1 (argument_0),
mOperand2 (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeFormuleOu * GGS_typeFormuleOu::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFormuleOu *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeFormuleOu *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeFormuleOu::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeFormuleOu * _p = dynamic_cast <const cPtr_typeFormuleOu *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mOperand1 == _p->mOperand1).boolValue ()
         && (mOperand2 == _p->mOperand2).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeFormuleOu::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeFormuleOu:"
           << mOperand1.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mOperand2.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_typeFormuleOu'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeFormuleOu::
GGS_typeFormuleOu (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeFormuleOu::
GGS_typeFormuleOu (const GGS_typeFormuleOu & inOperand)
:GGS_typeFormule () {
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeFormuleOu::
~GGS_typeFormuleOu (void) {
  macroDetachPointer (mPointer, cPtr_typeFormuleOu) ;
}

//---------------------------------------------------------------------------*

void GGS_typeFormuleOu::
operator = (const GGS_typeFormuleOu & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeFormuleOu GGS_typeFormuleOu::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_typeFormule & argument_0,
                 const GGS_typeFormule & argument_1 COMMA_LOCATION_ARGS) {
  GGS_typeFormuleOu result ;
  macroMyNew (result.mPointer, cPtr_typeFormuleOu (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeFormule  GGS_typeFormuleOu::
reader_mOperand1 (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeFormule   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFormuleOu *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeFormuleOu *) mPointer)->mOperand1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeFormule  GGS_typeFormuleOu::
reader_mOperand2 (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeFormule   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFormuleOu *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeFormuleOu *) mPointer)->mOperand2 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeFormuleOu::
operator == (const GGS_typeFormuleOu & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeFormuleOu::
operator != (const GGS_typeFormuleOu & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeFormuleOu::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeFormuleOu" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                abstract class 'cPtr_typeFormuleImplique'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeFormuleImplique::
cPtr_typeFormuleImplique (const GGS_typeFormule & argument_0,
                                const GGS_typeFormule & argument_1 COMMA_LOCATION_ARGS)
:cPtr_typeFormule (THERE),
mOperand1 (argument_0),
mOperand2 (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeFormuleImplique * GGS_typeFormuleImplique::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFormuleImplique *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeFormuleImplique *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeFormuleImplique::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeFormuleImplique * _p = dynamic_cast <const cPtr_typeFormuleImplique *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mOperand1 == _p->mOperand1).boolValue ()
         && (mOperand2 == _p->mOperand2).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeFormuleImplique::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeFormuleImplique:"
           << mOperand1.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mOperand2.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeFormuleImplique'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeFormuleImplique::
GGS_typeFormuleImplique (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeFormuleImplique::
GGS_typeFormuleImplique (const GGS_typeFormuleImplique & inOperand)
:GGS_typeFormule () {
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeFormuleImplique::
~GGS_typeFormuleImplique (void) {
  macroDetachPointer (mPointer, cPtr_typeFormuleImplique) ;
}

//---------------------------------------------------------------------------*

void GGS_typeFormuleImplique::
operator = (const GGS_typeFormuleImplique & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeFormuleImplique GGS_typeFormuleImplique::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_typeFormule & argument_0,
                 const GGS_typeFormule & argument_1 COMMA_LOCATION_ARGS) {
  GGS_typeFormuleImplique result ;
  macroMyNew (result.mPointer, cPtr_typeFormuleImplique (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeFormule  GGS_typeFormuleImplique::
reader_mOperand1 (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeFormule   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFormuleImplique *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeFormuleImplique *) mPointer)->mOperand1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeFormule  GGS_typeFormuleImplique::
reader_mOperand2 (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeFormule   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFormuleImplique *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeFormuleImplique *) mPointer)->mOperand2 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeFormuleImplique::
operator == (const GGS_typeFormuleImplique & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeFormuleImplique::
operator != (const GGS_typeFormuleImplique & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeFormuleImplique::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeFormuleImplique" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              abstract class 'cPtr_typeComparaisonFormules'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeComparaisonFormules::
cPtr_typeComparaisonFormules (const GGS_luint & argument_0,
                                const GGS_typeFormule & argument_1,
                                const GGS_typeFormule & argument_2 COMMA_LOCATION_ARGS)
:cPtr_typeFormule (THERE),
mComparaison (argument_0),
mOperand1 (argument_1),
mOperand2 (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeComparaisonFormules * GGS_typeComparaisonFormules::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeComparaisonFormules *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeComparaisonFormules *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeComparaisonFormules::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeComparaisonFormules * _p = dynamic_cast <const cPtr_typeComparaisonFormules *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mComparaison == _p->mComparaison).boolValue ()
         && (mOperand1 == _p->mOperand1).boolValue ()
         && (mOperand2 == _p->mOperand2).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeComparaisonFormules::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeComparaisonFormules:"
           << mComparaison.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mOperand1.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mOperand2.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_typeComparaisonFormules'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeComparaisonFormules::
GGS_typeComparaisonFormules (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeComparaisonFormules::
GGS_typeComparaisonFormules (const GGS_typeComparaisonFormules & inOperand)
:GGS_typeFormule () {
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeComparaisonFormules::
~GGS_typeComparaisonFormules (void) {
  macroDetachPointer (mPointer, cPtr_typeComparaisonFormules) ;
}

//---------------------------------------------------------------------------*

void GGS_typeComparaisonFormules::
operator = (const GGS_typeComparaisonFormules & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeComparaisonFormules GGS_typeComparaisonFormules::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_luint & argument_0,
                 const GGS_typeFormule & argument_1,
                 const GGS_typeFormule & argument_2 COMMA_LOCATION_ARGS) {
  GGS_typeComparaisonFormules result ;
  macroMyNew (result.mPointer, cPtr_typeComparaisonFormules (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_typeComparaisonFormules::
reader_mComparaison (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeComparaisonFormules *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeComparaisonFormules *) mPointer)->mComparaison ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeFormule  GGS_typeComparaisonFormules::
reader_mOperand1 (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeFormule   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeComparaisonFormules *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeComparaisonFormules *) mPointer)->mOperand1 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeFormule  GGS_typeComparaisonFormules::
reader_mOperand2 (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeFormule   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeComparaisonFormules *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeComparaisonFormules *) mPointer)->mOperand2 ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeComparaisonFormules::
operator == (const GGS_typeComparaisonFormules & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeComparaisonFormules::
operator != (const GGS_typeComparaisonFormules & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeComparaisonFormules::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeComparaisonFormules" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  abstract class 'cPtr_typeFormuleExist'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeFormuleExist::
cPtr_typeFormuleExist (const GGS_typeFormalArgumentsList & argument_0,
                                const GGS_typeFormule & argument_1,
                                const GGS_extern_bdd& argument_2 COMMA_LOCATION_ARGS)
:cPtr_typeFormule (THERE),
mListeArgsBooleens (argument_0),
mOperand (argument_1),
mContraints (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeFormuleExist * GGS_typeFormuleExist::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFormuleExist *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeFormuleExist *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeFormuleExist::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeFormuleExist * _p = dynamic_cast <const cPtr_typeFormuleExist *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mListeArgsBooleens == _p->mListeArgsBooleens).boolValue ()
         && (mOperand == _p->mOperand).boolValue ()
         && (mContraints == _p->mContraints).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeFormuleExist::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeFormuleExist:"
           << mListeArgsBooleens.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mOperand.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mContraints.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeFormuleExist'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeFormuleExist::
GGS_typeFormuleExist (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeFormuleExist::
GGS_typeFormuleExist (const GGS_typeFormuleExist & inOperand)
:GGS_typeFormule () {
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeFormuleExist::
~GGS_typeFormuleExist (void) {
  macroDetachPointer (mPointer, cPtr_typeFormuleExist) ;
}

//---------------------------------------------------------------------------*

void GGS_typeFormuleExist::
operator = (const GGS_typeFormuleExist & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeFormuleExist GGS_typeFormuleExist::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_typeFormalArgumentsList & argument_0,
                 const GGS_typeFormule & argument_1,
                 const GGS_extern_bdd& argument_2 COMMA_LOCATION_ARGS) {
  GGS_typeFormuleExist result ;
  macroMyNew (result.mPointer, cPtr_typeFormuleExist (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeFormalArgumentsList  GGS_typeFormuleExist::
reader_mListeArgsBooleens (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeFormalArgumentsList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFormuleExist *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeFormuleExist *) mPointer)->mListeArgsBooleens ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeFormule  GGS_typeFormuleExist::
reader_mOperand (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeFormule   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFormuleExist *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeFormuleExist *) mPointer)->mOperand ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_extern_bdd GGS_typeFormuleExist::
reader_mContraints (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_extern_bdd  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFormuleExist *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeFormuleExist *) mPointer)->mContraints ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeFormuleExist::
operator == (const GGS_typeFormuleExist & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeFormuleExist::
operator != (const GGS_typeFormuleExist & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeFormuleExist::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeFormuleExist" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            abstract class 'cPtr_typeFormuleComparaisonValeur'             *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeFormuleComparaisonValeur::
cPtr_typeFormuleComparaisonValeur (const GGS_luint & argument_0,
                                const GGS_luint & argument_1,
                                const GGS_luint & argument_2,
                                const GGS_luint & argument_3,
                                const GGS_luint & argument_4,
                                const GGS_luint & argument_5 COMMA_LOCATION_ARGS)
:cPtr_typeFormule (THERE),
mIndiceBDD (argument_0),
mDimension (argument_1),
mLowBound (argument_2),
mHighBound (argument_3),
mComparaison (argument_4),
mValeur (argument_5) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeFormuleComparaisonValeur * GGS_typeFormuleComparaisonValeur::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFormuleComparaisonValeur *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeFormuleComparaisonValeur *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeFormuleComparaisonValeur::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeFormuleComparaisonValeur * _p = dynamic_cast <const cPtr_typeFormuleComparaisonValeur *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mIndiceBDD == _p->mIndiceBDD).boolValue ()
         && (mDimension == _p->mDimension).boolValue ()
         && (mLowBound == _p->mLowBound).boolValue ()
         && (mHighBound == _p->mHighBound).boolValue ()
         && (mComparaison == _p->mComparaison).boolValue ()
         && (mValeur == _p->mValeur).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeFormuleComparaisonValeur::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeFormuleComparaisonValeur:"
           << mIndiceBDD.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mDimension.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mLowBound.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mHighBound.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mComparaison.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mValeur.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_typeFormuleComparaisonValeur'               *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeFormuleComparaisonValeur::
GGS_typeFormuleComparaisonValeur (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeFormuleComparaisonValeur::
GGS_typeFormuleComparaisonValeur (const GGS_typeFormuleComparaisonValeur & inOperand)
:GGS_typeFormule () {
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeFormuleComparaisonValeur::
~GGS_typeFormuleComparaisonValeur (void) {
  macroDetachPointer (mPointer, cPtr_typeFormuleComparaisonValeur) ;
}

//---------------------------------------------------------------------------*

void GGS_typeFormuleComparaisonValeur::
operator = (const GGS_typeFormuleComparaisonValeur & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeFormuleComparaisonValeur GGS_typeFormuleComparaisonValeur::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_luint & argument_0,
                 const GGS_luint & argument_1,
                 const GGS_luint & argument_2,
                 const GGS_luint & argument_3,
                 const GGS_luint & argument_4,
                 const GGS_luint & argument_5 COMMA_LOCATION_ARGS) {
  GGS_typeFormuleComparaisonValeur result ;
  macroMyNew (result.mPointer, cPtr_typeFormuleComparaisonValeur (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_typeFormuleComparaisonValeur::
reader_mIndiceBDD (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFormuleComparaisonValeur *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeFormuleComparaisonValeur *) mPointer)->mIndiceBDD ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_typeFormuleComparaisonValeur::
reader_mDimension (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFormuleComparaisonValeur *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeFormuleComparaisonValeur *) mPointer)->mDimension ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_typeFormuleComparaisonValeur::
reader_mLowBound (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFormuleComparaisonValeur *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeFormuleComparaisonValeur *) mPointer)->mLowBound ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_typeFormuleComparaisonValeur::
reader_mHighBound (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFormuleComparaisonValeur *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeFormuleComparaisonValeur *) mPointer)->mHighBound ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_typeFormuleComparaisonValeur::
reader_mComparaison (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFormuleComparaisonValeur *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeFormuleComparaisonValeur *) mPointer)->mComparaison ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_typeFormuleComparaisonValeur::
reader_mValeur (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFormuleComparaisonValeur *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeFormuleComparaisonValeur *) mPointer)->mValeur ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeFormuleComparaisonValeur::
operator == (const GGS_typeFormuleComparaisonValeur & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeFormuleComparaisonValeur::
operator != (const GGS_typeFormuleComparaisonValeur & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeFormuleComparaisonValeur::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeFormuleComparaisonValeur" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           abstract class 'cPtr_typeFormuleComparaisonVariable'            *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeFormuleComparaisonVariable::
cPtr_typeFormuleComparaisonVariable (const GGS_luint & argument_0,
                                const GGS_luint & argument_1,
                                const GGS_luint & argument_2,
                                const GGS_luint & argument_3,
                                const GGS_luint & argument_4,
                                const GGS_luint & argument_5,
                                const GGS_luint & argument_6,
                                const GGS_luint & argument_7 COMMA_LOCATION_ARGS)
:cPtr_typeFormule (THERE),
mIndiceBDDgauche (argument_0),
mDimension (argument_1),
mLeftLowBound (argument_2),
mLeftHighBound (argument_3),
mComparaison (argument_4),
mIndiceBDDdroite (argument_5),
mRightLowBound (argument_6),
mRightHighBound (argument_7) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeFormuleComparaisonVariable * GGS_typeFormuleComparaisonVariable::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFormuleComparaisonVariable *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeFormuleComparaisonVariable *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeFormuleComparaisonVariable::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeFormuleComparaisonVariable * _p = dynamic_cast <const cPtr_typeFormuleComparaisonVariable *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mIndiceBDDgauche == _p->mIndiceBDDgauche).boolValue ()
         && (mDimension == _p->mDimension).boolValue ()
         && (mLeftLowBound == _p->mLeftLowBound).boolValue ()
         && (mLeftHighBound == _p->mLeftHighBound).boolValue ()
         && (mComparaison == _p->mComparaison).boolValue ()
         && (mIndiceBDDdroite == _p->mIndiceBDDdroite).boolValue ()
         && (mRightLowBound == _p->mRightLowBound).boolValue ()
         && (mRightHighBound == _p->mRightHighBound).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeFormuleComparaisonVariable::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeFormuleComparaisonVariable:"
           << mIndiceBDDgauche.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mDimension.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mLeftLowBound.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mLeftHighBound.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mComparaison.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mIndiceBDDdroite.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mRightLowBound.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mRightHighBound.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            GALGAS class 'GGS_typeFormuleComparaisonVariable'              *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeFormuleComparaisonVariable::
GGS_typeFormuleComparaisonVariable (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeFormuleComparaisonVariable::
GGS_typeFormuleComparaisonVariable (const GGS_typeFormuleComparaisonVariable & inOperand)
:GGS_typeFormule () {
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeFormuleComparaisonVariable::
~GGS_typeFormuleComparaisonVariable (void) {
  macroDetachPointer (mPointer, cPtr_typeFormuleComparaisonVariable) ;
}

//---------------------------------------------------------------------------*

void GGS_typeFormuleComparaisonVariable::
operator = (const GGS_typeFormuleComparaisonVariable & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeFormuleComparaisonVariable GGS_typeFormuleComparaisonVariable::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_luint & argument_0,
                 const GGS_luint & argument_1,
                 const GGS_luint & argument_2,
                 const GGS_luint & argument_3,
                 const GGS_luint & argument_4,
                 const GGS_luint & argument_5,
                 const GGS_luint & argument_6,
                 const GGS_luint & argument_7 COMMA_LOCATION_ARGS) {
  GGS_typeFormuleComparaisonVariable result ;
  macroMyNew (result.mPointer, cPtr_typeFormuleComparaisonVariable (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6,
                                argument_7 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_typeFormuleComparaisonVariable::
reader_mIndiceBDDgauche (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFormuleComparaisonVariable *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeFormuleComparaisonVariable *) mPointer)->mIndiceBDDgauche ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_typeFormuleComparaisonVariable::
reader_mDimension (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFormuleComparaisonVariable *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeFormuleComparaisonVariable *) mPointer)->mDimension ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_typeFormuleComparaisonVariable::
reader_mLeftLowBound (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFormuleComparaisonVariable *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeFormuleComparaisonVariable *) mPointer)->mLeftLowBound ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_typeFormuleComparaisonVariable::
reader_mLeftHighBound (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFormuleComparaisonVariable *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeFormuleComparaisonVariable *) mPointer)->mLeftHighBound ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_typeFormuleComparaisonVariable::
reader_mComparaison (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFormuleComparaisonVariable *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeFormuleComparaisonVariable *) mPointer)->mComparaison ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_typeFormuleComparaisonVariable::
reader_mIndiceBDDdroite (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFormuleComparaisonVariable *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeFormuleComparaisonVariable *) mPointer)->mIndiceBDDdroite ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_typeFormuleComparaisonVariable::
reader_mRightLowBound (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFormuleComparaisonVariable *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeFormuleComparaisonVariable *) mPointer)->mRightLowBound ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_typeFormuleComparaisonVariable::
reader_mRightHighBound (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeFormuleComparaisonVariable *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeFormuleComparaisonVariable *) mPointer)->mRightHighBound ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeFormuleComparaisonVariable::
operator == (const GGS_typeFormuleComparaisonVariable & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeFormuleComparaisonVariable::
operator != (const GGS_typeFormuleComparaisonVariable & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeFormuleComparaisonVariable::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeFormuleComparaisonVariable" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     abstract class 'cPtr_typeCalcul'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeCalcul::
cPtr_typeCalcul (LOCATION_ARGS)
:C_GGS_Object (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeCalcul * GGS_typeCalcul::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
      return mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_typeCalcul::
appendForDescription (C_Lexique & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeCalcul:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_typeCalcul'                        *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeCalcul::
GGS_typeCalcul (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeCalcul::
GGS_typeCalcul (const GGS_typeCalcul & inOperand) {
  mPointer = (cPtr_typeCalcul *) NULL ;
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeCalcul::
~GGS_typeCalcul (void) {
  macroDetachPointer (mPointer, cPtr_typeCalcul) ;
}

//---------------------------------------------------------------------------*

void GGS_typeCalcul::
operator = (const GGS_typeCalcul & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

void GGS_typeCalcul::
_drop_operation (void) {
  macroDetachPointer (mPointer, cPtr_typeCalcul) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeCalcul::
operator == (const GGS_typeCalcul & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeCalcul::
operator != (const GGS_typeCalcul & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeCalcul::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeCalcul" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  abstract class 'cPtr_typeCalculSimple'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeCalculSimple::
cPtr_typeCalculSimple (const GGS_luint & argument_0,
                                const GGS_typeFormule & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_typeTableVariablesBool & argument_3,
                                const GGS_luint & argument_4 COMMA_LOCATION_ARGS)
:cPtr_typeCalcul (THERE),
mNumeroFormule (argument_0),
mFormule (argument_1),
mNomFormule (argument_2),
mTableVariablesBool (argument_3),
mAfficher (argument_4) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeCalculSimple * GGS_typeCalculSimple::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeCalculSimple *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeCalculSimple *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeCalculSimple::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeCalculSimple * _p = dynamic_cast <const cPtr_typeCalculSimple *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mNumeroFormule == _p->mNumeroFormule).boolValue ()
         && (mFormule == _p->mFormule).boolValue ()
         && (mNomFormule == _p->mNomFormule).boolValue ()
         && (mTableVariablesBool == _p->mTableVariablesBool).boolValue ()
         && (mAfficher == _p->mAfficher).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeCalculSimple::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeCalculSimple:"
           << mNumeroFormule.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mFormule.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mNomFormule.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mTableVariablesBool.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mAfficher.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeCalculSimple'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeCalculSimple::
GGS_typeCalculSimple (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeCalculSimple::
GGS_typeCalculSimple (const GGS_typeCalculSimple & inOperand)
:GGS_typeCalcul () {
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeCalculSimple::
~GGS_typeCalculSimple (void) {
  macroDetachPointer (mPointer, cPtr_typeCalculSimple) ;
}

//---------------------------------------------------------------------------*

void GGS_typeCalculSimple::
operator = (const GGS_typeCalculSimple & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeCalculSimple GGS_typeCalculSimple::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_luint & argument_0,
                 const GGS_typeFormule & argument_1,
                 const GGS_lstring & argument_2,
                 const GGS_typeTableVariablesBool & argument_3,
                 const GGS_luint & argument_4 COMMA_LOCATION_ARGS) {
  GGS_typeCalculSimple result ;
  macroMyNew (result.mPointer, cPtr_typeCalculSimple (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_typeCalculSimple::
reader_mNumeroFormule (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeCalculSimple *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeCalculSimple *) mPointer)->mNumeroFormule ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeFormule  GGS_typeCalculSimple::
reader_mFormule (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeFormule   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeCalculSimple *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeCalculSimple *) mPointer)->mFormule ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeCalculSimple::
reader_mNomFormule (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeCalculSimple *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeCalculSimple *) mPointer)->mNomFormule ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeTableVariablesBool  GGS_typeCalculSimple::
reader_mTableVariablesBool (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeTableVariablesBool   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeCalculSimple *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeCalculSimple *) mPointer)->mTableVariablesBool ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_typeCalculSimple::
reader_mAfficher (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeCalculSimple *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeCalculSimple *) mPointer)->mAfficher ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeCalculSimple::
operator == (const GGS_typeCalculSimple & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeCalculSimple::
operator != (const GGS_typeCalculSimple & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeCalculSimple::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeCalculSimple" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    abstract class 'cPtr_typeUse_AND'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeUse_AND::
cPtr_typeUse_AND (LOCATION_ARGS)
:cPtr_typeCalcul (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeUse_AND * GGS_typeUse_AND::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeUse_AND *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeUse_AND *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeUse_AND::
isEqualToObject (const C_GGS_Object * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeUse_AND::
appendForDescription (C_Lexique & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeUse_AND:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_typeUse_AND'                       *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeUse_AND::
GGS_typeUse_AND (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeUse_AND::
GGS_typeUse_AND (const GGS_typeUse_AND & inOperand)
:GGS_typeCalcul () {
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeUse_AND::
~GGS_typeUse_AND (void) {
  macroDetachPointer (mPointer, cPtr_typeUse_AND) ;
}

//---------------------------------------------------------------------------*

void GGS_typeUse_AND::
operator = (const GGS_typeUse_AND & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeUse_AND GGS_typeUse_AND::
constructor_new (C_Lexique & /* inLexique */ COMMA_LOCATION_ARGS) {
  GGS_typeUse_AND result ;
  macroMyNew (result.mPointer, cPtr_typeUse_AND (THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeUse_AND::
operator == (const GGS_typeUse_AND & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeUse_AND::
operator != (const GGS_typeUse_AND & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeUse_AND::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeUse_AND" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    abstract class 'cPtr_typeUse_ITE'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeUse_ITE::
cPtr_typeUse_ITE (LOCATION_ARGS)
:cPtr_typeCalcul (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeUse_ITE * GGS_typeUse_ITE::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeUse_ITE *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeUse_ITE *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeUse_ITE::
isEqualToObject (const C_GGS_Object * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeUse_ITE::
appendForDescription (C_Lexique & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeUse_ITE:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      GALGAS class 'GGS_typeUse_ITE'                       *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeUse_ITE::
GGS_typeUse_ITE (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeUse_ITE::
GGS_typeUse_ITE (const GGS_typeUse_ITE & inOperand)
:GGS_typeCalcul () {
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeUse_ITE::
~GGS_typeUse_ITE (void) {
  macroDetachPointer (mPointer, cPtr_typeUse_ITE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeUse_ITE::
operator = (const GGS_typeUse_ITE & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeUse_ITE GGS_typeUse_ITE::
constructor_new (C_Lexique & /* inLexique */ COMMA_LOCATION_ARGS) {
  GGS_typeUse_ITE result ;
  macroMyNew (result.mPointer, cPtr_typeUse_ITE (THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeUse_ITE::
operator == (const GGS_typeUse_ITE & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeUse_ITE::
operator != (const GGS_typeUse_ITE & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeUse_ITE::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeUse_ITE" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  abstract class 'cPtr_typeUse_AND_ITE'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeUse_AND_ITE::
cPtr_typeUse_AND_ITE (LOCATION_ARGS)
:cPtr_typeCalcul (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeUse_AND_ITE * GGS_typeUse_AND_ITE::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeUse_AND_ITE *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeUse_AND_ITE *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeUse_AND_ITE::
isEqualToObject (const C_GGS_Object * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeUse_AND_ITE::
appendForDescription (C_Lexique & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeUse_AND_ITE:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_typeUse_AND_ITE'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeUse_AND_ITE::
GGS_typeUse_AND_ITE (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeUse_AND_ITE::
GGS_typeUse_AND_ITE (const GGS_typeUse_AND_ITE & inOperand)
:GGS_typeCalcul () {
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeUse_AND_ITE::
~GGS_typeUse_AND_ITE (void) {
  macroDetachPointer (mPointer, cPtr_typeUse_AND_ITE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeUse_AND_ITE::
operator = (const GGS_typeUse_AND_ITE & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeUse_AND_ITE GGS_typeUse_AND_ITE::
constructor_new (C_Lexique & /* inLexique */ COMMA_LOCATION_ARGS) {
  GGS_typeUse_AND_ITE result ;
  macroMyNew (result.mPointer, cPtr_typeUse_AND_ITE (THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeUse_AND_ITE::
operator == (const GGS_typeUse_AND_ITE & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeUse_AND_ITE::
operator != (const GGS_typeUse_AND_ITE & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeUse_AND_ITE::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeUse_AND_ITE" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              abstract class 'cPtr_typeDimensionnerANDCache'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeDimensionnerANDCache::
cPtr_typeDimensionnerANDCache (const GGS_luint & argument_0 COMMA_LOCATION_ARGS)
:cPtr_typeCalcul (THERE),
mDimensionCache (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeDimensionnerANDCache * GGS_typeDimensionnerANDCache::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeDimensionnerANDCache *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeDimensionnerANDCache *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeDimensionnerANDCache::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeDimensionnerANDCache * _p = dynamic_cast <const cPtr_typeDimensionnerANDCache *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mDimensionCache == _p->mDimensionCache).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeDimensionnerANDCache::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeDimensionnerANDCache:"
           << mDimensionCache.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeDimensionnerANDCache'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeDimensionnerANDCache::
GGS_typeDimensionnerANDCache (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeDimensionnerANDCache::
GGS_typeDimensionnerANDCache (const GGS_typeDimensionnerANDCache & inOperand)
:GGS_typeCalcul () {
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeDimensionnerANDCache::
~GGS_typeDimensionnerANDCache (void) {
  macroDetachPointer (mPointer, cPtr_typeDimensionnerANDCache) ;
}

//---------------------------------------------------------------------------*

void GGS_typeDimensionnerANDCache::
operator = (const GGS_typeDimensionnerANDCache & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeDimensionnerANDCache GGS_typeDimensionnerANDCache::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_luint & argument_0 COMMA_LOCATION_ARGS) {
  GGS_typeDimensionnerANDCache result ;
  macroMyNew (result.mPointer, cPtr_typeDimensionnerANDCache (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_typeDimensionnerANDCache::
reader_mDimensionCache (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeDimensionnerANDCache *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeDimensionnerANDCache *) mPointer)->mDimensionCache ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeDimensionnerANDCache::
operator == (const GGS_typeDimensionnerANDCache & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeDimensionnerANDCache::
operator != (const GGS_typeDimensionnerANDCache & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeDimensionnerANDCache::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeDimensionnerANDCache" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              abstract class 'cPtr_typeDimensionnerITECache'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeDimensionnerITECache::
cPtr_typeDimensionnerITECache (const GGS_luint & argument_0 COMMA_LOCATION_ARGS)
:cPtr_typeCalcul (THERE),
mDimensionCache (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeDimensionnerITECache * GGS_typeDimensionnerITECache::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeDimensionnerITECache *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeDimensionnerITECache *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeDimensionnerITECache::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeDimensionnerITECache * _p = dynamic_cast <const cPtr_typeDimensionnerITECache *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mDimensionCache == _p->mDimensionCache).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeDimensionnerITECache::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeDimensionnerITECache:"
           << mDimensionCache.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeDimensionnerITECache'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeDimensionnerITECache::
GGS_typeDimensionnerITECache (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeDimensionnerITECache::
GGS_typeDimensionnerITECache (const GGS_typeDimensionnerITECache & inOperand)
:GGS_typeCalcul () {
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeDimensionnerITECache::
~GGS_typeDimensionnerITECache (void) {
  macroDetachPointer (mPointer, cPtr_typeDimensionnerITECache) ;
}

//---------------------------------------------------------------------------*

void GGS_typeDimensionnerITECache::
operator = (const GGS_typeDimensionnerITECache & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeDimensionnerITECache GGS_typeDimensionnerITECache::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_luint & argument_0 COMMA_LOCATION_ARGS) {
  GGS_typeDimensionnerITECache result ;
  macroMyNew (result.mPointer, cPtr_typeDimensionnerITECache (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_typeDimensionnerITECache::
reader_mDimensionCache (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeDimensionnerITECache *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeDimensionnerITECache *) mPointer)->mDimensionCache ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeDimensionnerITECache::
operator == (const GGS_typeDimensionnerITECache & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeDimensionnerITECache::
operator != (const GGS_typeDimensionnerITECache & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeDimensionnerITECache::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeDimensionnerITECache" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               abstract class 'cPtr_typeDimensionnerTable'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeDimensionnerTable::
cPtr_typeDimensionnerTable (const GGS_luint & argument_0 COMMA_LOCATION_ARGS)
:cPtr_typeCalcul (THERE),
mDimensionTable (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeDimensionnerTable * GGS_typeDimensionnerTable::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeDimensionnerTable *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeDimensionnerTable *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeDimensionnerTable::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeDimensionnerTable * _p = dynamic_cast <const cPtr_typeDimensionnerTable *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mDimensionTable == _p->mDimensionTable).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeDimensionnerTable::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeDimensionnerTable:"
           << mDimensionTable.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeDimensionnerTable'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeDimensionnerTable::
GGS_typeDimensionnerTable (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeDimensionnerTable::
GGS_typeDimensionnerTable (const GGS_typeDimensionnerTable & inOperand)
:GGS_typeCalcul () {
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeDimensionnerTable::
~GGS_typeDimensionnerTable (void) {
  macroDetachPointer (mPointer, cPtr_typeDimensionnerTable) ;
}

//---------------------------------------------------------------------------*

void GGS_typeDimensionnerTable::
operator = (const GGS_typeDimensionnerTable & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeDimensionnerTable GGS_typeDimensionnerTable::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_luint & argument_0 COMMA_LOCATION_ARGS) {
  GGS_typeDimensionnerTable result ;
  macroMyNew (result.mPointer, cPtr_typeDimensionnerTable (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_typeDimensionnerTable::
reader_mDimensionTable (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeDimensionnerTable *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeDimensionnerTable *) mPointer)->mDimensionTable ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeDimensionnerTable::
operator == (const GGS_typeDimensionnerTable & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeDimensionnerTable::
operator != (const GGS_typeDimensionnerTable & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeDimensionnerTable::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeDimensionnerTable" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 abstract class 'cPtr_typeAfficherBilan'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeAfficherBilan::
cPtr_typeAfficherBilan (LOCATION_ARGS)
:cPtr_typeCalcul (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeAfficherBilan * GGS_typeAfficherBilan::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeAfficherBilan *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeAfficherBilan *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeAfficherBilan::
isEqualToObject (const C_GGS_Object * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeAfficherBilan::
appendForDescription (C_Lexique & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeAfficherBilan:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_typeAfficherBilan'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeAfficherBilan::
GGS_typeAfficherBilan (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeAfficherBilan::
GGS_typeAfficherBilan (const GGS_typeAfficherBilan & inOperand)
:GGS_typeCalcul () {
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeAfficherBilan::
~GGS_typeAfficherBilan (void) {
  macroDetachPointer (mPointer, cPtr_typeAfficherBilan) ;
}

//---------------------------------------------------------------------------*

void GGS_typeAfficherBilan::
operator = (const GGS_typeAfficherBilan & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeAfficherBilan GGS_typeAfficherBilan::
constructor_new (C_Lexique & /* inLexique */ COMMA_LOCATION_ARGS) {
  GGS_typeAfficherBilan result ;
  macroMyNew (result.mPointer, cPtr_typeAfficherBilan (THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeAfficherBilan::
operator == (const GGS_typeAfficherBilan & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeAfficherBilan::
operator != (const GGS_typeAfficherBilan & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeAfficherBilan::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeAfficherBilan" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 abstract class 'cPtr_typeCalculIteratif'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeCalculIteratif::
cPtr_typeCalculIteratif (const GGS_luint & argument_0,
                                const GGS_typeFormule & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_typeTableVariablesBool & argument_3,
                                const GGS_lbool & argument_4,
                                const GGS_luint & argument_5 COMMA_LOCATION_ARGS)
:cPtr_typeCalcul (THERE),
mNumeroFormule (argument_0),
mFormule (argument_1),
mNomFormule (argument_2),
mTableVariablesBool (argument_3),
mSigne (argument_4),
mAfficher (argument_5) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeCalculIteratif * GGS_typeCalculIteratif::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeCalculIteratif *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeCalculIteratif *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeCalculIteratif::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeCalculIteratif * _p = dynamic_cast <const cPtr_typeCalculIteratif *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mNumeroFormule == _p->mNumeroFormule).boolValue ()
         && (mFormule == _p->mFormule).boolValue ()
         && (mNomFormule == _p->mNomFormule).boolValue ()
         && (mTableVariablesBool == _p->mTableVariablesBool).boolValue ()
         && (mSigne == _p->mSigne).boolValue ()
         && (mAfficher == _p->mAfficher).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeCalculIteratif::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeCalculIteratif:"
           << mNumeroFormule.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mFormule.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mNomFormule.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mTableVariablesBool.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mSigne.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mAfficher.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeCalculIteratif'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeCalculIteratif::
GGS_typeCalculIteratif (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeCalculIteratif::
GGS_typeCalculIteratif (const GGS_typeCalculIteratif & inOperand)
:GGS_typeCalcul () {
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeCalculIteratif::
~GGS_typeCalculIteratif (void) {
  macroDetachPointer (mPointer, cPtr_typeCalculIteratif) ;
}

//---------------------------------------------------------------------------*

void GGS_typeCalculIteratif::
operator = (const GGS_typeCalculIteratif & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeCalculIteratif GGS_typeCalculIteratif::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_luint & argument_0,
                 const GGS_typeFormule & argument_1,
                 const GGS_lstring & argument_2,
                 const GGS_typeTableVariablesBool & argument_3,
                 const GGS_lbool & argument_4,
                 const GGS_luint & argument_5 COMMA_LOCATION_ARGS) {
  GGS_typeCalculIteratif result ;
  macroMyNew (result.mPointer, cPtr_typeCalculIteratif (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_typeCalculIteratif::
reader_mNumeroFormule (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeCalculIteratif *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeCalculIteratif *) mPointer)->mNumeroFormule ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeFormule  GGS_typeCalculIteratif::
reader_mFormule (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeFormule   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeCalculIteratif *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeCalculIteratif *) mPointer)->mFormule ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeCalculIteratif::
reader_mNomFormule (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeCalculIteratif *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeCalculIteratif *) mPointer)->mNomFormule ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeTableVariablesBool  GGS_typeCalculIteratif::
reader_mTableVariablesBool (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeTableVariablesBool   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeCalculIteratif *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeCalculIteratif *) mPointer)->mTableVariablesBool ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lbool  GGS_typeCalculIteratif::
reader_mSigne (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lbool   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeCalculIteratif *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeCalculIteratif *) mPointer)->mSigne ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_typeCalculIteratif::
reader_mAfficher (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeCalculIteratif *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeCalculIteratif *) mPointer)->mAfficher ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeCalculIteratif::
operator == (const GGS_typeCalculIteratif & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeCalculIteratif::
operator != (const GGS_typeCalculIteratif & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeCalculIteratif::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeCalculIteratif" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   Element of list '@typeListeCalculs'                     *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeListeCalculs::
elementOf_GGS_typeListeCalculs (const GGS_typeCalcul & argument_0):
mCalcul (argument_0) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_typeListeCalculs::
isEqualToElement (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_typeListeCalculs * _p = dynamic_cast <const elementOf_GGS_typeListeCalculs *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mCalcul == _p->mCalcul).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeListeCalculs::
appendForListDescription (C_Lexique & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mCalcul.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         List '@typeListeCalculs'                          *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeListeCalculs::GGS_typeListeCalculs (void): AC_galgas_list () { // Default Constructor
}

//---------------------------------------------------------------------------*

GGS_typeListeCalculs::
GGS_typeListeCalculs (const GGS_typeListeCalculs & inSource): AC_galgas_list (inSource) {
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeListeCalculs::
operator == (const GGS_typeListeCalculs & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeListeCalculs::
operator != (const GGS_typeListeCalculs & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeCalculs::
_internalAppendValues (const GGS_typeCalcul & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeCalculs::
_internalPrependValues (const GGS_typeCalcul & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeCalculs::
_addAssign_operation (const GGS_typeCalcul & argument_0) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

GGS_typeListeCalculs GGS_typeListeCalculs::
operator + (const GGS_typeListeCalculs & inOperand) const {
  GGS_typeListeCalculs result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        elementOf_GGS_typeListeCalculs * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_typeCalcul  p_0 = p->mCalcul ;
          result._internalAppendValues (p_0) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeCalculs::
modifier_prependValue (C_Lexique & /* inLexique */,
                     const GGS_typeCalcul & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeCalculs::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mCalcul) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeListeCalculs  GGS_typeListeCalculs::
constructor_emptyList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeListeCalculs result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeListeCalculs  GGS_typeListeCalculs::
constructor_listWithValue (C_Lexique & /* _inLexique */,
                           const GGS_typeCalcul & argument_0
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeListeCalculs result ;
  result._alloc () ;
  result._addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeListeCalculs::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@typeListeCalculs", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeCalculs::
method_first (C_Lexique & _inLexique,
              GGS_typeCalcul & _out_0
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mCalcul ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeCalculs::
method_last (C_Lexique & _inLexique,
             GGS_typeCalcul & _out_0
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mCalcul ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeCalculs::
modifier_popFirst (C_Lexique & _inLexique,
                 GGS_typeCalcul & _out_0
                 COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mCalcul ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeCalculs::
modifier_popLast (C_Lexique & _inLexique,
                GGS_typeCalcul & _out_0
                COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mCalcul ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*
//                                                                           *
//         Implementation of routine "verifierNombreArgumentsBool"           *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_verifierNombreArgumentsBool (C_Lexique & _inLexique,
                                const GGS_typeFormalArgumentsList  & var_cas_t1,
                                const GGS_typeActualArgumentsList  & var_cas_t2,
                                const GGS_location  & var_cas_positionFinListe COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_verifierNombreArgumentsBool at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  if (((var_cas_t1.reader_length (_inLexique SOURCE_FILE_AT_LINE (257))) < (var_cas_t2.reader_length (_inLexique SOURCE_FILE_AT_LINE (257)))).isBuiltAndTrue ()) {
    var_cas_positionFinListe.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "too much actual arguments") SOURCE_FILE_AT_LINE (259)) ;
  }else if (((var_cas_t1.reader_length (_inLexique SOURCE_FILE_AT_LINE (259))) > (var_cas_t2.reader_length (_inLexique SOURCE_FILE_AT_LINE (259)))).isBuiltAndTrue ()) {
    var_cas_positionFinListe.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "one or more actual arguments missing") SOURCE_FILE_AT_LINE (261)) ;
  }
  GGS_typeFormalArgumentsList::element_type * operand_7774 = var_cas_t1.firstObject () ;
  GGS_typeActualArgumentsList::element_type * operand_7855 = var_cas_t2.firstObject () ;
  while ((operand_7774 != NULL)
      && (operand_7855 != NULL)) {
    macroValidPointer (operand_7774) ;
    macroValidPointer (operand_7855) ;
    if (((operand_7774->mVariableBitSize.reader_uint (_inLexique SOURCE_FILE_AT_LINE (264))) == (operand_7855->mVariableBitSize.reader_uint (_inLexique SOURCE_FILE_AT_LINE (264)))).isBuiltAndTrue ()) {
      if (((operand_7774->mLowBound.reader_uint (_inLexique SOURCE_FILE_AT_LINE (265))) == (operand_7855->mLowBound.reader_uint (_inLexique SOURCE_FILE_AT_LINE (265)))).isBuiltAndTrue ()) {
        if (((operand_7774->mHighBound.reader_uint (_inLexique SOURCE_FILE_AT_LINE (266))) == (operand_7855->mHighBound.reader_uint (_inLexique SOURCE_FILE_AT_LINE (266)))).isBuiltAndTrue ()) {
        }else{
          operand_7855->mErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "the actual high bound is different the formal one") SOURCE_FILE_AT_LINE (269)) ;
        }
      }else{
        operand_7855->mErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "the actual low bound is different the formal one") SOURCE_FILE_AT_LINE (272)) ;
      }
    }else{
      operand_7855->mErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "the actual dimension is different from the formal one") SOURCE_FILE_AT_LINE (275)) ;
    }
    operand_7774 = operand_7774->nextObject () ;
    operand_7855 = operand_7855->nextObject () ;
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_verifierNombreArgumentsBool\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//             Implementation of routine "buildFormalArgsList"               *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_buildFormalArgsList (C_Lexique & _inLexique,
                                const GGS_typeVariableDescriptor  & var_cas_inVariableDescriptor,
                                GGS_typeFormalArgumentsList  & var_cas_ioFormalArgsList,
                                const GGS_location  & var_cas_inErrorLocation COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_buildFormalArgsList at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  if (var_cas_inVariableDescriptor._isBuilt ()) {
    cPtr_typeDirectVariable * operand_8728 = dynamic_cast <cPtr_typeDirectVariable *> (var_cas_inVariableDescriptor.getPtr ()) ;
    if (operand_8728 != NULL) {
      macroValidPointer (operand_8728) ; 
      var_cas_ioFormalArgsList._addAssign_operation (operand_8728->mIndex, operand_8728->mBitSize, operand_8728->mLowBound, operand_8728->mHighBound) ;
    }else{
      cPtr_typeRecordVariable * operand_8906 = dynamic_cast <cPtr_typeRecordVariable *> (var_cas_inVariableDescriptor.getPtr ()) ;
      if (operand_8906 != NULL) {
        macroValidPointer (operand_8906) ; 
        GGS_typeTableVariablesBool::element_type * operand_9001 = operand_8906->mMap.firstObject () ;
        while ((operand_9001 != NULL)) {
          macroValidPointer (operand_9001) ;
          ::routine_buildFormalArgsList (_inLexique,  operand_9001->mInfo.mVariableDescriptor,  var_cas_ioFormalArgsList,  var_cas_inErrorLocation SOURCE_FILE_AT_LINE (291)) ;
          operand_9001 = operand_9001->nextObject () ;
        }
      }else{ // Else part
        var_cas_inErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, ((GGS_string (true, "a variable was expected here ; I found ")) + (var_cas_inVariableDescriptor.reader_variableDescriptorErrorMessage (_inLexique SOURCE_FILE_AT_LINE (294)))) SOURCE_FILE_AT_LINE (295)) ;
      }
    }
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_buildFormalArgsList\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//             Implementation of routine "buildActualArgsList"               *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_buildActualArgsList (C_Lexique & _inLexique,
                                const GGS_typeTableVariablesBool  & var_cas_inDomainMap,
                                GGS_typeActualArgumentsList  & var_cas_ioActualArgsList,
                                const GGS_location  & var_cas_inErrorLocation COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_buildActualArgsList at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_typeTableVariablesBool::element_type * operand_9572 = var_cas_inDomainMap.firstObject () ;
  while ((operand_9572 != NULL)) {
    macroValidPointer (operand_9572) ;
    if (operand_9572->mInfo.mVariableDescriptor._isBuilt ()) {
      cPtr_typeDirectVariable * operand_9677 = dynamic_cast <cPtr_typeDirectVariable *> (operand_9572->mInfo.mVariableDescriptor.getPtr ()) ;
      if (operand_9677 != NULL) {
        macroValidPointer (operand_9677) ; 
        var_cas_ioActualArgsList._addAssign_operation (operand_9677->mIndex, operand_9677->mBitSize, operand_9677->mLowBound, operand_9677->mHighBound, var_cas_inErrorLocation) ;
      }else{
        cPtr_typeRecordVariable * operand_9876 = dynamic_cast <cPtr_typeRecordVariable *> (operand_9572->mInfo.mVariableDescriptor.getPtr ()) ;
        if (operand_9876 != NULL) {
          macroValidPointer (operand_9876) ; 
          ::routine_buildActualArgsList (_inLexique,  operand_9876->mMap,  var_cas_ioActualArgsList,  var_cas_inErrorLocation SOURCE_FILE_AT_LINE (310)) ;
        }else{ // Else part
          var_cas_inErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, ((GGS_string (true, "a variable was expected here ; I found ")) + (operand_9572->mInfo.mVariableDescriptor.reader_variableDescriptorErrorMessage (_inLexique SOURCE_FILE_AT_LINE (313)))) SOURCE_FILE_AT_LINE (314)) ;
        }
      }
    }
    operand_9572 = operand_9572->nextObject () ;
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_buildActualArgsList\n") ;
  #endif
}

//---------------------------------------------------------------------------*

