syntax syntaxeBDD :#-------------------------------------------------------------------*import lexique lexiqueBDD in "lexiqueBDD.ggs" ;import semantics semantiqueBDD in "semantiqueBDD.ggs" ;import grammar grammaireBDD in "grammaireBDD.ggs" ;#-------------------------------------------------------------------*action getHighBound ??@luint inDimension !@luint outHighBound ;action verifyBoundsAndComputeDimension ??@luint lowBound ??@luint highBound !@luint dimension ;action verifierDimensionValeurCorrecte ?@luint dim ?@luint valeur ;action verifierMemesDimensions ?@luint dim ?@luint dimensionDroite ;action verifierDimensionUn ?@luint inBitSize ?@location inErrorLocation ;action verifierDimensionExpliciteCorrecte ?@luint numeroVar                                          ?@luint dim                                          ?!@luint indiceDebutBDD                                          ?@luint dimension ;#-------------------------------------------------------------------*rule <axiomeBDD>  ?!@typeTableFormules tableFormules  ?!@typeListeCalculs listeCalculs  ?!@typeDomainMap ioDomainMap;rule <domainDefinition>  ?!@typeDomainMap ioDomainMap  !@typeDomain outDomain;rule <formule>  ?@typeTableVariablesBool tableVariables  ?!@typeDomainMap ioDomainMap  ?!@typeTableFormules tableFormules  !@typeFormule formule;rule <type_formule>  ?@typeTableVariablesBool tableVariables  ?!@typeDomainMap ioDomainMap  ?!@typeTableFormules tableFormules  ?@lstring nomFormule  ?@typeFormalArgumentsList listeArgFormelsBool  ?@luint afficherBDD  !@typeCalcul calcul;rule <egalite_formule>  ?@typeTableVariablesBool tableVariables  ?!@typeDomainMap ioDomainMap  ?!@typeTableFormules tableFormules  !@typeFormule formule;rule <facteur_formule>  ?@typeTableVariablesBool tableVariables  ?!@typeDomainMap ioDomainMap  ?!@typeTableFormules tableFormules  !@typeFormule formule;rule <terme_formule>  ?@typeTableVariablesBool tableVariables  ?!@typeDomainMap ioDomainMap  ?!@typeTableFormules tableFormules  !@typeFormule formule;rule <dimension>  ?!@typeDomainMap ioDomainMap  !@typeDomain outDomain;rule <comparaisonVariable>  ?@typeTableVariablesBool tableVariables  ?@luint numero  ?@luint dim  ?@luint lowBound  ?@luint highBound  ?@luint comparaison  !@typeFormule formule;rule <analyserFormule>  ?!@typeTableFormules tableFormules  ?!@typeDomainMap ioDomainMap  ?!@typeListeCalculs listeCalculs  ?@luint afficherBDD;rule <argsFormelsFormule>  ?!@typeTableVariablesBool tableVariables  ?!@typeDomainMap ioDomainMap  !@typeFormalArgumentsList listeArgFormelsBool;rule <declarations>  ?!@typeTableVariablesBool tableVariables  ?!@typeDomainMap ioDomainMap  !@typeFormalArgumentsList listeArgFormelsBool;rule <parse_scalar_argument>  ?!@typeTableVariablesBool ioVarMap  !@luint outVarIndex  !@luint outBitSize  !@luint outLowBound  !@luint outHighBound  !@location outErrorLocation ;rule <parse_argument>  ?!@typeTableVariablesBool ioVarMap  !@typeVariableDescriptor outVarDescriptor  !@location outErrorLocation;#-------------------------------------------------------------------*#                             axiome                                *#-------------------------------------------------------------------*rule <axiomeBDD>  ?!@typeTableFormules tableFormules  ?!@typeListeCalculs listeCalculs  ?!@typeDomainMap ioDomainMap:  repeat  while     $domain$ ;    @lstring domainName ;    $id$ ? domainName ;    $:$ ;    @typeDomain d ;    <domainDefinition> !?ioDomainMap ?d ;    insert ioDomainMap.insertKey domainName (!d) ;    $;$ ;  while     $dimension$ ;    @lstring nomDimension ;    $id$ ? nomDimension ;    $:$ ;    @luint dimension ;    $nombre$ ? dimension ;    warning dimension : "old style declaration : now use domain declaration" ;    @luint lowBound := [@luint new !0 !here] ;    @luint highBound ;    action getHighBound !dimension ?highBound ;    @typeDomain d := [@typeDirectDomain new !lowBound !highBound !dimension] ;    insert ioDomainMap.insertKey nomDimension (!d) ;    $;$ ;  while     $include$ ;    @lstring nomFichierInclusion ;    $string$ ? nomFichierInclusion ;    $;$ ;    grammar grammaireBDD in nomFichierInclusion      !?tableFormules      !?listeCalculs      !?ioDomainMap    ;  while    $use_and$ ;    @typeCalcul calcul := [@typeUse_AND new] ;    listeCalculs += !calcul ;    $;$ ;  while    $use_ite$ ;    @typeCalcul calcul := [@typeUse_ITE new] ;    listeCalculs += !calcul ;    $;$ ;  while    $use_and_ite$ ;    @typeCalcul calcul := [@typeUse_AND_ITE new] ;    listeCalculs += !calcul ;    $;$ ;  while    $and_cache$ ;    @luint dimensionCache ;    $nombre$ ?dimensionCache ;    @typeCalcul calcul ;    calcul := [@typeDimensionnerANDCache new !dimensionCache] ;    listeCalculs += !calcul ;    $;$ ;  while    $ite_cache$ ;    @luint dimensionCache ;    $nombre$ ?dimensionCache ;    @typeCalcul calcul ;    calcul := [@typeDimensionnerITECache new !dimensionCache] ;    listeCalculs += !calcul ;    $;$ ;  while     $map$ ;    @luint dimensionTable ;    $nombre$ ? dimensionTable ;    @typeCalcul calcul ;    calcul := [@typeDimensionnerTable new !dimensionTable] ;    listeCalculs += !calcul ;    $;$ ;  while     $bdd$ ;    @typeCalcul calcul ;    calcul := [@typeAfficherBilan new] ;    listeCalculs += !calcul ;    $;$ ;  while    $display$ ;    @luint afficherBDD ;    afficherBDD := [@luint new !1 !here] ;    $#$ ;    <analyserFormule> !?tableFormules !?ioDomainMap !?listeCalculs !afficherBDD ;    $;$ ;  while    $dump$ ;    @luint afficherBDD ;    afficherBDD := [@luint new !2 !here] ;    $#$ ;    <analyserFormule> !?tableFormules !?ioDomainMap !?listeCalculs !afficherBDD ;    $;$ ;  while    $verify$ ;    @luint afficherBDD ;    afficherBDD := [@luint new !3 !here] ;    $#$ ;    <analyserFormule> !?tableFormules !?ioDomainMap !?listeCalculs !afficherBDD ;    $;$ ;  while    $#$ ;    @luint afficherBDD ;    afficherBDD := [@luint new !0 !here] ;    <analyserFormule> !?tableFormules !?ioDomainMap !?listeCalculs !afficherBDD ;    $;$ ;  end repeat ;  $end$ ;end rule ;#-------------------------------------------------------------------*rule <domainDefinition>  ?!@typeDomainMap ioDomainMap  !@typeDomain outDomain:  select    @luint lowBound ;    @luint highBound ;    select      $nombre$ ? lowBound ;      $..$ ;      $nombre$ ? highBound ;   or      $bool$ ;      lowBound := [@luint new !0 !here] ;      select        highBound := [@luint new !1 !here] ;      or        $[$ ;        @luint dim ;        $nombre$ ? dim ;        $]$ ;        action getHighBound !dim ?highBound ;      end select ;    end select ;    @luint dimension ;    action verifyBoundsAndComputeDimension !lowBound !highBound ?dimension ;    outDomain := [@typeDirectDomain new !lowBound !highBound !dimension] ;  or    $record$ ;    @typeDomainMap recordDomainMap [empty] ;    repeat      @lstring fieldName ;      $id$ ? fieldName ;      $:$ ;      @typeDomain d ;      <domainDefinition> !?ioDomainMap ?d ;      $;$ ;      insert recordDomainMap.insertKey fieldName (!d) ;    while    end repeat ;    $end$ ;    $record$ ;    outDomain := [@typeRecordDomain new !recordDomainMap] ;  or    @lstring domainName ;    $id$ ? domainName ;    search ioDomainMap.searchKey domainName (?outDomain) ;  end select ;end rule ;#-------------------------------------------------------------------*#                       Formule                                     *#-------------------------------------------------------------------*rule <analyserFormule>  ?!@typeTableFormules tableFormules  ?!@typeDomainMap ioDomainMap  ?!@typeListeCalculs listeCalculs  ?@luint afficherBDD:  @lstring nomFormule ;  $id$ ? nomFormule ;  @typeTableVariablesBool tableVariables [empty] ;  @typeFormalArgumentsList listeArgFormelsBool ;  <argsFormelsFormule> !?tableVariables !?ioDomainMap ?listeArgFormelsBool ;  @typeCalcul calcul ;  <type_formule> !tableVariables !?ioDomainMap !?tableFormules                !nomFormule !listeArgFormelsBool !afficherBDD ?calcul ;  listeCalculs += !calcul ;end rule ;#-------------------------------------------------------------------*#                Arguments formels de la formule                    *#-------------------------------------------------------------------*rule <argsFormelsFormule>  ?!@typeTableVariablesBool tableVariables  ?!@typeDomainMap ioDomainMap  !@typeFormalArgumentsList listeArgFormelsBool:  select    # Pas de declarations    listeArgFormelsBool := [@typeFormalArgumentsList empty] ;  or    $[$ ;    <declarations> !?tableVariables !?ioDomainMap ?listeArgFormelsBool ;    $]$ ;  end select ;end rule ;#-------------------------------------------------------------------*routine exploreRecordDomain ??@typeDomainMap inRecordMap                            !@typeTableVariablesBool outMap                            ??@location inErrorLocation ;routine exploreRecordDomain ??@typeDomainMap inRecordMap                            !@typeTableVariablesBool outMap                            ??@location inErrorLocation :  outMap := [@typeTableVariablesBool empty] ;  foreach inRecordMap (??@lstring inKey ??@typeDomain inDomain) :    extract inDomain :    when @typeDirectDomain (??@luint inLowBound ??@luint inHighBound ??@luint inBitSize) ->      @luint num := [@luint new !0 !here] ;      @typeVariableDescriptor v := [@typeDirectVariable new !num !inBitSize !inLowBound !inHighBound] ;      insert outMap.insertKey inKey (!v) ;    when @typeRecordDomain (??@typeDomainMap inLocalRecordMap) ->      @typeTableVariablesBool localMap ;      exploreRecordDomain !inLocalRecordMap ?localMap !inErrorLocation ;      @typeVariableDescriptor v := [@typeRecordVariable new !localMap] ;      insert outMap.insertKey inKey (!v) ;    else       error inErrorLocation : "a domain was expected here ; I found " . [inDomain messageDomainType] ;     end extract ;  end foreach ;end routine ;#-------------------------------------------------------------------*routine buildFormalArgsList ??@typeVariableDescriptor inVariableDescriptor                            ?!@typeFormalArgumentsList ioFormalArgsList                            ??@location inErrorLocation ;routine buildFormalArgsList ??@typeVariableDescriptor inVariableDescriptor                            ?!@typeFormalArgumentsList ioFormalArgsList                            ??@location inErrorLocation :  extract inVariableDescriptor :  when @typeDirectVariable (??@luint inIndexVar ??@luint inBitSize ??@luint inLowBound ??@luint inHighBound) ->    ioFormalArgsList += !inIndexVar !inBitSize !inLowBound !inHighBound ;  when @typeRecordVariable (??@typeTableVariablesBool inLocalRecordMap) ->    foreach inLocalRecordMap (??* ??@typeVariableDescriptor inLocalVariableDescriptor) :      buildFormalArgsList !inLocalVariableDescriptor !?ioFormalArgsList !inErrorLocation ;    end foreach ;  else     error inErrorLocation : "a variable was expected here ; I found " . [inVariableDescriptor variableDescriptorErrorMessage] ;   end extract ;end routine ;#-------------------------------------------------------------------*rule <declarations>  ?!@typeTableVariablesBool tableVariables  ?!@typeDomainMap ioDomainMap  !@typeFormalArgumentsList listeArgFormelsBool:  listeArgFormelsBool := [@typeFormalArgumentsList empty] ;  repeat    @lstring nom;    $id$ ? nom;    @typeDomain domain ;    <dimension> !?ioDomainMap ?domain ;    extract domain :    when @typeDirectDomain (??@luint inLowBound ??@luint inHighBound ??@luint inDim) ->      @luint num ;      @luint pipo := [@luint new !0 !here] ;      @typeVariableDescriptor v := [@typeDirectVariable new !pipo !inDim !inLowBound !inHighBound] ;       insert tableVariables.insertKey nom (!v) ;      search tableVariables.searchKey nom (?v) ;      extract v->@typeDirectVariable (?num ?* ?* ?*) error nom : variableDescriptorErrorMessage ;      listeArgFormelsBool += !num !inDim !inLowBound !inHighBound ;    when @typeRecordDomain (??@typeDomainMap inRecordMap) ->      @typeTableVariablesBool recordMap ;      @location errorLocation := here ;      exploreRecordDomain !inRecordMap ?recordMap !errorLocation ;      @typeVariableDescriptor v := [@typeRecordVariable new !recordMap] ;      insert tableVariables.insertKey nom (!v) ;      search tableVariables.searchKey nom (?v) ;      buildFormalArgsList !v !?listeArgFormelsBool !errorLocation ;    else      error nom : "a domain was expected here ; I found " . [domain messageDomainType] ;    end extract ;  while    $,$ ;  end repeat ;end rule ;#-------------------------------------------------------------------*#              Dimension d'une variable                             *#-------------------------------------------------------------------*rule <dimension>  ?!@typeDomainMap ioDomainMap  !@typeDomain outDomain:  select    @luint lowBound := [@luint new !0 !here] ;    @luint highBound := [@luint new !1 !here] ;    @luint dim := [@luint new !1 !here] ;    outDomain := [@typeDirectDomain new !lowBound !highBound !dim] ;    warning dim : "old style implicit boolean declaration : now use bool keyword" ;  or    $:$ ;    select      @luint dim ;      $nombre$ ? dim ;      warning dim : "old style definition : now use bool [...]" ;      @luint lowBound := [@luint new !0 !here] ;      @luint highBound ;      action getHighBound !dim ?highBound ;      outDomain := [@typeDirectDomain new !lowBound !highBound !dim] ;    or      $bool$ ;      @luint lowBound := [@luint new !0 !here] ;      @luint highBound ;      @luint dim ;      select        highBound := [@luint new !1 !here] ;        dim := [@luint new !1 !here] ;      or        $[$ ;        $nombre$ ? dim ;        $]$ ;        action getHighBound !dim ?highBound ;      end select ;      outDomain := [@typeDirectDomain new !lowBound !highBound !dim] ;    or      @lstring domainName ;      $id$ ? domainName ;      search ioDomainMap.searchKey domainName (?outDomain) ;    end select ;  end select ;end rule ;#-------------------------------------------------------------------*#                    type de formule (:=, +=, -=)                   *#-------------------------------------------------------------------*rule <type_formule>  ?@typeTableVariablesBool tableVariables  ?!@typeDomainMap ioDomainMap  ?!@typeTableFormules tableFormules  ?@lstring nomFormule  ?@typeFormalArgumentsList listeArgFormelsBool  ?@luint afficherBDD  !@typeCalcul calcul:  $:=$ ;  @luint numero ;  @typeFormule f ;  @typeTableVariablesBool tableVariablesLocales := tableVariables ;  <formule> !tableVariablesLocales !?ioDomainMap !?tableFormules ?f ;  @bdd unusedBDD [empty] ;  insert tableFormules.insertKey nomFormule (!listeArgFormelsBool !unusedBDD) -> numero ;  calcul := [@typeCalculSimple new !numero !f !nomFormule !tableVariables !afficherBDD] ;end rule ;#-------------------------------------------------------------------*rule <type_formule>  ?@typeTableVariablesBool tableVariables  ?!@typeDomainMap ioDomainMap  ?!@typeTableFormules tableFormules  ?@lstring nomFormule  ?@typeFormalArgumentsList listeArgFormelsBool  ?@luint afficherBDD  !@typeCalcul calcul:  $+=$ ;  @lbool signe := [@lbool new !true !here] ;  @luint numero ;  @bdd unusedBDD [empty] ;  insert tableFormules.insertKey nomFormule (!listeArgFormelsBool !unusedBDD) -> numero ;  @typeFormule f ;  @typeTableVariablesBool tableVariablesLocales := tableVariables ;  <formule> !tableVariablesLocales !?ioDomainMap !?tableFormules ?f ;  calcul := [@typeCalculIteratif new !numero !f !nomFormule !tableVariables !signe !afficherBDD] ;end rule ;#-------------------------------------------------------------------*rule <type_formule>  ?@typeTableVariablesBool tableVariables  ?!@typeDomainMap ioDomainMap  ?!@typeTableFormules tableFormules  ?@lstring nomFormule  ?@typeFormalArgumentsList listeArgFormelsBool  ?@luint afficherBDD  !@typeCalcul calcul:  $-=$ ;  @lbool signe := [@lbool new !false !here] ;  @luint numero ;  @bdd unusedBDD [empty] ;  insert tableFormules.insertKey nomFormule (! listeArgFormelsBool !unusedBDD) -> numero ;  @typeFormule f ;  @typeTableVariablesBool tableVariablesLocales ;  tableVariablesLocales := tableVariables ;  <formule> !tableVariablesLocales !?ioDomainMap !?tableFormules ?f ;  calcul := [@typeCalculIteratif new !numero !f !nomFormule !tableVariables !signe !afficherBDD] ;end rule ;#-------------------------------------------------------------------*#                             formule                               *#-------------------------------------------------------------------*rule <formule>  ?@typeTableVariablesBool tableVariables  ?!@typeDomainMap ioDomainMap  ?!@typeTableFormules tableFormules  !@typeFormule formule:  <egalite_formule> !tableVariables !?ioDomainMap !?tableFormules ?formule ;  repeat  while    @luint comparaison ;    $comp$ ? comparaison ;    @typeFormule g ;    @typeFormule h := formule ;    <egalite_formule> !tableVariables !?ioDomainMap !?tableFormules ?g ;    formule := [@typeComparaisonFormules new !comparaison !h !g] ;  while    $->$ ;    @typeFormule g ;    @typeFormule h := formule ;    <egalite_formule> !tableVariables !?ioDomainMap !?tableFormules ?g ;    formule := [@typeFormuleImplique new !h !g] ;  end repeat ;end rule ;#-------------------------------------------------------------------*#                           egalite_formule                         *#-------------------------------------------------------------------*rule <egalite_formule>  ?@typeTableVariablesBool tableVariables  ?!@typeDomainMap ioDomainMap  ?!@typeTableFormules tableFormules  !@typeFormule formule:  <terme_formule> !tableVariables !?ioDomainMap !?tableFormules ?formule ;  repeat  while    $|$ ;    @typeFormule g ;    @typeFormule h := formule ;    <terme_formule> !tableVariables !?ioDomainMap !?tableFormules ?g ;    formule := [@typeFormuleOu new !h !g] ;  end repeat ;end rule ;#-------------------------------------------------------------------*#                           terme_formule                           *#-------------------------------------------------------------------*rule <terme_formule>  ?@typeTableVariablesBool tableVariables  ?!@typeDomainMap ioDomainMap  ?!@typeTableFormules tableFormules  !@typeFormule formule:  <facteur_formule> !tableVariables !?ioDomainMap !?tableFormules ?formule ;  repeat  while    $&$ ;    @typeFormule g ;    @typeFormule h := formule ;    <facteur_formule> !tableVariables !?ioDomainMap !?tableFormules  ?g ;    formule := [@typeFormuleEt new !h !g] ;  end repeat ;end rule ;#-------------------------------------------------------------------*#                           facteur_formule                         *#-------------------------------------------------------------------*rule <facteur_formule>  ?@typeTableVariablesBool tableVariables  ?!@typeDomainMap ioDomainMap  ?!@typeTableFormules tableFormules  !@typeFormule formule:  $($ ;  <formule> !tableVariables !?ioDomainMap !?tableFormules ?formule ;  $)$ ;end rule ;#-------------------------------------------------------------------*rule <facteur_formule>  ?@typeTableVariablesBool tableVariables  ?!@typeDomainMap unused ioDomainMap  ?!@typeTableFormules unused tableFormules  !@typeFormule formule:  $true$ ;  formule := [@typeFormuleTrue new] ;end rule ;#-------------------------------------------------------------------*rule <facteur_formule>  ?@typeTableVariablesBool tableVariables  ?!@typeDomainMap unused ioDomainMap  ?!@typeTableFormules unused tableFormules  !@typeFormule formule:  ${$ ;  @luint varIndex ;  @luint bitSize ;  @luint lowBound ;  @luint highBound ;  @location errorLocation ;  <parse_scalar_argument> !?tableVariables ?varIndex ?bitSize ?lowBound ?highBound ?errorLocation ;  @luint comparaison ;  $comp$ ? comparaison ;  <comparaisonVariable> !tableVariables !varIndex !bitSize !lowBound !highBound !comparaison ?formule ;  $}$ ;end rule ;#-------------------------------------------------------------------*rule <comparaisonVariable>  ?@typeTableVariablesBool tableVariables  ?@luint numero  ?@luint dim  ?@luint lowBound  ?@luint highBound  ?@luint comparaison  !@typeFormule formule:  @luint valeur ;  $nombre$ ? valeur ;  action verifierDimensionValeurCorrecte !dim !valeur ;  formule := [@typeFormuleComparaisonValeur new !numero !dim !lowBound !highBound !comparaison !valeur] ;end rule ;#-------------------------------------------------------------------*rule <comparaisonVariable>  ?@typeTableVariablesBool tableVariables  ?@luint inLeftVarIndex  ?@luint inLeftBitSize  ?@luint inLeftLowBound  ?@luint inLeftHighBound  ?@luint comparaison  !@typeFormule formule:  @luint rightVarIndex ;  @luint rightBitSize ;  @luint rightLowBound ;  @luint rightHighBound ;  @location errorLocation ;  <parse_scalar_argument> !?tableVariables ?rightVarIndex ?rightBitSize ?rightLowBound ?rightHighBound ?errorLocation ;  action verifierMemesDimensions !inLeftBitSize !rightBitSize ;  formule := [@typeFormuleComparaisonVariable new !inLeftVarIndex !inLeftBitSize !inLeftLowBound !inLeftHighBound                                                  !comparaison                                                  !rightVarIndex !rightLowBound !rightHighBound] ;end rule ;#-------------------------------------------------------------------*rule <facteur_formule>  ?@typeTableVariablesBool tableVariables  ?!@typeDomainMap unused ioDomainMap  ?!@typeTableFormules unused tableFormules  !@typeFormule formule:  $false$ ;  formule := [@typeFormuleFalse new] ;end rule ;#-------------------------------------------------------------------*rule <facteur_formule>  ?@typeTableVariablesBool tableVariables  ?!@typeDomainMap ioDomainMap  ?!@typeTableFormules tableFormules  !@typeFormule formule:  $~$ ;  @typeFormule f ;  <facteur_formule> !tableVariables !?ioDomainMap !?tableFormules ?f ;  formule := [@typeFormuleNon new !f] ;end rule ;#-------------------------------------------------------------------*rule <facteur_formule>  ?@typeTableVariablesBool tableVariables  ?!@typeDomainMap ioDomainMap  ?!@typeTableFormules tableFormules  !@typeFormule formule:  $if$ ;  @typeFormule operande1 ;  <formule> !tableVariables !?ioDomainMap !?tableFormules ?operande1 ;  $then$ ;  @typeFormule operande2 ;  <formule> !tableVariables !?ioDomainMap !?tableFormules ?operande2 ;  $else$ ;  @typeFormule operande3 ;  <formule> !tableVariables !?ioDomainMap !?tableFormules ?operande3 ;  $end$ ;  formule := [@typeFormuleIte new !operande1 !operande2 !operande3] ;end rule ;#-------------------------------------------------------------------*rule <facteur_formule>  ?@typeTableVariablesBool tableVariables  ?!@typeDomainMap ioDomainMap  ?!@typeTableFormules tableFormules  !@typeFormule formule:  $!$ ;  @typeFormalArgumentsList listeNumVarsBool ;  @typeTableVariablesBool tableLocaleVariables := tableVariables ;  <declarations> !?tableLocaleVariables !?ioDomainMap                ?listeNumVarsBool ;  @typeFormule f ;  <facteur_formule> !tableLocaleVariables  !?ioDomainMap!?tableFormules ?f ;#--- use identity : 'forall (f)' is equivalent to 'not (exist (not f))'  @typeFormule not_f := [@typeFormuleNon new !f] ;  @bdd unusedBDD [empty] ;  @typeFormule exist_not_f := [@typeFormuleExist new !listeNumVarsBool !not_f !unusedBDD] ;  formule := [@typeFormuleNon new !exist_not_f] ;end rule ;#-------------------------------------------------------------------*rule <facteur_formule>  ?@typeTableVariablesBool tableVariables  ?!@typeDomainMap ioDomainMap  ?!@typeTableFormules tableFormules  !@typeFormule formule:  $?$ ;  @typeFormalArgumentsList listeNumVarsBool ;  @typeTableVariablesBool tableLocaleVariables := tableVariables ;  <declarations> !?tableLocaleVariables !?ioDomainMap                 ?listeNumVarsBool ;  @typeFormule f ;  <facteur_formule> !tableLocaleVariables !?ioDomainMap !?tableFormules ?f ;  @bdd unusedBDD [empty] ;  formule := [@typeFormuleExist new !listeNumVarsBool !f !unusedBDD] ;end rule ;#-------------------------------------------------------------------*rule <facteur_formule>  ?@typeTableVariablesBool tableVariables  ?!@typeDomainMap unused ioDomainMap  ?!@typeTableFormules unused tableFormules  !@typeFormule formule:  @luint varIndex ;  @luint bitSize ;  @luint lowBound ;  @luint highBound ;  @location errorLocation ;  <parse_scalar_argument>!?tableVariables ?varIndex ?bitSize ?lowBound ?highBound ?errorLocation ;  action verifierDimensionUn !bitSize !errorLocation ;  formule := [@typeFormuleVar new !varIndex !lowBound !highBound] ;end rule ;#-------------------------------------------------------------------*routine buildActualArgsList ??@typeTableVariablesBool inDomainMap                            ?!@typeActualArgumentsList ioActualArgsList                            ??@location inErrorLocation ;routine buildActualArgsList ??@typeTableVariablesBool inDomainMap                            ?!@typeActualArgumentsList ioActualArgsList                            ??@location inErrorLocation :  foreach inDomainMap (??* ??@typeVariableDescriptor inLocalVariableDescriptor) :    extract inLocalVariableDescriptor :    when @typeDirectVariable (??@luint inIndexVar ??@luint inBitSize ??@luint inLowBound ??@luint inHighBound) ->      ioActualArgsList += !inIndexVar !inBitSize !inLowBound !inHighBound !inErrorLocation ;    when @typeRecordVariable (??@typeTableVariablesBool inLocalRecordMap) ->      buildActualArgsList !inLocalRecordMap !?ioActualArgsList !inErrorLocation ;    else       error inErrorLocation : "a variable was expected here ; I found "             . [inLocalVariableDescriptor  variableDescriptorErrorMessage] ;    end extract ;  end foreach ;end routine ;#-------------------------------------------------------------------*rule <facteur_formule>  ?@typeTableVariablesBool tableVariables  ?!@typeDomainMap unused ioDomainMap  ?!@typeTableFormules tableFormules  !@typeFormule formule:  $#$ ;  @lstring nom ;  @luint numero ;  $id$ ? nom ;  @typeFormalArgumentsList listeArgsFormelsBool ;  search tableFormules.searchKey nom (?listeArgsFormelsBool ?*) -> numero ;  $[$ ;  @typeActualArgumentsList listeArgsEffectifsBool [empty] ;  repeat    @typeVariableDescriptor varDescriptor ;    @location errorLocation ;    <parse_argument> !?tableVariables ?varDescriptor ?errorLocation ;    select      extract varDescriptor :      when @typeDirectVariable (??@luint varIndex ??@luint bitSize ??@luint lowBound ??@luint highBound) ->        listeArgsEffectifsBool += !varIndex !bitSize !lowBound !highBound !errorLocation ;      when @typeRecordVariable (??@typeTableVariablesBool inRecordMap) ->        buildActualArgsList !inRecordMap !?listeArgsEffectifsBool !errorLocation ;      else        error errorLocation : "a variable was expected here ; I found " .                     [varDescriptor variableDescriptorErrorMessage] ;      end extract ;    or      @luint explicitBitSize ;      @luint explicitVarIndex ;      $:$ ;      $nombre$ ? explicitBitSize ;      $::$ ;      $nombre$ ? explicitVarIndex ;      @luint varIndex ;      @luint bitSize ;      @luint lowBound ;      @luint highBound ;      extract varDescriptor->@typeDirectVariable (?varIndex ?bitSize ?lowBound ?highBound)                  error errorLocation : variableDescriptorErrorMessage ;      action verifierDimensionExpliciteCorrecte !explicitVarIndex !explicitBitSize !?varIndex !bitSize ;      listeArgsEffectifsBool += !varIndex !bitSize !lowBound !highBound !errorLocation ;    end select ;  while    $,$ ;  end repeat ;  $]$ ;#--- Verifier le bon nombre d'arguments  @location positionFinListe := here ;  verifierNombreArgumentsBool !listeArgsFormelsBool !listeArgsEffectifsBool !positionFinListe ;  @bdd unusedBDD [empty] ;  @lbool unusedBool := [@lbool new !false !here] ;  formule := [@typeFormuleFor new !numero !listeArgsEffectifsBool !unusedBDD !unusedBool] ;end rule ;#-------------------------------------------------------------------*rule <parse_argument>  ?!@typeTableVariablesBool ioVarMap  !@typeVariableDescriptor outVarDescriptor  !@location outErrorLocation:  @lstring varName ;  $id$ ? varName ;  outErrorLocation := [varName location] ;  search ioVarMap.searchKey varName (?outVarDescriptor) ;  repeat  while    $.$ ;    @location errorLoc := here ;    @typeTableVariablesBool fieldMap ;    extract outVarDescriptor->@typeRecordVariable (?fieldMap)          error errorLoc : variableDescriptorErrorMessage ;    @lstring fieldName ;    $id$ ?fieldName ;    outErrorLocation := [fieldName location] ;    search fieldMap.searchKey fieldName (?outVarDescriptor) ;  end repeat ;end rule ;#-------------------------------------------------------------------*rule <parse_scalar_argument>  ?!@typeTableVariablesBool ioVarMap  !@luint outVarIndex  !@luint outBitSize  !@luint outLowBound  !@luint outHighBound  !@location outErrorLocation:  @typeVariableDescriptor v ;  <parse_argument> !?ioVarMap ?v ?outErrorLocation ;  @luint bitSize ;  @luint varIndex ;  extract v->@typeDirectVariable (?varIndex ?bitSize ?outLowBound ?outHighBound)          error outErrorLocation : variableDescriptorErrorMessage ;  select    outVarIndex := varIndex ;    outBitSize := bitSize ;  or    $:$ ;    $nombre$ ? outBitSize ;    $::$ ;    $nombre$ ? outVarIndex ;    action verifierDimensionExpliciteCorrecte !varIndex !bitSize !?outVarIndex !outBitSize ;  end select ;end rule ;#-------------------------------------------------------------------*end syntax ;