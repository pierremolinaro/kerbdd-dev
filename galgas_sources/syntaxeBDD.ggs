syntax syntaxeBDD :

#-------------------------------------------------------------------*

  with "lexiqueBDD.gLexique" ;

import lexique lexiqueBDD in "lexiqueBDD.gLexique" ;
import semantics semantiqueBDD in "semantiqueBDD.ggs" ;
import grammar grammaireBDD in "grammaireBDD.gGrammar" ;

#-------------------------------------------------------------------*

nonterminal <axiomeBDD>
  ?!@typeTableFormules tableFormules
  ?!@typeListeCalculs listeCalculs
  ?!@typeDomainMap ioDomainMap
;

nonterminal <domainDefinition>
  ?!@typeDomainMap ioDomainMap
  !@typeDomain outDomain
;

nonterminal <formule>
  ?@typeTableVariablesBool tableVariables
  ?@uint inBDDslot
  ?!@typeDomainMap ioDomainMap
  ?!@typeTableFormules tableFormules
  !@typeFormule formule
;

nonterminal <type_formule>
  ?@typeTableVariablesBool tableVariables
  ?@uint inBDDslot
  ?!@typeDomainMap ioDomainMap
  ?!@typeTableFormules tableFormules
  ?@lstring nomFormule
  ?@typeFormalArgumentsList listeArgFormelsBool
  ?@luint afficherBDD
  !@typeCalcul calcul
;

nonterminal <egalite_formule>
  ?@typeTableVariablesBool tableVariables
  ?@uint inBDDslot
  ?!@typeDomainMap ioDomainMap
  ?!@typeTableFormules tableFormules
  !@typeFormule formule
;

nonterminal <facteur_formule>
  ?@typeTableVariablesBool tableVariables
  ?@uint inBDDslot
  ?!@typeDomainMap ioDomainMap
  ?!@typeTableFormules tableFormules
  !@typeFormule formule
;

nonterminal <terme_formule>
  ?@typeTableVariablesBool tableVariables
  ?@uint inBDDslot
  ?!@typeDomainMap ioDomainMap
  ?!@typeTableFormules tableFormules
  !@typeFormule formule
;

nonterminal <dimension>
  ?!@typeDomainMap ioDomainMap
  !@typeDomain outDomain
;

nonterminal <comparaisonVariable>
  ?@typeTableVariablesBool tableVariables
  ?@luint numero
  ?@luint dim
  ?@luint lowBound
  ?@luint highBound
  ?@luint comparaison
  !@typeFormule formule
;

nonterminal <analyserFormule>
  ?!@typeTableFormules tableFormules
  ?!@typeDomainMap ioDomainMap
  ?!@typeListeCalculs listeCalculs
  ?@luint afficherBDD
;

nonterminal <argsFormelsFormule>
  !@typeTableVariablesBool tableVariables
  !@uint outBDDslot
  ?!@typeDomainMap ioDomainMap
  !@typeFormalArgumentsList listeArgFormelsBool
;

nonterminal <declarations>
  ?!@typeTableVariablesBool tableVariables
  ?!@uint ioBDDslot
  ?!@typeDomainMap ioDomainMap
  !@typeFormalArgumentsList listeArgFormelsBool
;

nonterminal <parse_scalar_argument>
  ?!@typeTableVariablesBool ioVarMap
  !@luint outVarIndex
  !@luint outBitSize
  !@luint outLowBound
  !@luint outHighBound
  !@location outErrorLocation ;

nonterminal <parse_argument>
  ?!@typeTableVariablesBool ioVarMap
  !@typeVariableDescriptor outVarDescriptor
  !@location outErrorLocation
;

#-------------------------------------------------------------------*
#                             axiome                                *
#-------------------------------------------------------------------*

rule <axiomeBDD>
  ?!@typeTableFormules tableFormules
  ?!@typeListeCalculs listeCalculs
  ?!@typeDomainMap ioDomainMap
:
  repeat
  while 
    $domain$ ;
    @lstring domainName ;
    $id$ ? domainName ;
    $:$ ;
    @typeDomain d ;
    <domainDefinition> !?ioDomainMap ?d ;
    [!?ioDomainMap insertKey !domainName !d] ;
    $;$ ;
  while 
    $include$ ;
    @lstring nomFichierInclusion ;
    $string$ ? nomFichierInclusion ;
    $;$ ;
    grammar grammaireBDD in nomFichierInclusion
      !?tableFormules
      !?listeCalculs
      !?ioDomainMap
    ;
  while
    $use_and$ ;
    @typeCalcul calcul := [@typeUse_AND new] ;
    listeCalculs += !calcul ;
    $;$ ;
  while
    $use_ite$ ;
    @typeCalcul calcul := [@typeUse_ITE new] ;
    listeCalculs += !calcul ;
    $;$ ;
  while
    $use_and_ite$ ;
    @typeCalcul calcul := [@typeUse_AND_ITE new] ;
    listeCalculs += !calcul ;
    $;$ ;
  while
    $and_cache$ ;
    @luint dimensionCache ;
    $nombre$ ?dimensionCache ;
    @typeCalcul calcul ;
    calcul := [@typeDimensionnerANDCache new !dimensionCache] ;
    listeCalculs += !calcul ;
    $;$ ;
  while
    $ite_cache$ ;
    @luint dimensionCache ;
    $nombre$ ?dimensionCache ;
    @typeCalcul calcul ;
    calcul := [@typeDimensionnerITECache new !dimensionCache] ;
    listeCalculs += !calcul ;
    $;$ ;
  while 
    $map$ ;
    @luint dimensionTable ;
    $nombre$ ? dimensionTable ;
    @typeCalcul calcul ;
    calcul := [@typeDimensionnerTable new !dimensionTable] ;
    listeCalculs += !calcul ;
    $;$ ;
  while 
    $bdd$ ;
    @typeCalcul calcul ;
    calcul := [@typeAfficherBilan new] ;
    listeCalculs += !calcul ;
    $;$ ;
  while
    $display$ ;
    @luint afficherBDD ;
    afficherBDD := [@luint new !1 !here] ;
    $#$ ;
    <analyserFormule> !?tableFormules !?ioDomainMap !?listeCalculs !afficherBDD ;
    $;$ ;
  while
    $dump$ ;
    @luint afficherBDD ;
    afficherBDD := [@luint new !2 !here] ;
    $#$ ;
    <analyserFormule> !?tableFormules !?ioDomainMap !?listeCalculs !afficherBDD ;
    $;$ ;
  while
    $verify$ ;
    @luint afficherBDD ;
    afficherBDD := [@luint new !3 !here] ;
    $#$ ;
    <analyserFormule> !?tableFormules !?ioDomainMap !?listeCalculs !afficherBDD ;
    $;$ ;
  while
    $#$ ;
    @luint afficherBDD ;
    afficherBDD := [@luint new !0 !here] ;
    <analyserFormule> !?tableFormules !?ioDomainMap !?listeCalculs !afficherBDD ;
    $;$ ;
  end repeat ;
  $end$ ;
end rule ;

#-------------------------------------------------------------------*

rule <domainDefinition>
  ?!@typeDomainMap ioDomainMap
  !@typeDomain outDomain
:
  select
    @luint lowBound ;
    @luint highBound ;
    select
      $nombre$ ? lowBound ;
      $..$ ;
      $nombre$ ? highBound ;
   or
      $bool$ ;
      lowBound := [@luint new !0 !here] ;
      select
        highBound := [@luint new !1 !here] ;
      or
        $[$ ;
        @luint dim ;
        $nombre$ ? dim ;
        $]$ ;
        getHighBound !dim ?highBound ;
      end select ;
    end select ;
    @luint dimension ;
    verifyBoundsAndComputeDimension !lowBound !highBound ?dimension ;
    outDomain := [@typeDirectDomain new !lowBound !highBound !dimension] ;
  or
    $record$ ;
    @typeDomainMap recordDomainMap [emptyMap] ;
    repeat
      @lstring fieldName ;
      $id$ ? fieldName ;
      $:$ ;
      @typeDomain d ;
      <domainDefinition> !?ioDomainMap ?d ;
      $;$ ;
      [!?recordDomainMap insertKey !fieldName !d] ;
    while
    end repeat ;
    $end$ ;
    $record$ ;
    outDomain := [@typeRecordDomain new !recordDomainMap] ;
  or
    @lstring domainName ;
    $id$ ? domainName ;
    [ioDomainMap searchKey !domainName ?outDomain] ;
  end select ;
end rule ;

#-------------------------------------------------------------------*
#                       Formule                                     *
#-------------------------------------------------------------------*

rule <analyserFormule>
  ?!@typeTableFormules tableFormules
  ?!@typeDomainMap ioDomainMap
  ?!@typeListeCalculs listeCalculs
  ?@luint afficherBDD
:
  @lstring nomFormule ;
  $id$ ? nomFormule ;
  @typeTableVariablesBool tableVariables ;
  @uint bddSlot ;
  @typeFormalArgumentsList listeArgFormelsBool ;
  <argsFormelsFormule>
    ?tableVariables
    ?bddSlot
    !?ioDomainMap
    ?listeArgFormelsBool
  ;
  @typeCalcul calcul ;
  <type_formule>
    !tableVariables
    !bddSlot
    !?ioDomainMap
    !?tableFormules
    !nomFormule
    !listeArgFormelsBool
    !afficherBDD
    ?calcul
  ;
  listeCalculs += !calcul ;
end rule ;

#-------------------------------------------------------------------*
#                Arguments formels de la formule                    *
#-------------------------------------------------------------------*

rule <argsFormelsFormule>
  !@typeTableVariablesBool tableVariables
  !@uint outBDDslot
  ?!@typeDomainMap ioDomainMap
  !@typeFormalArgumentsList listeArgFormelsBool
:
  tableVariables := [@typeTableVariablesBool emptyMap] ;
  outBDDslot := 0 ;
  select
    # Pas de declarations
    listeArgFormelsBool := [@typeFormalArgumentsList emptyList] ;
  or
    $[$ ;
    <declarations>
      !?tableVariables
      !?outBDDslot
      !?ioDomainMap
      ?listeArgFormelsBool
    ;
    $]$ ;
  end select ;
end rule ;

#-------------------------------------------------------------------*

routine exploreRecordDomain
  ??@typeDomainMap inRecordMap
  !@typeTableVariablesBool outMap
  ?!@uint ioBDDslot
  ??@location inErrorLocation
:
  outMap := [@typeTableVariablesBool emptyMap] ;
  foreach inRecordMap do
    cast mDomain :
    when >= @typeDirectDomain dd do # § (@luint inLowBound @luint inHighBound @luint inBitSize) ->
      @luint slot := [@luint new !ioBDDslot !here] ;
      @typeVariableDescriptor v := [@typeDirectVariable new !slot ![dd mBitsCount] ![dd mLowBound] ![dd mHighBound]] ;
      [!?outMap insertKey !key !v] ;
      ioBDDslot := ioBDDslot + [[dd mBitsCount] uint] ;
    when >= @typeRecordDomain rd do # §(@typeDomainMap inLocalRecordMap) ->
      @typeTableVariablesBool localMap ;
      exploreRecordDomain ![rd mRecordMap] ?localMap !?ioBDDslot !inErrorLocation ;
      @typeVariableDescriptor v := [@typeRecordVariable new !localMap] ;
      [!?outMap insertKey !key !v] ;
    else
       error inErrorLocation : "a aDomain was expected here ; I found " . [mDomain messageDomainType] ;
     end cast ;
  end foreach ;
end routine ;

#-------------------------------------------------------------------*

rule <declarations>
  ?!@typeTableVariablesBool tableVariables
  ?!@uint ioBDDslot
  ?!@typeDomainMap ioDomainMap
  !@typeFormalArgumentsList listeArgFormelsBool
:
  listeArgFormelsBool := [@typeFormalArgumentsList emptyList] ;
  repeat
    @lstring nom;
    $id$ ? nom;
    @typeDomain aDomain ;
    <dimension> !?ioDomainMap ?aDomain ;
    cast aDomain :
    when >= @typeDirectDomain dd do # § (@luint inLowBound @luint inHighBound @luint inBitSize) ->
      @luint slot := [@luint new !ioBDDslot !here] ;
      @typeVariableDescriptor v := [@typeDirectVariable new !slot ![dd mBitsCount] ![dd mLowBound] ![dd mHighBound]] ;
      [!?tableVariables insertKey !nom !v] ;
      ioBDDslot := ioBDDslot + [[dd mBitsCount] uint] ;
      cast v :
      when >= @typeDirectVariable dv do # §(?num ?* ?* ?*)
        listeArgFormelsBool += ![dv mIndex] ![dd mBitsCount] ![dd mLowBound] ![dd mHighBound] ;
      default error nom
      end cast ;
    when >= @typeRecordDomain rd do # §(@typeDomainMap inLocalRecordMap) ->
      @typeTableVariablesBool recordMap ;
      @location errorLocation := here ;
      exploreRecordDomain ![rd mRecordMap] ?recordMap !?ioBDDslot !errorLocation ;
      @typeVariableDescriptor v := [@typeRecordVariable new !recordMap] ;
      [!?tableVariables insertKey !nom !v] ;
      buildFormalArgsList !v !?listeArgFormelsBool !errorLocation ;
 
# §   when @typeDirectDomain (@luint inLowBound @luint inHighBound @luint inDim) ->
#      @luint slot [new !ioBDDslot !here] ;
#      @typeVariableDescriptor v := [@typeDirectVariable new !slot !inDim !inLowBound !inHighBound] ; 
#      [!?tableVariables insertKey !nom !v] ;
#      ioBDDslot := ioBDDslot + [inDim uint] ;
#      @luint num ;
#      extract v->@typeDirectVariable (?num ?* ?* ?*) error nom : variableDescriptorErrorMessage ;
#      listeArgFormelsBool += !num !inDim !inLowBound !inHighBound ;
#    when @typeRecordDomain (@typeDomainMap inRecordMap) ->
#      @typeTableVariablesBool recordMap ;
#      @location errorLocation := here ;
#      exploreRecordDomain !inRecordMap ?recordMap !?ioBDDslot !errorLocation ;
#      @typeVariableDescriptor v := [@typeRecordVariable new !recordMap] ;
#      [!?tableVariables insertKey !nom !v] ;
#      buildFormalArgsList !v !?listeArgFormelsBool !errorLocation ;
    else
      error nom : "a aDomain was expected here ; I found " . [aDomain messageDomainType] ;
    end cast ;
  while
    $,$ ;
  end repeat ;
end rule ;

#-------------------------------------------------------------------*
#              Dimension d'une variable                             *
#-------------------------------------------------------------------*

rule <dimension>
  ?!@typeDomainMap ioDomainMap
  !@typeDomain outDomain
:
  $:$ ;
  select
    $bool$ ;
    @luint lowBound := [@luint new !0 !here] ;
    @luint highBound ;
    @luint dim ;
    select
      highBound := [@luint new !1 !here] ;
      dim := [@luint new !1 !here] ;
    or
      $[$ ;
      $nombre$ ? dim ;
      $]$ ;
      getHighBound !dim ?highBound ;
    end select ;
    outDomain := [@typeDirectDomain new !lowBound !highBound !dim] ;
  or
    @lstring domainName ;
    $id$ ? domainName ;
    [ioDomainMap searchKey !domainName ?outDomain] ;
  end select ;
end rule ;

#-------------------------------------------------------------------*
#                    type de formule (:=, +=, -=)                   *
#-------------------------------------------------------------------*

rule <type_formule>
  ?@typeTableVariablesBool tableVariables
  ?@uint inBDDslot
  ?!@typeDomainMap ioDomainMap
  ?!@typeTableFormules tableFormules
  ?@lstring nomFormule
  ?@typeFormalArgumentsList listeArgFormelsBool
  ?@luint afficherBDD
  !@typeCalcul calcul
:
  $:=$ ;
  @luint numero ;
  @typeFormule f ;
  @typeTableVariablesBool tableVariablesLocales := tableVariables ;
  <formule>
    !tableVariablesLocales
    !inBDDslot
    !?ioDomainMap
    !?tableFormules
    ?f
  ;
  @extern_bdd unusedBDD [empty] ;
  [!?tableFormules insertKeyGetIndex !nomFormule ?numero !listeArgFormelsBool !unusedBDD] ;
  calcul := [@typeCalculSimple new !numero !f !nomFormule !tableVariables !afficherBDD] ;
end rule ;

#-------------------------------------------------------------------*

rule <type_formule>
  ?@typeTableVariablesBool tableVariables
  ?@uint inBDDslot
  ?!@typeDomainMap ioDomainMap
  ?!@typeTableFormules tableFormules
  ?@lstring nomFormule
  ?@typeFormalArgumentsList listeArgFormelsBool
  ?@luint afficherBDD
  !@typeCalcul calcul
:
  $+=$ ;
  @lbool signe := [@lbool new !true !here] ;
  @luint numero ;
  @extern_bdd unusedBDD [empty] ;
  [!?tableFormules insertKeyGetIndex !nomFormule ?numero !listeArgFormelsBool !unusedBDD] ;
  @typeFormule f ;
  @typeTableVariablesBool tableVariablesLocales := tableVariables ;
  <formule>
    !tableVariablesLocales
    !inBDDslot
    !?ioDomainMap
    !?tableFormules
    ?f
  ;
  calcul := [@typeCalculIteratif new !numero !f !nomFormule !tableVariables !signe !afficherBDD] ;
end rule ;

#-------------------------------------------------------------------*

rule <type_formule>
  ?@typeTableVariablesBool tableVariables
  ?@uint inBDDslot
  ?!@typeDomainMap ioDomainMap
  ?!@typeTableFormules tableFormules
  ?@lstring nomFormule
  ?@typeFormalArgumentsList listeArgFormelsBool
  ?@luint afficherBDD
  !@typeCalcul calcul
:
  $-=$ ;
  @lbool signe := [@lbool new !false !here] ;
  @luint numero ;
  @extern_bdd unusedBDD [empty] ;
  [!?tableFormules insertKeyGetIndex !nomFormule ?numero !listeArgFormelsBool !unusedBDD] ;
  @typeFormule f ;
  @typeTableVariablesBool tableVariablesLocales ;
  tableVariablesLocales := tableVariables ;
  <formule>
    !tableVariablesLocales
    !inBDDslot
    !?ioDomainMap
    !?tableFormules
    ?f
  ;
  calcul := [@typeCalculIteratif new !numero !f !nomFormule !tableVariables !signe !afficherBDD] ;
end rule ;

#-------------------------------------------------------------------*
#                             formule                               *
#-------------------------------------------------------------------*

rule <formule>
  ?@typeTableVariablesBool tableVariables
  ?@uint inBDDslot
  ?!@typeDomainMap ioDomainMap
  ?!@typeTableFormules tableFormules
  !@typeFormule formule
:
  <egalite_formule>
    !tableVariables
    !inBDDslot
    !?ioDomainMap
    !?tableFormules
    ?formule
  ;
  repeat
  while
    @luint comparaison ;
    $comp$ ? comparaison ;
    @typeFormule g ;
    @typeFormule h := formule ;
    <egalite_formule>
      !tableVariables
      !inBDDslot
      !?ioDomainMap
      !?tableFormules
      ?g
    ;
    formule := [@typeComparaisonFormules new !comparaison !h !g] ;
  while
    $->$ ;
    @typeFormule g ;
    @typeFormule h := formule ;
    <egalite_formule>
      !tableVariables
      !inBDDslot
      !?ioDomainMap
      !?tableFormules
      ?g
    ;
    formule := [@typeFormuleImplique new !h !g] ;
  end repeat ;
end rule ;

#-------------------------------------------------------------------*
#                           egalite_formule                         *
#-------------------------------------------------------------------*

rule <egalite_formule>
  ?@typeTableVariablesBool tableVariables
  ?@uint inBDDslot
  ?!@typeDomainMap ioDomainMap
  ?!@typeTableFormules tableFormules
  !@typeFormule formule
:
  <terme_formule>
    !tableVariables
    !inBDDslot
    !?ioDomainMap
    !?tableFormules
    ?formule
  ;
  repeat
  while
    $|$ ;
    @typeFormule g ;
    @typeFormule h := formule ;
    <terme_formule>
      !tableVariables
      !inBDDslot
      !?ioDomainMap
      !?tableFormules
      ?g
    ;
    formule := [@typeFormuleOu new !h !g] ;
  end repeat ;
end rule ;

#-------------------------------------------------------------------*
#                           terme_formule                           *
#-------------------------------------------------------------------*

rule <terme_formule>
  ?@typeTableVariablesBool tableVariables
  ?@uint inBDDslot
  ?!@typeDomainMap ioDomainMap
  ?!@typeTableFormules tableFormules
  !@typeFormule formule
:
  <facteur_formule>
    !tableVariables
    !inBDDslot
    !?ioDomainMap
    !?tableFormules
    ?formule ;
  repeat
  while
    $&$ ;
    @typeFormule g ;
    @typeFormule h := formule ;
    <facteur_formule>
      !tableVariables
      !inBDDslot
      !?ioDomainMap
      !?tableFormules
      ?g
    ;
    formule := [@typeFormuleEt new !h !g] ;
  end repeat ;
end rule ;

#-------------------------------------------------------------------*
#                           facteur_formule                         *
#-------------------------------------------------------------------*

rule <facteur_formule>
  ?@typeTableVariablesBool tableVariables
  ?@uint inBDDslot
  ?!@typeDomainMap ioDomainMap
  ?!@typeTableFormules tableFormules
  !@typeFormule formule
:
  $($ ;
  <formule>
    !tableVariables
    !inBDDslot
    !?ioDomainMap
    !?tableFormules
    ?formule
  ;
  $)$ ;
end rule ;

#-------------------------------------------------------------------*

rule <facteur_formule>
  ?@typeTableVariablesBool unused tableVariables
  ?@uint unused inBDDslot
  ?!@typeDomainMap unused ioDomainMap
  ?!@typeTableFormules unused tableFormules
  !@typeFormule formule
:
  $true$ ;
  formule := [@typeFormuleTrue new] ;
end rule ;

#-------------------------------------------------------------------*

rule <facteur_formule>
  ?@typeTableVariablesBool tableVariables
  ?@uint unused inBDDslot
  ?!@typeDomainMap unused ioDomainMap
  ?!@typeTableFormules unused tableFormules
  !@typeFormule formule
:
  ${$ ;
  @luint varIndex ;
  @luint bitSize ;
  @luint lowBound ;
  @luint highBound ;
  @location errorLocation ;
  <parse_scalar_argument> !?tableVariables ?varIndex ?bitSize ?lowBound ?highBound ?errorLocation ;
  @luint comparaison ;
  $comp$ ? comparaison ;
  <comparaisonVariable>
    !tableVariables
    !varIndex
    !bitSize
    !lowBound !highBound !comparaison ?formule ;
  $}$ ;
end rule ;

#-------------------------------------------------------------------*

rule <comparaisonVariable>
  ?@typeTableVariablesBool unused tableVariables
  ?@luint numero
  ?@luint dim
  ?@luint lowBound
  ?@luint highBound
  ?@luint comparaison
  !@typeFormule formule
:
  @luint valeur ;
  $nombre$ ? valeur ;
  verifierDimensionValeurCorrecte !dim !valeur ;
  formule := [@typeFormuleComparaisonValeur new !numero !dim !lowBound !highBound !comparaison !valeur] ;
end rule ;

#-------------------------------------------------------------------*

rule <comparaisonVariable>
  ?@typeTableVariablesBool tableVariables
  ?@luint inLeftVarIndex
  ?@luint inLeftBitSize
  ?@luint inLeftLowBound
  ?@luint inLeftHighBound
  ?@luint comparaison
  !@typeFormule formule
:
  @luint rightVarIndex ;
  @luint rightBitSize ;
  @luint rightLowBound ;
  @luint rightHighBound ;
  @location errorLocation ;
  <parse_scalar_argument> !?tableVariables ?rightVarIndex ?rightBitSize ?rightLowBound ?rightHighBound ?errorLocation ;
  verifierMemesDimensions !inLeftBitSize !rightBitSize ;
  formule := [@typeFormuleComparaisonVariable new !inLeftVarIndex !inLeftBitSize !inLeftLowBound !inLeftHighBound
                                                  !comparaison
                                                  !rightVarIndex !rightLowBound !rightHighBound] ;
end rule ;

#-------------------------------------------------------------------*

rule <facteur_formule>
  ?@typeTableVariablesBool unused tableVariables
  ?@uint unused inBDDslot
  ?!@typeDomainMap unused ioDomainMap
  ?!@typeTableFormules unused tableFormules
  !@typeFormule formule
:
  $false$ ;
  formule := [@typeFormuleFalse new] ;
end rule ;

#-------------------------------------------------------------------*

rule <facteur_formule>
  ?@typeTableVariablesBool tableVariables
  ?@uint inBDDslot
  ?!@typeDomainMap ioDomainMap
  ?!@typeTableFormules tableFormules
  !@typeFormule formule
:
  $~$ ;
  @typeFormule f ;
  <facteur_formule>
    !tableVariables
    !inBDDslot
    !?ioDomainMap
    !?tableFormules
    ?f
  ;
  formule := [@typeFormuleNon new !f] ;
end rule ;

#-------------------------------------------------------------------*

rule <facteur_formule>
  ?@typeTableVariablesBool tableVariables
  ?@uint inBDDslot
  ?!@typeDomainMap ioDomainMap
  ?!@typeTableFormules tableFormules
  !@typeFormule formule
:
  $if$ ;
  @typeFormule operande1 ;
  <formule>
    !tableVariables
    !inBDDslot
    !?ioDomainMap
    !?tableFormules
    ?operande1
  ;
  $then$ ;
  @typeFormule operande2 ;
  <formule>
    !tableVariables
    !inBDDslot
    !?ioDomainMap
    !?tableFormules
    ?operande2
  ;
  $else$ ;
  @typeFormule operande3 ;
  <formule>
    !tableVariables
    !inBDDslot
    !?ioDomainMap
    !?tableFormules
    ?operande3
  ;
  $end$ ;
  formule := [@typeFormuleIte new !operande1 !operande2 !operande3] ;
end rule ;

#-------------------------------------------------------------------*

rule <facteur_formule>
  ?@typeTableVariablesBool tableVariables
  ?@uint inBDDslot
  ?!@typeDomainMap ioDomainMap
  ?!@typeTableFormules tableFormules
  !@typeFormule formule
:
  $!$ ;
  @typeFormalArgumentsList listeNumVarsBool ;
  @typeTableVariablesBool tableLocaleVariables := tableVariables ;
  @uint bddSlot := inBDDslot ;
  <declarations>
    !?tableLocaleVariables
    !?bddSlot
    !?ioDomainMap
    ?listeNumVarsBool
  ;
  @typeFormule f ;
  <facteur_formule>
    !tableLocaleVariables
    !bddSlot
    !?ioDomainMap
    !?tableFormules
    ?f
  ;
#--- use identity : 'forall (f)' is equivalent to 'not (exist (not f))'
  @typeFormule not_f := [@typeFormuleNon new !f] ;
  @extern_bdd unusedBDD [empty] ;
  @typeFormule exist_not_f := [@typeFormuleExist new !listeNumVarsBool !not_f !unusedBDD] ;
  formule := [@typeFormuleNon new !exist_not_f] ;
end rule ;

#-------------------------------------------------------------------*

rule <facteur_formule>
  ?@typeTableVariablesBool tableVariables
  ?@uint inBDDslot
  ?!@typeDomainMap ioDomainMap
  ?!@typeTableFormules tableFormules
  !@typeFormule formule
:
  $?$ ;
  @typeFormalArgumentsList listeNumVarsBool ;
  @typeTableVariablesBool tableLocaleVariables := tableVariables ;
  @uint bddSlot := inBDDslot ;
  <declarations>
    !?tableLocaleVariables
    !?bddSlot
    !?ioDomainMap
    ?listeNumVarsBool
  ;
  @typeFormule f ;
  <facteur_formule>
    !tableLocaleVariables
    !bddSlot
    !?ioDomainMap
    !?tableFormules
    ?f
  ;
  @extern_bdd unusedBDD [empty] ;
  formule := [@typeFormuleExist new !listeNumVarsBool !f !unusedBDD] ;
end rule ;

#-------------------------------------------------------------------*

rule <facteur_formule>
  ?@typeTableVariablesBool tableVariables
  ?@uint unused inBDDslot
  ?!@typeDomainMap unused ioDomainMap
  ?!@typeTableFormules unused tableFormules
  !@typeFormule formule
:
  @luint varIndex ;
  @luint bitSize ;
  @luint lowBound ;
  @luint highBound ;
  @location errorLocation ;
  <parse_scalar_argument>!?tableVariables ?varIndex ?bitSize ?lowBound ?highBound ?errorLocation ;
  verifierDimensionUn !bitSize !errorLocation ;
  formule := [@typeFormuleVar new !varIndex !lowBound !highBound] ;
end rule ;

#-------------------------------------------------------------------*

rule <facteur_formule>
  ?@typeTableVariablesBool tableVariables
  ?@uint unused inBDDslot
  ?!@typeDomainMap unused ioDomainMap
  ?!@typeTableFormules tableFormules
  !@typeFormule formule
:
  $#$ ;
  @lstring nom ;
  @luint numero ;
  $id$ ? nom ;
  @typeFormalArgumentsList listeArgsFormelsBool ;
  [tableFormules searchKeyGetIndex !nom ?numero ?listeArgsFormelsBool ?*] ;
  $[$ ;
  @typeActualArgumentsList listeArgsEffectifsBool [emptyList] ;
  repeat
    @typeVariableDescriptor varDescriptor ;
    @location errorLocation ;
    <parse_argument> !?tableVariables ?varDescriptor ?errorLocation ;
    cast varDescriptor :
    when >= @typeDirectVariable dv do # §(@luint varIndex @luint bitSize @luint lowBound @luint highBound) ->
      listeArgsEffectifsBool += ![dv mIndex] ![dv mBitSize] ![dv mLowBound] ![dv mHighBound] !errorLocation ;
    when >= @typeRecordVariable rv do # §  (@typeTableVariablesBool inRecordMap) ->
      buildActualArgsList ![rv mMap] !?listeArgsEffectifsBool !errorLocation ;
    else
      error errorLocation : "a variable was expected here ; I found " .
                   [varDescriptor variableDescriptorErrorMessage] ;
    end cast ;
  while
    $,$ ;
  end repeat ;
  $]$ ;
#--- Verifier le bon nombre d'arguments
  @location positionFinListe := here ;
  verifierNombreArgumentsBool !listeArgsFormelsBool !listeArgsEffectifsBool !positionFinListe ;
  @extern_bdd unusedBDD [empty] ;
  @lbool unusedBool := [@lbool new !false !here] ;
  formule := [@typeFormuleFor new !numero !listeArgsEffectifsBool !unusedBDD !unusedBool] ;
end rule ;

#-------------------------------------------------------------------*

rule <parse_argument>
  ?!@typeTableVariablesBool ioVarMap
  !@typeVariableDescriptor outVarDescriptor
  !@location outErrorLocation
:
  @lstring varName ;
  $id$ ? varName ;
  outErrorLocation := [varName location] ;
  [ioVarMap searchKey !varName ?outVarDescriptor] ;
  repeat
  while
    $.$ ;
#    @location errorLoc := here ;
#    extract outVarDescriptor->@typeRecordVariable (?fieldMap)
#          error errorLoc : variableDescriptorErrorMessage ;
    @typeRecordVariable rv := (cast outVarDescriptor if >= @typeRecordVariable else error here) ;
    @typeTableVariablesBool fieldMap := [rv mMap] ;
    @lstring fieldName ;
    $id$ ?fieldName ;
    outErrorLocation := [fieldName location] ;
    [fieldMap searchKey !fieldName ?outVarDescriptor] ;
  end repeat ;
end rule ;

#-------------------------------------------------------------------*

rule <parse_scalar_argument>
  ?!@typeTableVariablesBool ioVarMap
  !@luint outVarIndex
  !@luint outBitSize
  !@luint outLowBound
  !@luint outHighBound
  !@location outErrorLocation
:
  @typeVariableDescriptor v ;
  <parse_argument> !?ioVarMap ?v ?outErrorLocation ;
#  § extract v->@typeDirectVariable (?outVarIndex ?outBitSize ?outLowBound ?outHighBound)
#          error outErrorLocation : variableDescriptorErrorMessage ;
  @typeDirectVariable variable := (cast v if == @typeDirectVariable else error outErrorLocation) ;
  outVarIndex := [variable mIndex] ;
  outBitSize := [variable mBitSize] ;
  outLowBound := [variable mLowBound] ;
  outHighBound := [variable mHighBound] ;
end rule ;

#-------------------------------------------------------------------*

end syntax ;
