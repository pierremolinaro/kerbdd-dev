semantics semantiqueBDD :extern @bdd :  class C_galgas_bdd in "galgas/C_galgas_bdd.h" ; # C++ class name  constructor empty ; # Accepts assignment from emptyend extern ;#------------------------------------------------------------------*#                   Domains                                        *#------------------------------------------------------------------*abstract class @typeDomain  message messageDomainType "any domain" ;end class ;#------------------------------------------------------------------*class @typeDirectDomain extends @typeDomain  @luint mLowBound ;  @luint mHighBound ;  @luint mBitsCount ;  message messageDomainType "an interval domain" ;end class ;#------------------------------------------------------------------*#                   Domain map                                     *#------------------------------------------------------------------*map @typeDomainMap  insert insertKey error message "the '%' domain has been already declared" ;  search searchKey error message "the '%' domain is not declared" ;  key @lstring ;  @typeDomain mDomain ;end map ;#------------------------------------------------------------------*class @typeRecordDomain extends @typeDomain  @typeDomainMap mRecordMap ;  message messageDomainType "a record domain" ;end class ;#------------------------------------------------------------------*#                   Liste d'arguments booleens                     *#------------------------------------------------------------------*list @typeFormalArgumentsList  @luint mVariableIndex ;  @luint mVariableBitSize ;  @luint mLowBound ;  @luint mHighBound ;end list ;#------------------------------------------------------------------*#                   Liste d'arguments booleens                     *#------------------------------------------------------------------*list @typeActualArgumentsList  @luint mVariableIndex ;  @luint mVariableBitSize ;  @luint mLowBound ;  @luint mHighBound ;  @location mErrorLocation ;end list ;#------------------------------------------------------------------*#                   Table des variables boolennes                  *#------------------------------------------------------------------*abstract class @typeVariableDescriptor  include header ;  message variableDescriptorErrorMessage "any variable" ;end class ;#------------------------------------------------------------------*class @typeDirectVariable extends @typeVariableDescriptor  @luint mIndex ;  @luint mBitSize ;  @luint mLowBound ;  @luint mHighBound ;  message variableDescriptorErrorMessage "a direct domain variable" ;end class ;#------------------------------------------------------------------*#                   Table des variables boolennes                  *#------------------------------------------------------------------*map @typeTableVariablesBool  class cTableVariablesBDD  in "cTableVariablesBDD.h", "cTableVariablesBDD.hh" ;  insert insertKey error message "the '%' variable has been already declared" ;  search searchKey error message "the '%' variable is not declared" ;  key @lstring ;  @typeVariableDescriptor mVariableDescriptor ;end map ;#------------------------------------------------------------------*class @typeRecordVariable extends @typeVariableDescriptor  @typeTableVariablesBool mMap ;  message variableDescriptorErrorMessage "a record domain variable" ;end class ;#------------------------------------------------------------------*#                   Table des formules                             *#------------------------------------------------------------------*map @typeTableFormules  insert insertKey error message "La formule '%' a deja ete declaree" ;  search searchKey error message "La formule '%' n'a pas ete declaree" ;  key @lstring ;  @typeFormalArgumentsList aListeArgsFormelsBool ;  @bdd aBDD ;end map ;#------------------------------------------------------------------*#                       Type de formule                            *#------------------------------------------------------------------*abstract class @typeFormule include header  ;end class ;class @typeFormuleTrue extends @typeFormuleend class ;class @typeFormuleFalse extends @typeFormuleend class ;class @typeFormuleVar extends @typeFormule  @luint aNumeroVariable ;  @luint mLowBound ;  @luint mHighBound ;end class ;class @typeFormuleFor extends @typeFormule  @luint aNumeroFormule ;  @typeActualArgumentsList aListeArgsBool ;  @bdd aFormuleTraduite ;  @lbool aEstFormuleCourante ;end class ;class @typeFormuleNon extends @typeFormule  @typeFormule aOperande ;end class ;class @typeFormuleEt  extends @typeFormule  @typeFormule aOperande1 ;  @typeFormule aOperande2 ;end class ;class @typeFormuleIte  extends @typeFormule  @typeFormule aOperande1 ;  @typeFormule aOperande2 ;  @typeFormule aOperande3 ;end class ;class @typeFormuleOu  extends @typeFormule  @typeFormule aOperande1 ;  @typeFormule aOperande2 ;end class ;
class @typeFormuleImplique  extends @typeFormule  @typeFormule aOperande1 ;  @typeFormule aOperande2 ;end class ;class @typeComparaisonFormules extends @typeFormule  @luint aComparaison ;  @typeFormule aOperande1 ;  @typeFormule aOperande2 ;end class ;class @typeFormuleQuelqueSoit extends @typeFormule  @typeFormalArgumentsList aListeArgsBooleens ;  @typeFormule aOperande ;  @bdd aContraintes ;end class ;class @typeFormuleExist extends @typeFormule  @typeFormalArgumentsList aListeArgsBooleens ;  @typeFormule aOperande ;  @bdd aContraintes ;end class ;class @typeFormuleComparaisonValeur extends @typeFormule  @luint aIndiceBDD ;  @luint aDimension ;  @luint mLowBound ;  @luint mHighBound ;  @luint aComparaison ;  @luint aValeur ;end class ;class @typeFormuleComparaisonVariable extends @typeFormule  @luint aIndiceBDDgauche ;  @luint aDimension ;  @luint mLeftLowBound ;  @luint mLeftHighBound ;  @luint aComparaison ;  @luint aIndiceBDDdroite ;  @luint mRightLowBound ;  @luint mRightHighBound ;end class ;#------------------------------------------------------------------*#                      Type de calcul                              *#------------------------------------------------------------------*abstract class @typeCalcul include header ;end class ;class @typeCalculSimple extends @typeCalcul  @luint aNumeroFormule ;  @typeFormule aFormule ;  @lstring aNomFormule ;  @typeTableVariablesBool aTableVariablesBool ;  @luint aAfficher ;end class ;class @typeDimensionnerCache extends @typeCalcul  @luint aDimensionCache ;end class ;class @typeDimensionnerTable extends @typeCalcul  @luint aDimensionTable ;end class ;class @typeAfficherBilan extends @typeCalculend class ;class @typeCalculIteratif extends @typeCalcul  @luint aNumeroFormule ;  @typeFormule aFormule ;  @lstring aNomFormule ;  @typeTableVariablesBool aTableVariablesBool ;  @lbool aSigne ;  @luint aAfficher ;end class ;#------------------------------------------------------------------*#                   Liste de calculs                               *#------------------------------------------------------------------*list @typeListeCalculs  @typeCalcul aCalcul ;end list ;#----------------------------------------------------------------------*#                                                                      *#   ITERATEUR DE VERIFICATION DU NOMBRE CORRECT D'ARGUMENTS            *#                                                                      *#----------------------------------------------------------------------*routine verifierNombreArgumentsBool ??@typeFormalArgumentsList t1                                    ??@typeActualArgumentsList t2                                    ??@location positionFinListe :  if [t1 length] < [t2 length] then    error positionFinListe : "too much actual arguments" ;  elsif [t1 length] > [t2 length] then    error positionFinListe : "one or more actual arguments missing" ;  end if ;  foreach list t1 :: t2 ->  (??@luint attNum1 ??@luint attDim1 ??@luint lowBound1 ??@luint highBound1) ::  (??@luint attNum2 ??@luint attDim2 ??@luint lowBound2 ??@luint highBound2 ??@location errorLocation) :    if [attDim1 value] == [attDim2 value] then      if [lowBound1 value] == [lowBound2 value] then        if [highBound1 value] == [highBound2 value] then        else          error errorLocation : "the actual high bound is different the formal one" ;        end if ;      else        error errorLocation : "the actual low bound is different the formal one" ;      end if ;    else      error errorLocation : "the actual dimension is different from the formal one" ;    end if ;  end foreach ;end routine ;#------------------------------------------------------------------*end semantics ;