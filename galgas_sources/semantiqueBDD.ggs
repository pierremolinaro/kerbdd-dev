semantics semantiqueBDD :extern @extern_bdd class C_galgas_bdd in "C_galgas_bdd.h" {  constructor empty ; # Accepts assignment from empty}#------------------------------------------------------------------*#                   Domains                                        *#------------------------------------------------------------------*abstract class @typeDomain {  message messageDomainType "any domain" ;}#------------------------------------------------------------------*class @typeDirectDomain extends @typeDomain {  @luint mLowBound ;  @luint mHighBound ;  @luint mBitsCount ;  message messageDomainType "an interval domain" ;}#------------------------------------------------------------------*#                   Domain map                                     *#------------------------------------------------------------------*map @typeDomainMap {  @typeDomain mDomain ;  insert insertKey error message "the '%K' domain has been already declared" ;  search searchKey error message "the '%K' domain is not declared" ;}#------------------------------------------------------------------*class @typeRecordDomain extends @typeDomain {  @typeDomainMap mRecordMap ;  message messageDomainType "a record domain" ;}#------------------------------------------------------------------*#                   Liste d'arguments booleens                     *#------------------------------------------------------------------*list @typeFormalArgumentsList {  @luint mVariableIndex ;  @luint mVariableBitSize ;  @luint mLowBound ;  @luint mHighBound ;}#------------------------------------------------------------------*#                   Liste d'arguments booleens                     *#------------------------------------------------------------------*list @typeActualArgumentsList {  @luint mVariableIndex ;  @luint mVariableBitSize ;  @luint mLowBound ;  @luint mHighBound ;  @location mErrorLocation ;}#------------------------------------------------------------------*#                   Table des variables boolennes                  *#------------------------------------------------------------------*abstract class @typeVariableDescriptor {  message variableDescriptorErrorMessage "any variable" ;  message "any variable" ;}#------------------------------------------------------------------*class @typeDirectVariable extends @typeVariableDescriptor {  @luint mIndex ;  @luint mBitSize ;  @luint mLowBound ;  @luint mHighBound ;  message variableDescriptorErrorMessage "a direct domain variable" ;  message "a direct domain variable" ;}#------------------------------------------------------------------*#                   Table des variables boolennes                  *#------------------------------------------------------------------*map @typeTableVariablesBool {  @typeVariableDescriptor mVariableDescriptor ;  insert insertKey error message "the '%K' variable has been already declared" ;  search searchKey error message "the '%K' variable is not declared" ;}#------------------------------------------------------------------*class @typeRecordVariable extends @typeVariableDescriptor {  @typeTableVariablesBool mMap ;  message variableDescriptorErrorMessage "a record domain variable" ;  message "a record domain variable" ;}#------------------------------------------------------------------*#                   Table des formules                             *#------------------------------------------------------------------*map @typeTableFormules {  @typeFormalArgumentsList aListeArgsFormelsBool ;  @extern_bdd aBDD ;  insert insertKey, insertKeyGetIndex error message "the '#%K' formula is already defined" ;  search searchKey, searchKeyGetIndex error message "the '#%K' formula is not defined" ;}#------------------------------------------------------------------*#                       Type de formule                            *#------------------------------------------------------------------*abstract class @typeFormule {}class @typeFormuleTrue extends @typeFormule {}class @typeFormuleFalse extends @typeFormule {}class @typeFormuleVar extends @typeFormule {  @luint mNumeroVariable ;  @luint mLowBound ;  @luint mHighBound ;}class @typeFormuleFor extends @typeFormule {  @luint mNumeroFormule ;  @typeActualArgumentsList mListeArgsBool ;  @extern_bdd mFormuleTraduite ;  @lbool mEstFormuleCourante ;}class @typeFormuleNon extends @typeFormule {  @typeFormule mOperand ;}class @typeFormuleEt  extends @typeFormule {  @typeFormule mOperand1 ;  @typeFormule mOperand2 ;}class @typeFormuleIte  extends @typeFormule {  @typeFormule mOperand1 ;  @typeFormule mOperand2 ;  @typeFormule mOperand3 ;}class @typeFormuleOu  extends @typeFormule {  @typeFormule mOperand1 ;  @typeFormule mOperand2 ;}class @typeFormuleImplique  extends @typeFormule {  @typeFormule mOperand1 ;  @typeFormule mOperand2 ;}class @typeComparaisonFormules extends @typeFormule {  @luint mComparaison ;  @typeFormule mOperand1 ;  @typeFormule mOperand2 ;}class @typeFormuleExist extends @typeFormule {  @typeFormalArgumentsList mListeArgsBooleens ;  @typeFormule mOperand ;  @extern_bdd mContraints ;}class @typeFormuleComparaisonValeur extends @typeFormule {  @luint mIndiceBDD ;  @luint mDimension ;  @luint mLowBound ;  @luint mHighBound ;  @luint mComparaison ;  @luint mValeur ;}class @typeFormuleComparaisonVariable extends @typeFormule {  @luint mIndiceBDDgauche ;  @luint mDimension ;  @luint mLeftLowBound ;  @luint mLeftHighBound ;  @luint mComparaison ;  @luint mIndiceBDDdroite ;  @luint mRightLowBound ;  @luint mRightHighBound ;}#------------------------------------------------------------------*#                      Type de calcul                              *#------------------------------------------------------------------*abstract class @typeCalcul {}class @typeCalculSimple extends @typeCalcul {  @luint mNumeroFormule ;  @typeFormule mFormule ;  @lstring mNomFormule ;  @typeTableVariablesBool mTableVariablesBool ;  @luint mAfficher ;}class @typeUse_AND extends @typeCalcul {}class @typeUse_ITE extends @typeCalcul {}class @typeUse_AND_ITE extends @typeCalcul {}class @typeDimensionnerANDCache extends @typeCalcul {  @luint mDimensionCache ;}class @typeDimensionnerITECache extends @typeCalcul {  @luint mDimensionCache ;}class @typeDimensionnerTable extends @typeCalcul {  @luint mDimensionTable ;}class @typeAfficherBilan extends @typeCalcul {}class @typeCalculIteratif extends @typeCalcul {  @luint mNumeroFormule ;  @typeFormule mFormule ;  @lstring mNomFormule ;  @typeTableVariablesBool mTableVariablesBool ;  @lbool mSigne ;  @luint mAfficher ;}#------------------------------------------------------------------*#                   Liste de calculs                               *#------------------------------------------------------------------*list @typeListeCalculs {  @typeCalcul mCalcul ;}#----------------------------------------------------------------------*#                                                                      *#   ITERATEUR DE VERIFICATION DU NOMBRE CORRECT D'ARGUMENTS            *#                                                                      *#----------------------------------------------------------------------*routine verifierNombreArgumentsBool ??@typeFormalArgumentsList t1                                    ??@typeActualArgumentsList t2                                    ??@location positionFinListe :  if [t1 length] < [t2 length] then    error positionFinListe : "too much actual arguments" ;  elsif [t1 length] > [t2 length] then    error positionFinListe : "one or more actual arguments missing" ;  end if ;  foreach t1 (@luint attNum1 @luint attDim1 @luint lowBound1 @luint highBound1),          t2 (@luint attNum2 @luint attDim2 @luint lowBound2 @luint highBound2 @location errorLocation) :    if [attDim1 uint] == [attDim2 uint] then      if [lowBound1 uint] == [lowBound2 uint] then        if [highBound1 uint] == [highBound2 uint] then        else          error errorLocation : "the actual high bound is different the formal one" ;        end if ;      else        error errorLocation : "the actual low bound is different the formal one" ;      end if ;    else      error errorLocation : "the actual dimension is different from the formal one" ;    end if ;  end foreach ;end routine ;#------------------------------------------------------------------*routine buildFormalArgsList  ??@typeVariableDescriptor inVariableDescriptor  ?!@typeFormalArgumentsList ioFormalArgsList  ??@location inErrorLocation:  cast inVariableDescriptor :  when >= @typeDirectVariable v do # ¤(@luint inIndexVar @luint inBitSize @luint inLowBound @luint inHighBound) ->    ioFormalArgsList += ![v mIndex] ![v mBitSize] ![v mLowBound] ![v mHighBound] ;  when >= @typeRecordVariable r do # ¤ (@typeTableVariablesBool inLocalRecordMap) ->    foreach [r mMap] (* @typeVariableDescriptor inLocalVariableDescriptor) :      buildFormalArgsList !inLocalVariableDescriptor !?ioFormalArgsList !inErrorLocation ;    end foreach ;  default error inErrorLocation  end cast ;end routine ;#------------------------------------------------------------------*routine buildActualArgsList  ??@typeTableVariablesBool inDomainMap  ?!@typeActualArgumentsList ioActualArgsList  ??@location inErrorLocation:  foreach inDomainMap (* @typeVariableDescriptor inLocalVariableDescriptor) :    cast inLocalVariableDescriptor :    when >= @typeDirectVariable v do
      ioActualArgsList += ![v mIndex] ![v mBitSize] ![v mLowBound] ![v mHighBound] !inErrorLocation ;    when >= @typeRecordVariable r do
      buildActualArgsList ![r mMap] !?ioActualArgsList !inErrorLocation ;#  ¤  when @typeDirectVariable (@luint inIndexVar @luint inBitSize @luint inLowBound @luint inHighBound) ->#      ioActualArgsList += !inIndexVar !inBitSize !inLowBound !inHighBound !inErrorLocation ;#    when @typeRecordVariable (@typeTableVariablesBool inLocalRecordMap) ->#      buildActualArgsList !inLocalRecordMap !?ioActualArgsList !inErrorLocation ;    default error inErrorLocation
    end cast ;  end foreach ;end routine ;#-------------------------------------------------------------------*action getHighBound ??@luint inDimension !@luint outHighBound ;action verifyBoundsAndComputeDimension ??@luint lowBound ??@luint highBound !@luint dimension ;action verifierDimensionValeurCorrecte ?@luint dim ?@luint valeur ;action verifierMemesDimensions ?@luint dim ?@luint dimensionDroite ;action verifierDimensionUn ?@luint inBitSize ?@location inErrorLocation ;#-------------------------------------------------------------------*

action generate_code
  ??@typeTableFormules inTableFormules  ??@typeListeCalculs inListeCalculs  ??@typeDomainMap inDomainMap
;

#-------------------------------------------------------------------*

class @A {message "a @A instance" ;}
class @B extends @A {message "a @B instance" ;}
class @C extends @B {message "a @C instance" ;}
class @D extends @C {message "a @D instance" ;}
end semantics ;