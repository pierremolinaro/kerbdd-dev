semantics semantiqueBDD :extern @bdd :  class C_galgas_bdd in "galgas/C_galgas_bdd.h" ; # C++ class name  constructor empty ; # Accepts assignment from emptyend extern ;#------------------------------------------------------------------*#                   Domains                                        *#------------------------------------------------------------------*abstract class @typeDomain {  message messageDomainType "any domain" ;}#------------------------------------------------------------------*class @typeDirectDomain extends @typeDomain {  @luint mLowBound ;  @luint mHighBound ;  @luint mBitsCount ;  message messageDomainType "an interval domain" ;}#------------------------------------------------------------------*#                   Domain map                                     *#------------------------------------------------------------------*map @typeDomainMap {  insert insertKey error message "the '%' domain has been already declared" ;  search searchKey error message "the '%' domain is not declared" ;  @typeDomain mDomain ;}#------------------------------------------------------------------*class @typeRecordDomain extends @typeDomain {  @typeDomainMap mRecordMap ;  message messageDomainType "a record domain" ;}#------------------------------------------------------------------*#                   Liste d'arguments booleens                     *#------------------------------------------------------------------*list @typeFormalArgumentsList {  @luint mVariableIndex ;  @luint mVariableBitSize ;  @luint mLowBound ;  @luint mHighBound ;}#------------------------------------------------------------------*#                   Liste d'arguments booleens                     *#------------------------------------------------------------------*list @typeActualArgumentsList {  @luint mVariableIndex ;  @luint mVariableBitSize ;  @luint mLowBound ;  @luint mHighBound ;  @location mErrorLocation ;}#------------------------------------------------------------------*#                   Table des variables boolennes                  *#------------------------------------------------------------------*abstract class @typeVariableDescriptor {  include header ;  message variableDescriptorErrorMessage "any variable" ;}#------------------------------------------------------------------*class @typeDirectVariable extends @typeVariableDescriptor {  @luint mIndex ;  @luint mBitSize ;  @luint mLowBound ;  @luint mHighBound ;  message variableDescriptorErrorMessage "a direct domain variable" ;}#------------------------------------------------------------------*#                   Table des variables boolennes                  *#------------------------------------------------------------------*map @typeTableVariablesBool  class cTableVariablesBDD  in "cTableVariablesBDD.h", "cTableVariablesBDD.hh" ;  insert insertKey error message "the '%' variable has been already declared" ;  search searchKey error message "the '%' variable is not declared" ;  @typeVariableDescriptor mVariableDescriptor ;}#------------------------------------------------------------------*class @typeRecordVariable extends @typeVariableDescriptor {  @typeTableVariablesBool mMap ;  message variableDescriptorErrorMessage "a record domain variable" ;}#------------------------------------------------------------------*#                   Table des formules                             *#------------------------------------------------------------------*map @typeTableFormules {  insert insertKey error message "the '#" . * . "' formula is already defined" ;  search searchKey error message "the '#" . * . "' formula is not defined" ;  @typeFormalArgumentsList aListeArgsFormelsBool ;  @bdd aBDD ;}#------------------------------------------------------------------*#                       Type de formule                            *#------------------------------------------------------------------*abstract class @typeFormule { include header  ;}class @typeFormuleTrue extends @typeFormule {}class @typeFormuleFalse extends @typeFormule {}class @typeFormuleVar extends @typeFormule {  @luint aNumeroVariable ;  @luint mLowBound ;  @luint mHighBound ;}class @typeFormuleFor extends @typeFormule {  @luint aNumeroFormule ;  @typeActualArgumentsList aListeArgsBool ;  @bdd aFormuleTraduite ;  @lbool aEstFormuleCourante ;}class @typeFormuleNon extends @typeFormule {  @typeFormule aOperande ;}class @typeFormuleEt  extends @typeFormule {  @typeFormule aOperande1 ;  @typeFormule aOperande2 ;}class @typeFormuleIte  extends @typeFormule {  @typeFormule aOperande1 ;  @typeFormule aOperande2 ;  @typeFormule aOperande3 ;}class @typeFormuleOu  extends @typeFormule {  @typeFormule aOperande1 ;  @typeFormule aOperande2 ;}class @typeFormuleImplique  extends @typeFormule {  @typeFormule aOperande1 ;  @typeFormule aOperande2 ;}class @typeComparaisonFormules extends @typeFormule {  @luint aComparaison ;  @typeFormule aOperande1 ;  @typeFormule aOperande2 ;}class @typeFormuleExist extends @typeFormule {  @typeFormalArgumentsList aListeArgsBooleens ;  @typeFormule aOperande ;  @bdd aContraintes ;}class @typeFormuleComparaisonValeur extends @typeFormule {  @luint aIndiceBDD ;  @luint aDimension ;  @luint mLowBound ;  @luint mHighBound ;  @luint aComparaison ;  @luint aValeur ;}class @typeFormuleComparaisonVariable extends @typeFormule {  @luint aIndiceBDDgauche ;  @luint aDimension ;  @luint mLeftLowBound ;  @luint mLeftHighBound ;  @luint aComparaison ;  @luint aIndiceBDDdroite ;  @luint mRightLowBound ;  @luint mRightHighBound ;}#------------------------------------------------------------------*#                      Type de calcul                              *#------------------------------------------------------------------*abstract class @typeCalcul { include header ;}class @typeCalculSimple extends @typeCalcul {  @luint aNumeroFormule ;  @typeFormule aFormule ;  @lstring aNomFormule ;  @typeTableVariablesBool aTableVariablesBool ;  @luint aAfficher ;}class @typeUse_AND extends @typeCalcul {}class @typeUse_ITE extends @typeCalcul {}class @typeUse_AND_ITE extends @typeCalcul {}class @typeDimensionnerANDCache extends @typeCalcul {  @luint aDimensionCache ;}class @typeDimensionnerITECache extends @typeCalcul {  @luint aDimensionCache ;}class @typeDimensionnerTable extends @typeCalcul {  @luint aDimensionTable ;}class @typeAfficherBilan extends @typeCalcul {}class @typeCalculIteratif extends @typeCalcul {  @luint aNumeroFormule ;  @typeFormule aFormule ;  @lstring aNomFormule ;  @typeTableVariablesBool aTableVariablesBool ;  @lbool aSigne ;  @luint aAfficher ;}#------------------------------------------------------------------*#                   Liste de calculs                               *#------------------------------------------------------------------*list @typeListeCalculs {  @typeCalcul aCalcul ;}#----------------------------------------------------------------------*#                                                                      *#   ITERATEUR DE VERIFICATION DU NOMBRE CORRECT D'ARGUMENTS            *#                                                                      *#----------------------------------------------------------------------*routine verifierNombreArgumentsBool ??@typeFormalArgumentsList t1                                    ??@typeActualArgumentsList t2                                    ??@location positionFinListe :  if [t1 length] < [t2 length] then    error positionFinListe : "too much actual arguments" ;  elsif [t1 length] > [t2 length] then    error positionFinListe : "one or more actual arguments missing" ;  end if ;  foreach t1 (??@luint attNum1 ??@luint attDim1 ??@luint lowBound1 ??@luint highBound1),          t2 (??@luint attNum2 ??@luint attDim2 ??@luint lowBound2 ??@luint highBound2 ??@location errorLocation) :    if [attDim1 value] == [attDim2 value] then      if [lowBound1 value] == [lowBound2 value] then        if [highBound1 value] == [highBound2 value] then        else          error errorLocation : "the actual high bound is different the formal one" ;        end if ;      else        error errorLocation : "the actual low bound is different the formal one" ;      end if ;    else      error errorLocation : "the actual dimension is different from the formal one" ;    end if ;  end foreach ;end routine ;#------------------------------------------------------------------*end semantics ;