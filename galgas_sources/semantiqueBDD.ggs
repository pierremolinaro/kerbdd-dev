semantics semantiqueBDD :

extern @extern_bdd {
  constructor empty ; # Accepts assignment from empty
}

#------------------------------------------------------------------*
#                   Domains                                        *
#------------------------------------------------------------------*

abstract class @typeDomain feature generatedInSeparateFile {
  message messageDomainType "any domain" ;
}

#------------------------------------------------------------------*

class @typeDirectDomain extends @typeDomain {
  @luint mLowBound ;
  @luint mHighBound ;
  @luint mBitsCount ;
  message messageDomainType "an interval domain" ;
}

#------------------------------------------------------------------*
#                   Domain map                                     *
#------------------------------------------------------------------*

map @typeDomainMap {
  @typeDomain mDomain ;
  insert insertKey error message "the '%K' domain has been already declared" ;
  search searchKey error message "the '%K' domain is not declared" ;
}

#------------------------------------------------------------------*

class @typeRecordDomain extends @typeDomain {
  @typeDomainMap mRecordMap ;
  message messageDomainType "a record domain" ;
}

#------------------------------------------------------------------*
#                   Liste d'arguments booleens                     *
#------------------------------------------------------------------*

list @typeFormalArgumentsList {
  @luint mVariableIndex ;
  @luint mVariableBitSize ;
  @luint mLowBound ;
  @luint mHighBound ;
}

#------------------------------------------------------------------*
#                   Liste d'arguments booleens                     *
#------------------------------------------------------------------*

list @typeActualArgumentsList {
  @luint mVariableIndex ;
  @luint mVariableBitSize ;
  @luint mLowBound ;
  @luint mHighBound ;
  @location mErrorLocation ;
}

#------------------------------------------------------------------*
#                   Table des variables boolennes                  *
#------------------------------------------------------------------*

abstract class @typeVariableDescriptor feature generatedInSeparateFile {
  message variableDescriptorErrorMessage "any variable" ;
  message "any variable" ;
}

#------------------------------------------------------------------*

class @typeDirectVariable extends @typeVariableDescriptor {
  @luint mIndex ;
  @luint mBitSize ;
  @luint mLowBound ;
  @luint mHighBound ;
  message variableDescriptorErrorMessage "a direct domain variable" ;
  message "a direct domain variable" ;
}

#------------------------------------------------------------------*
#                   Table des variables boolennes                  *
#------------------------------------------------------------------*

map @typeTableVariablesBool {
  @typeVariableDescriptor mVariableDescriptor ;
  insert insertKey error message "the '%K' variable has been already declared" ;
  search searchKey error message "the '%K' variable is not declared" ;
}

#------------------------------------------------------------------*

class @typeRecordVariable extends @typeVariableDescriptor {
  @typeTableVariablesBool mMap ;
  message variableDescriptorErrorMessage "a record domain variable" ;
  message "a record domain variable" ;
}

#------------------------------------------------------------------*
#                   Table des formules                             *
#------------------------------------------------------------------*

map @typeTableFormules {
  @typeFormalArgumentsList aListeArgsFormelsBool ;
  @extern_bdd aBDD ;
  insert insertKey, insertKeyGetIndex error message "the '#%K' formula is already defined" ;
  search searchKey, searchKeyGetIndex error message "the '#%K' formula is not defined" ;
}

#------------------------------------------------------------------*
#                       Type de formule                            *
#------------------------------------------------------------------*

abstract class @typeFormule feature generatedInSeparateFile {
}

class @typeFormuleTrue extends @typeFormule {
}

class @typeFormuleFalse extends @typeFormule {
}

class @typeFormuleVar extends @typeFormule {
  @luint mNumeroVariable ;
  @luint mLowBound ;
  @luint mHighBound ;
}

class @typeFormuleFor extends @typeFormule {
  @luint mNumeroFormule ;
  @typeActualArgumentsList mListeArgsBool ;
  @extern_bdd mFormuleTraduite ;
  @lbool mEstFormuleCourante ;
}

class @typeFormuleNon extends @typeFormule {
  @typeFormule mOperand ;
}

class @typeFormuleEt  extends @typeFormule {
  @typeFormule mOperand1 ;
  @typeFormule mOperand2 ;
}

class @typeFormuleIte  extends @typeFormule {
  @typeFormule mOperand1 ;
  @typeFormule mOperand2 ;
  @typeFormule mOperand3 ;
}

class @typeFormuleOu  extends @typeFormule {
  @typeFormule mOperand1 ;
  @typeFormule mOperand2 ;
}
class @typeFormuleImplique  extends @typeFormule {
  @typeFormule mOperand1 ;
  @typeFormule mOperand2 ;
}

class @typeComparaisonFormules extends @typeFormule {
  @luint mComparaison ;
  @typeFormule mOperand1 ;
  @typeFormule mOperand2 ;
}

class @typeFormuleExist extends @typeFormule {
  @typeFormalArgumentsList mListeArgsBooleens ;
  @typeFormule mOperand ;
  @extern_bdd mContraints ;
}

class @typeFormuleComparaisonValeur extends @typeFormule {
  @luint mIndiceBDD ;
  @luint mDimension ;
  @luint mLowBound ;
  @luint mHighBound ;
  @luint mComparaison ;
  @luint mValeur ;
}

class @typeFormuleComparaisonVariable extends @typeFormule {
  @luint mIndiceBDDgauche ;
  @luint mDimension ;
  @luint mLeftLowBound ;
  @luint mLeftHighBound ;
  @luint mComparaison ;
  @luint mIndiceBDDdroite ;
  @luint mRightLowBound ;
  @luint mRightHighBound ;
}

#------------------------------------------------------------------*
#                      Type de calcul                              *
#------------------------------------------------------------------*

abstract class @typeCalcul feature generatedInSeparateFile {
}

class @typeCalculSimple extends @typeCalcul {
  @luint mNumeroFormule ;
  @typeFormule mFormule ;
  @lstring mNomFormule ;
  @typeTableVariablesBool mTableVariablesBool ;
  @luint mAfficher ;
}

class @typeUse_AND extends @typeCalcul {
}

class @typeUse_ITE extends @typeCalcul {
}

class @typeUse_AND_ITE extends @typeCalcul {
}

class @typeDimensionnerANDCache extends @typeCalcul {
  @luint mDimensionCache ;
}

class @typeDimensionnerITECache extends @typeCalcul {
  @luint mDimensionCache ;
}

class @typeDimensionnerTable extends @typeCalcul {
  @luint mDimensionTable ;
}

class @typeAfficherBilan extends @typeCalcul {
}

class @typeCalculIteratif extends @typeCalcul {
  @luint mNumeroFormule ;
  @typeFormule mFormule ;
  @lstring mNomFormule ;
  @typeTableVariablesBool mTableVariablesBool ;
  @lbool mSigne ;
  @luint mAfficher ;
}

#------------------------------------------------------------------*
#                   Liste de calculs                               *
#------------------------------------------------------------------*

list @typeListeCalculs {
  @typeCalcul mCalcul ;
}

#----------------------------------------------------------------------*
#                                                                      *
#   ITERATEUR DE VERIFICATION DU NOMBRE CORRECT D'ARGUMENTS            *
#                                                                      *
#----------------------------------------------------------------------*

routine verifierNombreArgumentsBool ??@typeFormalArgumentsList t1
                                    ??@typeActualArgumentsList t2
                                    ??@location positionFinListe :
  if [t1 length] < [t2 length] then
    error positionFinListe : "too much actual arguments" ;
  elsif [t1 length] > [t2 length] then
    error positionFinListe : "one or more actual arguments missing" ;
  end if ;
  foreach t1, t2 prefixedby t2_ do
    if [mVariableBitSize uint] == [t2_mVariableBitSize uint] then
      if [mLowBound uint] == [t2_mLowBound uint] then
        if [mHighBound uint] == [t2_mHighBound uint] then
        else
          error t2_mErrorLocation : "the actual high bound is different the formal one" ;
        end if ;
      else
        error t2_mErrorLocation : "the actual low bound is different the formal one" ;
      end if ;
    else
      error t2_mErrorLocation : "the actual dimension is different from the formal one" ;
    end if ;
  end foreach ;
end routine ;

#------------------------------------------------------------------*

routine buildFormalArgsList
  ??@typeVariableDescriptor inVariableDescriptor
  ?!@typeFormalArgumentsList ioFormalArgsList
  ??@location inErrorLocation
:
  cast inVariableDescriptor :
  when >= @typeDirectVariable v do # ¤(@luint inIndexVar @luint inBitSize @luint inLowBound @luint inHighBound) ->
    ioFormalArgsList += ![v mIndex] ![v mBitSize] ![v mLowBound] ![v mHighBound] ;
  when >= @typeRecordVariable r do # ¤ (@typeTableVariablesBool inLocalRecordMap) ->
    foreach [r mMap] do
      buildFormalArgsList !mVariableDescriptor !?ioFormalArgsList !inErrorLocation ;
    end foreach ;
  default error inErrorLocation
  end cast ;
end routine ;

#------------------------------------------------------------------*

routine buildActualArgsList
  ??@typeTableVariablesBool inDomainMap
  ?!@typeActualArgumentsList ioActualArgsList
  ??@location inErrorLocation
:
  foreach inDomainMap do
    cast mVariableDescriptor :
    when >= @typeDirectVariable v do
      ioActualArgsList += ![v mIndex] ![v mBitSize] ![v mLowBound] ![v mHighBound] !inErrorLocation ;
    when >= @typeRecordVariable r do
      buildActualArgsList ![r mMap] !?ioActualArgsList !inErrorLocation ;
    default error inErrorLocation
    end cast ;
  end foreach ;
end routine ;

#-------------------------------------------------------------------*

extern routine getHighBound ??@luint inDimension !@luint outHighBound ;

extern routine verifyBoundsAndComputeDimension ??@luint lowBound ??@luint highBound !@luint dimension ;

extern routine verifierDimensionValeurCorrecte ?@luint dim ?@luint valeur ;

extern routine verifierMemesDimensions ?@luint dim ?@luint dimensionDroite ;

extern routine verifierDimensionUn ?@luint inBitSize ?@location inErrorLocation ;

#-------------------------------------------------------------------*

extern routine generate_code
  ??@typeTableFormules inTableFormules
  ??@typeListeCalculs inListeCalculs
  ??@typeDomainMap inDomainMap
;

#-------------------------------------------------------------------*

end semantics ;
