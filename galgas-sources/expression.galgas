#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#    AST                                                                                                                
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

abstract class @expression {
}

#·······················································································································

class @varInExpression : @expression {
  @lstring mVarName
}

#·······················································································································

class @varBitInExpression : @expression {
  @lstring mVarName
  @luint mVarBit
}

#·······················································································································

class @andExpression, @orExpression, @xorExpression, @equalExpression, @notEqualExpression : @expression {
  @expression mLeftExpression
  @expression mRightExpression
}

#·······················································································································

class @complementExpression : @expression {
  @expression mExpression
}

#·······················································································································

class @trueExpression, @falseExpression : @expression {
}

#·······················································································································

class @formulaInExpression : @expression {
  @lstring mFormulaName
  @lstringlist mParameterList
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#    SYNTAX                                                                                                             
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension kerbdd_syntax {

#·······················································································································

rule <expression> !@expression outExpression {
  <comparison> ?outExpression
  select
  or
    $==$
    <comparison> ?let @expression rightExpression
    outExpression = @equalExpression.new {!outExpression !rightExpression}
  or
    $!=$
    <comparison> ?let @expression rightExpression
    outExpression = @notEqualExpression.new {!outExpression !rightExpression}
  end
}

#·······················································································································

rule <comparison> !@expression outExpression {
  <term> ?outExpression
  repeat
  while
    $|$
    <term> ?let @expression rightExpression
    outExpression = @orExpression.new {!outExpression !rightExpression}
  while
    $^$
    <term> ?let @expression rightExpression
    outExpression = @xorExpression.new {!outExpression !rightExpression}
  end
}

#·······················································································································

rule <term> !@expression outExpression {
  <factor> ?outExpression
  repeat
  while
    $&$
    <factor> ?let @expression rightExpression
    outExpression = @andExpression.new {!outExpression !rightExpression}
  end
}

#·······················································································································

rule <factor> !@expression outExpression {
  $identifier$ ?let varName
  select
    outExpression = @varInExpression.new {!varName}
  or
    $.$
    $integer$ ?let varBit
    outExpression = @varBitInExpression.new {!varName !varBit}
  end
}

#·······················································································································

rule <factor> !@expression outExpression {
  $($
  <expression> ?outExpression
  $)$
}

#·······················································································································

rule <factor> !@expression outExpression {
  $~$
  <factor> ?let expression
  outExpression = @complementExpression.new {!expression}
}

#·······················································································································

rule <factor> !@expression outExpression {
  $true$
  outExpression = @trueExpression.new
}

#·······················································································································

rule <factor> !@expression outExpression {
  $false$
  outExpression = @falseExpression.new
}

#·······················································································································

rule <factor> !@expression outExpression {
  $formula$ ?let formulaName
  @lstringlist parameterList = {}
  $($
  repeat
    $identifier$ ?let parameterName
    parameterList += !parameterName
  while
    $,$
  end
  $)$
  outExpression = @formulaInExpression.new {!formulaName !parameterList}
}

#·······················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#    ANALYZE EXPRESSION                                                                                                 
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

abstract getter @expression computeExpression
  ?let @varMap inVarMap
  ?let @computedFormulaMap inComputedFormulaMap
  -> @binaryset outResult

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @varInExpression computeExpression
  ?let @varMap inVarMap
  ?let @computedFormulaMap unused inComputedFormulaMap
  -> @binaryset outResult
{
  [inVarMap searchKey !mVarName ?let idx ?let bitCount]
  if bitCount != 1 then
    error mVarName : "variable is not boolean; use {...} or dot notation"
  end
  outResult = @binaryset.binarySetWithBit {!idx}
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @varBitInExpression computeExpression
  ?let @varMap inVarMap
  ?let @computedFormulaMap unused inComputedFormulaMap
  -> @binaryset outResult
{
  [inVarMap searchKey !mVarName ?let idx ?let bitCount]
  if bitCount <= mVarBit.uint then
    error mVarBit : "bit index should be < " + bitCount
  end
  outResult = @binaryset.binarySetWithBit {!idx + mVarBit.uint}
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @andExpression computeExpression
  ?let @varMap inVarMap
  ?let @computedFormulaMap inComputedFormulaMap
  -> @binaryset outResult
{
  let left  = [mLeftExpression  computeExpression !inVarMap !inComputedFormulaMap]
  let right = [mRightExpression computeExpression !inVarMap !inComputedFormulaMap]
  outResult = left & right
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @orExpression computeExpression
  ?let @varMap inVarMap
  ?let @computedFormulaMap inComputedFormulaMap
  -> @binaryset outResult
{
  let left  = [mLeftExpression  computeExpression !inVarMap !inComputedFormulaMap]
  let right = [mRightExpression computeExpression !inVarMap !inComputedFormulaMap]
  outResult = left | right
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @xorExpression computeExpression
  ?let @varMap inVarMap
  ?let @computedFormulaMap inComputedFormulaMap
  -> @binaryset outResult
{
  let left  = [mLeftExpression  computeExpression !inVarMap !inComputedFormulaMap]
  let right = [mRightExpression computeExpression !inVarMap !inComputedFormulaMap]
  outResult = left ^ right
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @equalExpression computeExpression
  ?let @varMap inVarMap
  ?let @computedFormulaMap inComputedFormulaMap
  -> @binaryset outResult
{
  let left  = [mLeftExpression  computeExpression !inVarMap !inComputedFormulaMap]
  let right = [mRightExpression computeExpression !inVarMap !inComputedFormulaMap]
  outResult = ~(left ^ right)
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @notEqualExpression computeExpression
  ?let @varMap inVarMap
  ?let @computedFormulaMap inComputedFormulaMap
  -> @binaryset outResult
{
  let left  = [mLeftExpression  computeExpression !inVarMap !inComputedFormulaMap]
  let right = [mRightExpression computeExpression !inVarMap !inComputedFormulaMap]
  outResult = left ^ right
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @complementExpression computeExpression
  ?let @varMap inVarMap
  ?let @computedFormulaMap inComputedFormulaMap
  -> @binaryset outResult
{
  outResult = ~ [mExpression  computeExpression !inVarMap !inComputedFormulaMap]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @trueExpression computeExpression
  ?let @varMap unused inVarMap
  ?let @computedFormulaMap unused inComputedFormulaMap
  -> @binaryset outResult
{
  outResult = @binaryset.fullBinarySet
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @falseExpression computeExpression
  ?let @varMap unused inVarMap
  ?let @computedFormulaMap unused inComputedFormulaMap
  -> @binaryset outResult
{
  outResult = @binaryset.emptyBinarySet
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @formulaInExpression computeExpression
  ?let @varMap inVarMap
  ?let @computedFormulaMap unused inComputedFormulaMap
  -> @binaryset outResult
{
  outResult = @binaryset.emptyBinarySet
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
