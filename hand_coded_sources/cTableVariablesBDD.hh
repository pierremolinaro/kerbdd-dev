//----------------------------------------------------------------------------*//                                                                            *//                        Table 'cTableVariablesBDD'                          *//                                                                            *//----------------------------------------------------------------------------*#ifndef IMPLEMENTATION_TABLE_VARIABLES_BDD_DEFINIE#define IMPLEMENTATION_TABLE_VARIABLES_BDD_DEFINIE//----------------------------------------------------------------------------*#include "cTableVariablesBDD.h"//----------------------------------------------------------------------------*template <class INFO, class CLEF>cElementTableVariablesBDD <INFO, CLEF>::cElementTableVariablesBDD (const INFO & info,                           const CLEF & clef,                           const sint32 numeroElement) {  mEntryIndex = numeroElement ;  mNextItem = NULL ;  champPtrVersInf = NULL ;  champPtrVersSup = NULL ;  mKey = clef ;  mInfo = info ;}//----------------------------------------------------------------------------*template <class INFO, class CLEF> cElementTableVariablesBDD <INFO, CLEF>::~cElementTableVariablesBDD (void) {  macroMyDelete (champPtrVersInf, element_type) ;  macroMyDelete (champPtrVersSup, element_type) ;}//----------------------------------------------------------------------------*template <class INFO, class CLEF>cTableVariablesBDD <INFO, CLEF>::cTableVariablesBDD (void) {  mRoot = NULL ;  mFirstItem = NULL ;  mLastItem = NULL ;  mListLength = 0 ;  mBDDbitsCount = 0 ;  mReferenceCountPtr = NULL ;}//----------------------------------------------------------------------------*template <class INFO, class CLEF>cTableVariablesBDD <INFO, CLEF>::~cTableVariablesBDD (void) {  destroy () ;}//---------------------------------------------------------------------------*//                                                                           *//        Constructor from empty                                             *//                                                                           *//---------------------------------------------------------------------------*template <class INFO, class KEY>cTableVariablesBDD <INFO, KEY> cTableVariablesBDD <INFO, KEY>::constructor_empty (void) {  cTableVariablesBDD <INFO, KEY> bdd ;  bdd.mRoot = (element_type *) NULL ;  bdd.mFirstItem = (element_type *) NULL ;  bdd.mLastItem = (element_type *) NULL ;  bdd.mListLength = 0 ;  bdd.mReferenceCountPtr = (sint32 *) NULL ;  macroMyNew (bdd.mReferenceCountPtr, sint32 (1)) ;  return bdd ;}//---------------------------------------------------------------------------*template <class INFO, class KEY>void cTableVariablesBDD <INFO, KEY>::drop_operation (void) {  mFirstItem = (element_type *) NULL ;  mLastItem = (element_type *) NULL ;  mListLength = 0 ;  if (mReferenceCountPtr != NULL) {    macroValidPointer (mReferenceCountPtr) ;    if ((*mReferenceCountPtr) == 1) {      macroMyDelete (mRoot, element_type) ;      macroMyDelete (mReferenceCountPtr, sint32) ;    }else{      mRoot = (element_type *) NULL ;      (*mReferenceCountPtr) -- ;      mReferenceCountPtr = (sint32 *) NULL ;    }  }}//----------------------------------------------------------------------------*template <class INFO, class CLEF>cTableVariablesBDD <INFO, CLEF>::cTableVariablesBDD (const cTableVariablesBDD <INFO, CLEF> & inSource) {  mRoot = NULL ;  mFirstItem = NULL ;  mLastItem = NULL ;  mListLength = 0 ;  mBDDbitsCount = 0 ;  mReferenceCountPtr = NULL ;  *this = inSource ;}//----------------------------------------------------------------------------*template <class INFO, class CLEF>void cTableVariablesBDD <INFO, CLEF>::operator = (const cTableVariablesBDD <INFO, CLEF> & inSource) {  if (this != & inSource) {    destroy () ;    mRoot = inSource.mRoot ;    mFirstItem = inSource.mFirstItem ;    mLastItem = inSource.mLastItem ;    mListLength = inSource.mListLength ;    mBDDbitsCount = inSource.mBDDbitsCount ;    mReferenceCountPtr = inSource.mReferenceCountPtr ;    if (mReferenceCountPtr != NULL) {      macroValidPointer (mReferenceCountPtr) ;      (*mReferenceCountPtr) ++ ;    }  }}//----------------------------------------------------------------------------*template <class INFO, class CLEF>void cTableVariablesBDD <INFO, CLEF>::destroy (void) {  mFirstItem = NULL ;  mLastItem = NULL ;  mListLength = 0 ;  mBDDbitsCount = 0 ;  if (mReferenceCountPtr != NULL) {    macroValidPointer (mReferenceCountPtr) ;    if ((*mReferenceCountPtr) == 1) {      macroMyDelete (mRoot, element_type) ;      macroMyDelete (mReferenceCountPtr, sint32) ;    }else{      mRoot = NULL ;      (*mReferenceCountPtr) -- ;      mReferenceCountPtr = NULL ;    }  }}//----------------------------------------------------------------------------*template <class INFO, class CLEF>void cTableVariablesBDD <INFO, CLEF>::insulateMap (void) {//--- Si la table est référencée plusieurs fois, la dupliquer  if (mReferenceCountPtr != NULL) {    macroValidPointer (mReferenceCountPtr) ;    if ((*mReferenceCountPtr) > 1) {      (*mReferenceCountPtr) -- ;      mReferenceCountPtr = NULL ;      macroMyNew (mReferenceCountPtr, sint32 (1)) ;      element_type * p = mFirstItem ;      mLastItem = NULL ;      mFirstItem = NULL ;      mRoot = NULL ;      mListLength = 0 ;      mBDDbitsCount = 0 ;      while (p != NULL) {        macroValidPointer (p) ;        insererInterne (p->mInfo, p->mKey, mRoot) ;        p = p->getNextItem () ;      }    }  }}//----------------------------------------------------------------------------*template <class INFO, class CLEF>sint32 cTableVariablesBDD <INFO, CLEF>::insertKey (C_lexique & inLexique,        const INFO & info,        const CLEF & clef,        const GGS_location & positionErreur,        const char * messageErreurInsertion) {  sint32 indiceAllocationBDD = -1 ;  if (isBuilt ()) {  //--- Si la table est référencée plusieurs fois, la dupliquer    insulateMap () ;  //--- Réaliser l'insertion    indiceAllocationBDD = insererInterne (info, clef, mRoot) ;  //--- Erreur d'insertion : la clef existe déjà    if (indiceAllocationBDD < 0) {      positionErreur.semanticError (inLexique, messageErreurInsertion) ;    }  }  return indiceAllocationBDD ;}//----------------------------------------------------------------------------*template <class INFO, class CLEF>sint32 cTableVariablesBDD <INFO, CLEF>::insererInterne (const INFO & info,                const CLEF & clef,                element_type * & racine) {  sint32 indiceAllocationBDD = -1 ;  if (racine == NULL) {    macroMyNew (racine, element_type (info, clef, mListLength)) ;    if (mLastItem == NULL) {      mFirstItem = racine ;    }else{      macroValidPointer (mLastItem) ;      mLastItem->mNextItem = racine ;    }    mLastItem = racine ;    racine->mInfo.mVariableDescriptor ()->allocateBDDvariables (mBDDbitsCount) ;    indiceAllocationBDD = mListLength ;    mListLength ++ ;  }else{    macroValidPointer (racine) ;    const sint32 comparaison = racine->mKey.compareString (clef) ;    if (comparaison > 0) {      indiceAllocationBDD = insererInterne (info, clef, racine->champPtrVersInf) ;    }else if (comparaison < 0) {      indiceAllocationBDD = insererInterne (info, clef, racine->champPtrVersSup) ;    }else{      indiceAllocationBDD = -1 ;    }  }  return indiceAllocationBDD ;}//----------------------------------------------------------------------------*template <class INFO, class CLEF>GGS_bool cTableVariablesBDD <INFO, CLEF>::reader_hasKey (const CLEF & clef) {  bool trouve = false ;  if (isBuilt () && clef.isBuilt ()) {    element_type * element = mRoot ;    while ((element != NULL) && ! trouve) {      macroValidPointer (element) ;      const sint32 comparaison = element->mKey.compareString (clef) ;      if (comparaison > 0) {        element = element->champPtrVersInf ;      }else if (comparaison < 0) {        element = element->champPtrVersSup ;      }else{        trouve = true ;      }    }  }  return GGS_bool (true, trouve) ;}//----------------------------------------------------------------------------*template <class INFO, class CLEF>cElementTableVariablesBDD <INFO, CLEF> * cTableVariablesBDD <INFO, CLEF>::searchKey (C_lexique & inLexique,           const CLEF & clef,           const GGS_location & positionErreur,           const char * messageErreurRecherche) {  element_type * resultat = (element_type *) NULL ;  if (isBuilt () && clef.isBuilt ()) {    resultat = mRoot ;    bool trouve = false ;    while ((resultat != NULL) && ! trouve) {      macroValidPointer (resultat) ;      const sint32 comparaison = resultat->mKey.compareString (clef) ;      if (comparaison > 0) {        resultat = resultat->champPtrVersInf ;      }else if (comparaison < 0) {        resultat = resultat->champPtrVersSup ;      }else{        trouve = true ;      }    }    if (resultat == NULL) {      positionErreur.semanticError (inLexique, messageErreurRecherche) ;    }else{      macroValidPointer (resultat) ;    }  }  return resultat ;}//----------------------------------------------------------------------------*#endif