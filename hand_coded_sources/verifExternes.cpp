//---------------------------------------------------------------------*//                                                                     *//        VŽrification sŽmantiques complŽmentaires                     *//                                                                     *//---------------------------------------------------------------------*//                                                                     *//         Versions successives :                                      *//                                                                     *//---------------------------------------------------------------------*//                                                                     *//         Ë propos de l'auteur...                                     *//                                                                     *//     Pierre Molinaro                                                 *//     IRCyN (Institut de Recherche en CybernŽtique de Nantes)         *//     ƒcole Centrale de Nantes                                        *//     BP 92101                                                        *//     44321 Nantes Cedex 3                                            *//                                                                     *// Adresse Žlectronique : molinaro@ircyn.ec-nantes.fr                  *//                                                                     *//---------------------------------------------------------------------*#include "syntaxeBDD.h"//---------------------------------------------------------------------*voidgetHighBound (C_Lexique & inLexique,              const GGS_luint & inPowerOfTwo,              GGS_luint & outResult) {  if (inPowerOfTwo.getValue () == 0) {    inPowerOfTwo.signalSemanticError (inLexique, "the dimension must be >0") ;  }  outResult.defineAttribute ((1UL << inPowerOfTwo.getValue ()) - 1UL, inLexique) ;}//---------------------------------------------------------------------*voidverifyBoundsAndComputeDimension (C_Lexique & inLexique,                                 const GGS_luint & inLowBound,                                 const GGS_luint & inHighBound,                                 GGS_luint & outDimension) {  if (inLowBound.getValue () >= inHighBound.getValue ()) {    inHighBound.signalSemanticError (inLexique, "the high bound is lower or equal to the low bound") ;  }  unsigned long bitCount = 0 ;  unsigned long high = inHighBound.getValue () ;  while (high != 0) {    high >>= 1 ;    bitCount ++ ;  }  outDimension.defineAttribute (bitCount, inLexique) ;}//---------------------------------------------------------------------*voidverifierDimensionUn (C_Lexique & inLexique,                     GGS_luint valeur,                     GGS_location inErrorLocation) {  if (valeur.isBuilt () && inErrorLocation.isBuilt () && (valeur.getValue () != 1)) {    inErrorLocation.signalSemanticError (inLexique, "This variable is not a boolean") ;  }}//---------------------------------------------------------------------*voidverifierDimensionValeurCorrecte (C_Lexique & inLexique,                                 GGS_luint dimension,                                 GGS_luint valeur) {  if (valeur.isBuilt () && dimension.isBuilt ()) {  //--- Valeur max    const unsigned long dim = dimension.getValue () ;    unsigned long valeurMax = 1 ;    for (unsigned short i=1 ; i <= dim ; i++) {      valeurMax <<= 1 ;    }    if (valeur.getValue () >= valeurMax) {      C_String erreur ;      erreur << "la valeur maximum est " ;      erreur << (valeurMax - 1) ;      valeur.signalSemanticError (inLexique, erreur) ;    }  }}//---------------------------------------------------------------------*voidverifierDimensionExpliciteCorrecte (C_Lexique & inLexique,                                     GGS_luint numeroVar, // indice BDD de la variable                                    GGS_luint dim, // dimension de la variable                                    GGS_luint & indiceBDD, // dŽcalage appel                                    GGS_luint dimension) { // dimension appel  if (numeroVar.isBuilt () && dim.isBuilt () &&      indiceBDD.isBuilt () && dimension.isBuilt ()){  //--- Il faut vŽrifier :  //       indiceBDD < dim  //       dimension >= 1 ;  //       (indiceBDD + dimension - 1) < dim    const unsigned long valeurNumeroVar = numeroVar.getValue () ;    const unsigned long valeurDim = dim.getValue () ;    const unsigned long valeurIndiceBDD = indiceBDD.getValue () ;    const unsigned long valeurDimension = dimension.getValue () ;    if (valeurIndiceBDD >= valeurDim) {      indiceBDD.signalSemanticError (inLexique, "l'indice est >= ˆ la dimension de la variable") ;    }else if (valeurDimension < 1) {      dimension.signalSemanticError (inLexique, "la dimension doit tre >= 0") ;    }else if ((valeurIndiceBDD + valeurDimension - 1) >= valeurDim) {      C_String erreur ;      erreur << "l'indice doit tre <= " ;      erreur << (valeurDim - valeurDimension) ;      indiceBDD.signalSemanticError (inLexique, erreur) ;        }  //--- Il faut recalculer  //        indiceBDD += numeroVar ;    indiceBDD.setUlongValue (indiceBDD.getValue () + valeurNumeroVar) ;  }}//---------------------------------------------------------------------*voidverifierMemesDimensions (C_Lexique & inLexique,                          GGS_luint dimensionGauche,                         GGS_luint dimensionDroite) {  if (dimensionGauche.isBuilt () && dimensionDroite.isBuilt ()) {    if (dimensionGauche.getValue () != dimensionDroite.getValue ()) {      C_String erreur ;      erreur << "la dimension de la variable droite ("             << dimensionDroite.getValue ()             << ") est diffŽrente de celle de la variable gauche ("             << dimensionGauche.getValue ()             << ")" ;      dimensionDroite.signalSemanticError (inLexique, erreur) ;    }    }}//---------------------------------------------------------------------*