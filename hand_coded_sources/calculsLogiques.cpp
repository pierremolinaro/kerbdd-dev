//----------------------------------------------------------------------------*#include "programmeBDD.h"#include "generic_arraies/TC_unique_dyn_array.h"#include "time/C_timer.h"#include "bdd/C_display_bdd.h"//----------------------------------------------------------------------------*#ifdef SUN_UNIX  #include <time.h>#endif//----------------------------------------------------------------------------*#include <limits.h>//----------------------------------------------------------------------------*void programmeBDD::beforeParsing_ (void) {  aTableFormules = GGS_typeTableFormules::constructor_empty () ;  aListeFormules = GGS_typeListeCalculs::constructor_empty () ;  mDomainMap = GGS_typeDomainMap::constructor_empty () ;}//----------------------------------------------------------------------------*void programmeBDD::afterParsing_ (void) {//--- Initial cache and map sizes  printf ("Initial size of BDD àunique table: %lu; initial size of ITE àcache: %lu; initial size of AND àcache: %lu.\n",          C_bdd::getHashMapEntriesCount (), C_bdd::getITEcacheEntriesCount (), C_bdd::getANDcacheEntriesCount ()) ;  switch (C_bdd::getComputingMode ()) {  case C_bdd::ITE_COMPUTED_FROM_AND :    printf ("ITE is computed from AND.\n\n") ;    break ;  case C_bdd::AND_COMPUTED_FROM_ITE :    printf ("AND is computed from ITE.\n\n") ;    break ;  case C_bdd::ITE_and_AND_ARE_INDEPENDANT :    printf ("AND and ITE are computed independantly.\n\n") ;    break ;  }    fflush (stdout) ;//--- Tableau des valeurs des formules  TC_unique_dyn_array <C_bdd> tabValeurFormules (aListeFormules.getCount () COMMA_HERE) ;//--- Boucler sur les formules à calculer  GGS_typeListeCalculs::element_type * courant = aListeFormules.getFirstItem () ;  while (courant != NULL) {    macroValidPointer (courant) ;    cPtr_typeCalcul * calcul = courant->aCalcul () ;  //--- Effectuer le calcul   calcul->executerCalcul (tabValeurFormules) ;   fflush (stdout) ;   courant = courant->getNextItem () ; }}//----------------------------------------------------------------------------*void cPtr_typeAfficherBilan::executerCalcul (TC_unique_dyn_array <C_bdd> & /*tabValeurFormules */) {  C_bdd::printBDDpackageOperationsSummary (stdout) ;}//----------------------------------------------------------------------------*void cPtr_typeDimensionnerTable::executerCalcul (TC_unique_dyn_array <C_bdd> & /*tabValeurFormules */) {  C_timer duree ;  C_bdd::setHashMapSize ((uint16) aDimensionTable.getValue ()) ;  duree.stopTimer () ;  printf ("map %lu: BDD àunique table resized to %lu (done in ",          aDimensionTable.getValue (), C_bdd::getHashMapEntriesCount ()) ;  duree.printTimer (stdout) ;  printf (").\n\n") ;   fflush (stdout) ; }//----------------------------------------------------------------------------*void cPtr_typeDimensionnerANDCache::executerCalcul (TC_unique_dyn_array <C_bdd> & /*tabValeurFormules */) {  C_timer duree ;  C_bdd::setANDcacheSize (aDimensionCache.getValue ()) ;  duree.stopTimer () ;  printf ("and_cache %lu: AND àcache resized to %lu (done in ",          aDimensionCache.getValue (), C_bdd::getANDcacheEntriesCount ()) ;  duree.printTimer (stdout) ;  printf (").\n\n") ;    fflush (stdout) ; }//----------------------------------------------------------------------------*void cPtr_typeDimensionnerITECache::executerCalcul (TC_unique_dyn_array <C_bdd> & /*tabValeurFormules */) {  C_timer duree ;  C_bdd::setITEcacheSize (aDimensionCache.getValue ()) ;  duree.stopTimer () ;  printf ("ite_cache %lu: ITE àcache resized to %lu (done in ",          aDimensionCache.getValue (), C_bdd::getITEcacheEntriesCount ()) ;  duree.printTimer (stdout) ;  printf (").\n\n") ;    fflush (stdout) ; }//----------------------------------------------------------------------------*void cPtr_typeUse_AND::executerCalcul (TC_unique_dyn_array <C_bdd> & /*tabValeurFormules */) {  C_bdd::setComputingMode (C_bdd::ITE_COMPUTED_FROM_AND) ;  printf ("use_and: ITE àis now computed from AND.\n\n") ;  fflush (stdout) ; }//----------------------------------------------------------------------------*void cPtr_typeUse_ITE::executerCalcul (TC_unique_dyn_array <C_bdd> & /*tabValeurFormules */) {  C_bdd::setComputingMode (C_bdd::AND_COMPUTED_FROM_ITE) ;  printf ("use_ite: AND àis now computed from ITE.\n\n") ;  fflush (stdout) ; }//----------------------------------------------------------------------------*void cPtr_typeUse_AND_ITE::executerCalcul (TC_unique_dyn_array <C_bdd> & /*tabValeurFormules */) {  C_bdd::setComputingMode (C_bdd::ITE_and_AND_ARE_INDEPENDANT) ;  printf ("use_and_ite: AND àand ITE are now computed independantly.\n\n") ;  fflush (stdout) ; }//----------------------------------------------------------------------------*static void construireTableauDesNoms (GGS_typeTableVariablesBool & tableDesVariablesBooleennes,                                      C_display_bdd & tableauDesNomsVariablesBooleennes) {//--- Compute variables count  long BDDvariablesCount = 0 ;  GGS_typeTableVariablesBool::element_type * pb = tableDesVariablesBooleennes.getFirstItem () ;  while (pb != NULL) {    macroValidPointer (pb) ;    BDDvariablesCount += pb->mInfo.mVariableDescriptor ()->getBDDvariablesCount () ;    pb = pb->getNextItem () ;  }  tableauDesNomsVariablesBooleennes.allouer ((uint16) BDDvariablesCount) ;  pb = tableDesVariablesBooleennes.getFirstItem () ;  uint32 index = 0 ;  while (pb != NULL) {    macroValidPointer (pb) ;    pb->mInfo.mVariableDescriptor ()->defineBDDvariableNames (tableauDesNomsVariablesBooleennes,                                                                  pb->mKey, index) ;    pb = pb->getNextItem () ;  }}//----------------------------------------------------------------------------*static C_bdd evaluerContraintesIntervalles (GGS_typeTableVariablesBool & tableVariablesBool) {  C_bdd contrainte ; contrainte.setToTrue () ;  GGS_typeTableVariablesBool::element_type * ptr = tableVariablesBool.getFirstItem () ;  while (ptr != NULL) {    macroValidPointer (ptr) ;    ptr->mInfo.mVariableDescriptor ()->computeBoundsConstraint (contrainte) ;    ptr = ptr->getNextItem () ;  }  return contrainte ;}//----------------------------------------------------------------------------*void cPtr_typeCalculSimple::executerCalcul (TC_unique_dyn_array <C_bdd> & tabValeurFormules) {  C_timer duree ;  const sint32 numeroFormule = (long) aNumeroFormule.getValue () ;//--- Effectuer les éventuels changements de variable  aFormule()->executerLesChangementsDeVariable (tabValeurFormules, numeroFormule) ;//--- Évaluer les contraintes d'intervalle des variables  const C_bdd contrainte = evaluerContraintesIntervalles (aTableVariablesBool) ;//--- Évaluation  const C_bdd resultat = contrainte & aFormule ()->evaluerFormule (tabValeurFormules (numeroFormule COMMA_HERE)) ;  tabValeurFormules (numeroFormule COMMA_HERE) = resultat ;  duree.stopTimer () ;  if (aTableVariablesBool.mBDDbitsCount == 0) {    printf ("Predicate '%s', computed in ", aNomFormule.getStringPtr ()) ;    duree.printTimer (stdout) ;    printf (", is %s\n", resultat.isFalse () ? "false" : "true") ;  }else{  //--- Print Result    printf ("Formula '%s', computed in ", aNomFormule.getStringPtr ()) ;    duree.printTimer (stdout) ;    const uint64 nValeurs = resultat.getBDDvaluesCount (aTableVariablesBool.mBDDbitsCount) ;    const uint32 nElements = resultat.getBDDnodesCount () ;    printf (", has %llu value%s coded by %lu node%s\n", nValeurs,            (nValeurs < 2) ? "" : "s", nElements, (nElements < 2) ? "" : "s") ;  //--- Print values ?    C_display_bdd tableauDesNomsVariablesBooleennes (0) ;    const uint32 affichage = aAfficher.getValue () ;    if (affichage > 0) { //--- Construire le tableau des noms      construireTableauDesNoms (aTableVariablesBool, tableauDesNomsVariablesBooleennes) ;    }  //--- Print BDD values ?    if (affichage > 0) {       resultat.printBDD (stdout, aTableVariablesBool.mBDDbitsCount, tableauDesNomsVariablesBooleennes) ;    }  //--- Print BDD nodes ?    if (affichage > 1) {       resultat.printBDDnodes (stdout, tableauDesNomsVariablesBooleennes) ;    }  //--- Check BDD ?      if (affichage > 2) {       sint32 nErreurs = 0 ;      for (uint64 i=0 ; i<nValeurs ; i++) {        C_bdd v = resultat.getNthBDD (i, aTableVariablesBool.mBDDbitsCount) ;        const uint64 rang = resultat.getBDDrange (v, aTableVariablesBool.mBDDbitsCount) ;        if (rang != i) {          printf (" *** BDD RANGE ERROR %llu (RECOMPUTED VALUE: %llu) ***\n", i, rang) ;          nErreurs ++ ;        }      }      if (nErreurs == 0) {        printf ("No error raised during checking.\n") ;      }    }  }  printf ("\n") ;}  //----------------------------------------------------------------------------*void cPtr_typeCalculIteratif::executerCalcul (TC_unique_dyn_array <C_bdd> & tabValeurFormules) {  C_timer duree ;  const sint32 numeroFormule = (long) aNumeroFormule.getValue () ;//--- Valeur initiale  if (aSigne.getValue ()) {    tabValeurFormules (numeroFormule COMMA_HERE) = C_bdd () ; // vide  }else{    tabValeurFormules (numeroFormule COMMA_HERE) = ~ C_bdd () ; // plein  }//--- Effectuer les éventuels changements de variable  aFormule()->executerLesChangementsDeVariable (tabValeurFormules, numeroFormule) ;//--- Évaluer les contraintes d'intervalle des variables  const C_bdd contrainte = evaluerContraintesIntervalles (aTableVariablesBool) ;//--- Évaluation initiale  C_bdd resultat = contrainte & aFormule ()->evaluerFormule (tabValeurFormules (numeroFormule COMMA_HERE)) ;  long nIterations = 1 ;//--- Itérer  do{    tabValeurFormules (numeroFormule COMMA_HERE) = resultat ;    resultat = contrainte & aFormule()->evaluerFormule (resultat) ;    nIterations ++ ;  }while (! resultat.isEqualToBDD (tabValeurFormules (numeroFormule COMMA_HERE))) ;  duree.stopTimer () ;  if (aTableVariablesBool.mBDDbitsCount == 0) {    printf ("Predicate '%s', computed in ", aNomFormule.getStringPtr ()) ;    duree.printTimer (stdout) ;    printf (", is %s\n", resultat.isFalse () ? "false" : "true") ;  }else{    printf ("Formula '%s', computed in ", aNomFormule.getStringPtr ()) ;    duree.printTimer (stdout) ;    printf (" with %ld iterations", nIterations) ;    const uint64 nValeurs = resultat.getBDDvaluesCount (aTableVariablesBool.mBDDbitsCount) ;    const uint32 nElements = resultat.getBDDnodesCount () ;    printf (", has %llu value%s coded by %lu node%s\n", nValeurs,            (nValeurs < 2) ? "" : "s", nElements, (nElements < 2) ? "" : "s") ;  //--- Imprimer la composition du resultat    C_display_bdd tableauDesNomsVariablesBooleennes (0) ;    const uint32 affichage = aAfficher.getValue () ;    if (affichage > 0) { //--- Construire le tableau des noms      construireTableauDesNoms (aTableVariablesBool, tableauDesNomsVariablesBooleennes) ;    }  //--- Imprimer la composition du resultat ?    if (affichage > 0) {       resultat.printBDD (stdout, aTableVariablesBool.mBDDbitsCount, tableauDesNomsVariablesBooleennes) ;    }  //--- Ecrire la composition du BDD ?    if (affichage > 1) {       resultat.printBDDnodes (stdout, tableauDesNomsVariablesBooleennes) ;    }  //--- Vérifier le BDD ?      if (affichage > 2) {       long nErreurs = 0 ;      for (uint64 i=0 ; i<nValeurs ; i++) {        C_bdd v = resultat.getNthBDD (i, aTableVariablesBool.mBDDbitsCount) ;        const uint64 rang = resultat.getBDDrange (v, aTableVariablesBool.mBDDbitsCount) ;        if (rang != i) {          printf (" *** BDD RANGE ERROR %llu (RECOMPUTED VALUE: %llu) ***\n", i, rang) ;          nErreurs ++ ;        }      }      if (nErreurs == 0) {        printf ("No error raised during checking.\n") ;      }    }  }  printf ("\n") ;}//---------------------------------------------------------------------*C_bdd cPtr_typeFormuleVar::evaluerFormule (const C_bdd & /* valeurFormuleCourante */) {  return C_bdd ((uint16) aNumeroVariable.getValue (), true) ;}//---------------------------------------------------------------------*void cPtr_typeFormuleVar::executerLesChangementsDeVariable (TC_unique_dyn_array <C_bdd> & /* tabValeurFormules */,                                  const sint32 /* numeroFormuleCourante */) {}//---------------------------------------------------------------------*C_bdd cPtr_typeFormuleTrue::evaluerFormule (const C_bdd & /* valeurFormuleCourante */) {  return ~C_bdd () ;}//---------------------------------------------------------------------*void cPtr_typeFormuleTrue::executerLesChangementsDeVariable (TC_unique_dyn_array <C_bdd> & /* tabValeurFormules */,                                  const sint32 /* numeroFormuleCourante */) {}//---------------------------------------------------------------------*C_bdd cPtr_typeFormuleFalse::evaluerFormule (const C_bdd & /* valeurFormuleCourante */) {  return C_bdd () ;}//---------------------------------------------------------------------*void cPtr_typeFormuleFalse::executerLesChangementsDeVariable (TC_unique_dyn_array <C_bdd> & /* tabValeurFormules */,                                  const sint32 /* numeroFormuleCourante */) {}//---------------------------------------------------------------------*static voidconstruireTableauChangementVariables (GGS_typeActualArgumentsList & listeArgumentsBooleens,                                      uint16 * & tabChgtBool,                                      uint16 & nombreVariablesBool) {//--- Calculer la taille du tableau des changements de variables  nombreVariablesBool = 0 ;  GGS_typeActualArgumentsList::element_type * p = listeArgumentsBooleens.getFirstItem () ;  while (p != NULL) {    nombreVariablesBool += (uint16) p->mVariableBitSize.getValue () ;    p = p->getNextItem () ;  }//--- Construire le tableau des changements de variables booléennes  tabChgtBool = new uint16 [nombreVariablesBool] ;  p = listeArgumentsBooleens.getFirstItem () ;  size_t i = 0 ;  while (p != NULL) {    macroValidPointer (p) ;    for (uint16 j=0 ; j < p->mVariableBitSize.getValue () ; j++) {      tabChgtBool [i] = (uint16) (p->mVariableIndex.getValue () + j) ;      i ++ ;    }    p = p->getNextItem () ;  }}//---------------------------------------------------------------------*//---------------------------------------------------------------------*C_bdd cPtr_typeFormuleFor::evaluerFormule (const C_bdd & valeurFormuleCourante) {  C_bdd resultat = aFormuleTraduite.mBDD ;  if (aEstFormuleCourante.getValue ()) {  //--- Construire le tableau des changements de variables    uint16 * tabChgtBool = NULL ;    uint16 nombreVariablesBool = 0 ;    construireTableauChangementVariables (aListeArgsBool, tabChgtBool, nombreVariablesBool) ;  //--- Traduire le BDD    resultat = valeurFormuleCourante.substitution (tabChgtBool, nombreVariablesBool) ;    delete [] tabChgtBool ; tabChgtBool = NULL ;  }  return resultat ;}//---------------------------------------------------------------------*void cPtr_typeFormuleFor::executerLesChangementsDeVariable (TC_unique_dyn_array <C_bdd> & tabValeurFormules,                                  const sint32 numeroFormuleCourante) {  aEstFormuleCourante.setValue (aNumeroFormule.getValue () == (uint32) numeroFormuleCourante) ;  if (! aEstFormuleCourante.getValue ()) {  //--- Construire le tableau des changements de variables    uint16 * tabChgtBool = NULL ;    uint16 nombreVariablesBool = 0 ;    construireTableauChangementVariables (aListeArgsBool, tabChgtBool, nombreVariablesBool) ;  //--- Traduire le BDD    aFormuleTraduite.mBDD = tabValeurFormules ((uint16) aNumeroFormule.getValue () COMMA_HERE).substitution (tabChgtBool, nombreVariablesBool) ;    delete [] tabChgtBool ; tabChgtBool = NULL ;  }}//---------------------------------------------------------------------*//---------------------------------------------------------------------*C_bdd cPtr_typeFormuleNon::evaluerFormule (const C_bdd & valeurFormuleCourante) {  return ~ (aOperande ()->evaluerFormule (valeurFormuleCourante)) ;}//---------------------------------------------------------------------*void cPtr_typeFormuleNon::executerLesChangementsDeVariable (TC_unique_dyn_array <C_bdd> & tabValeurFormules,                                  const sint32 numeroFormuleCourante) {  aOperande ()->executerLesChangementsDeVariable (tabValeurFormules, numeroFormuleCourante) ;}//---------------------------------------------------------------------*C_bdd cPtr_typeFormuleEt::evaluerFormule (const C_bdd & valeurFormuleCourante) {  return aOperande1 ()->evaluerFormule (valeurFormuleCourante)              &         aOperande2 ()->evaluerFormule (valeurFormuleCourante) ;}//---------------------------------------------------------------------*void cPtr_typeFormuleEt::executerLesChangementsDeVariable (TC_unique_dyn_array <C_bdd> & tabValeurFormules,                                  const sint32 numeroFormuleCourante) {  aOperande1 ()->executerLesChangementsDeVariable (tabValeurFormules, numeroFormuleCourante) ;  aOperande2 ()->executerLesChangementsDeVariable (tabValeurFormules, numeroFormuleCourante) ;}//---------------------------------------------------------------------*C_bdd cPtr_typeFormuleIte::evaluerFormule (const C_bdd & valeurFormuleCourante) {  return C_bdd::ite (aOperande1 ()->evaluerFormule (valeurFormuleCourante),                    aOperande2 ()->evaluerFormule (valeurFormuleCourante),                    aOperande3 ()->evaluerFormule (valeurFormuleCourante)) ;}//---------------------------------------------------------------------*void cPtr_typeFormuleIte::executerLesChangementsDeVariable (TC_unique_dyn_array <C_bdd> & tabValeurFormules,                                                      const sint32 numeroFormuleCourante) {  aOperande1 ()->executerLesChangementsDeVariable (tabValeurFormules, numeroFormuleCourante) ;  aOperande2 ()->executerLesChangementsDeVariable (tabValeurFormules, numeroFormuleCourante) ;  aOperande3 ()->executerLesChangementsDeVariable (tabValeurFormules, numeroFormuleCourante) ;}//---------------------------------------------------------------------*//---------------------------------------------------------------------*C_bdd cPtr_typeFormuleOu::evaluerFormule (const C_bdd & valeurFormuleCourante) {  return aOperande1 ()->evaluerFormule (valeurFormuleCourante)              |         aOperande2 ()->evaluerFormule (valeurFormuleCourante) ;}//---------------------------------------------------------------------*void cPtr_typeFormuleOu::executerLesChangementsDeVariable (TC_unique_dyn_array <C_bdd> & tabValeurFormules,                                                      const sint32 numeroFormuleCourante) {  aOperande1 ()->executerLesChangementsDeVariable (tabValeurFormules, numeroFormuleCourante) ;  aOperande2 ()->executerLesChangementsDeVariable (tabValeurFormules, numeroFormuleCourante) ;}//---------------------------------------------------------------------*//---------------------------------------------------------------------*C_bdd cPtr_typeFormuleImplique::evaluerFormule (const C_bdd & valeurFormuleCourante) {  return aOperande1 ()->evaluerFormule (valeurFormuleCourante).implies (aOperande2 ()->evaluerFormule (valeurFormuleCourante)) ;}//---------------------------------------------------------------------*void cPtr_typeFormuleImplique::executerLesChangementsDeVariable (TC_unique_dyn_array <C_bdd> & tabValeurFormules,                                  const sint32 numeroFormuleCourante) {  aOperande1 ()->executerLesChangementsDeVariable (tabValeurFormules, numeroFormuleCourante) ;  aOperande2 ()->executerLesChangementsDeVariable (tabValeurFormules, numeroFormuleCourante) ;}//---------------------------------------------------------------------*//---------------------------------------------------------------------*C_bdd cPtr_typeComparaisonFormules::evaluerFormule (const C_bdd & valeurFormuleCourante) {  C_bdd::compareEnum comp = C_bdd::kEqual ;  switch (aComparaison.getValue ()) {  case 1 :    comp = C_bdd::kNonEqual ;    break ;  case 2 :    comp = C_bdd::kLowerOrEqual ;    break ;  case 3 :    comp = C_bdd::kStrictLower ;    break ;  case 4 :    comp = C_bdd::kGreaterOrEqual ;    break ;  case 5 :    comp = C_bdd::kStrictGreater ;    break ;  default :    break ;  }  return aOperande1 ()->evaluerFormule (valeurFormuleCourante)             .compareWithBDD (comp, aOperande2 ()->evaluerFormule (valeurFormuleCourante)) ;}//---------------------------------------------------------------------*void cPtr_typeComparaisonFormules::executerLesChangementsDeVariable (TC_unique_dyn_array <C_bdd> & tabValeurFormules,                                  const sint32 numeroFormuleCourante) {  aOperande1 ()->executerLesChangementsDeVariable (tabValeurFormules, numeroFormuleCourante) ;  aOperande2 ()->executerLesChangementsDeVariable (tabValeurFormules, numeroFormuleCourante) ;}//---------------------------------------------------------------------*//---------------------------------------------------------------------*C_bdd cPtr_typeFormuleExist::evaluerFormule (const C_bdd & valeurFormuleCourante) {  C_bdd resultat = aOperande ()->evaluerFormule (valeurFormuleCourante) & aContraintes.mBDD ;  resultat = resultat.existsOnBitsAfterNumber ((uint16) aListeArgsBooleens.getFirstItem ()->mVariableIndex.getValue ()) ;  return resultat ;}//---------------------------------------------------------------------*void cPtr_typeFormuleExist::executerLesChangementsDeVariable (TC_unique_dyn_array <C_bdd> & tabValeurFormules,                                  const sint32 numeroFormuleCourante) {  aOperande ()->executerLesChangementsDeVariable (tabValeurFormules, numeroFormuleCourante) ;//--- Constraint evaluation  C_bdd constraint = ~ C_bdd () ; // Initially true  GGS_typeFormalArgumentsList::element_type * current = aListeArgsBooleens.getFirstItem () ;  while (current != NULL) {    macroValidPointer (current) ;    const uint32 variableIndex = current->mVariableIndex.getValue () ;    const uint32 variableBitSize = current->mVariableBitSize.getValue () ;    const uint32 lowBound = current->mLowBound.getValue () ;    const uint32 highBound = current->mHighBound.getValue () ;    const bool hasConstraint = (lowBound != 0) || ((highBound + 1) < (1UL << variableBitSize)) ;//    printf ("variableIndex:%lu; variableBitSize:%lu; lowBound:%lu; highBound:%lu hasConstraint:%s\n",//            variableIndex, variableBitSize, lowBound, highBound, hasConstraint ? "yes" : "no") ;    if (hasConstraint) {      constraint &= C_bdd::varCompareConst (variableIndex, variableBitSize, C_bdd::kGreaterOrEqual, lowBound)                  & C_bdd::varCompareConst (variableIndex, variableBitSize, C_bdd::kLowerOrEqual, highBound) ;     }    current = current->getNextItem () ;  }  aContraintes.mBDD = constraint ;}//---------------------------------------------------------------------*//---------------------------------------------------------------------*C_bdd cPtr_typeFormuleComparaisonValeur::evaluerFormule (const C_bdd & /* valeurFormuleCourante */) {  const uint16 premierIndice = (uint16) aIndiceBDD.getValue () ;  const uint16 dimension = (uint16)  aDimension.getValue () ;  const uint32 valeur = aValeur.getValue () ;  C_bdd::compareEnum comp = C_bdd::kEqual ;  switch (aComparaison.getValue ()) {  case 1 :    comp = C_bdd::kNonEqual ;    break ;  case 2 :    comp = C_bdd::kLowerOrEqual ;    break ;  case 3 :    comp = C_bdd::kStrictLower ;    break ;  case 4 :    comp = C_bdd::kGreaterOrEqual ;    break ;  case 5 :    comp = C_bdd::kStrictGreater ;    break ;  default :    break ;  }  return C_bdd::varCompareConst (premierIndice, dimension, comp, valeur) ;}//---------------------------------------------------------------------*void cPtr_typeFormuleComparaisonValeur::executerLesChangementsDeVariable (TC_unique_dyn_array <C_bdd> & /* tabValeurFormules */,                                                         const sint32 /* numeroFormuleCourante */) {}//---------------------------------------------------------------------*C_bdd cPtr_typeFormuleComparaisonVariable::evaluerFormule (const C_bdd & /* valeurFormuleCourante */) {  const uint16 premierIndiceGauche = (uint16) aIndiceBDDgauche.getValue () ;  const uint16 dimension = (uint16) aDimension.getValue () ;  const uint16 premierIndiceDroite = (uint16) aIndiceBDDdroite.getValue () ;  C_bdd::compareEnum comp = C_bdd::kEqual ;  switch (aComparaison.getValue ()) {  case 1 :    comp = C_bdd::kNonEqual ;    break ;  case 2 :    comp = C_bdd::kLowerOrEqual ;    break ;  case 3 :    comp = C_bdd::kStrictLower ;    break ;  case 4 :    comp = C_bdd::kGreaterOrEqual ;    break ;  case 5 :    comp = C_bdd::kStrictGreater ;    break ;  default :    break ;  }  return C_bdd::varCompareVar (premierIndiceGauche, dimension, comp, premierIndiceDroite) ;}//---------------------------------------------------------------------*void cPtr_typeFormuleComparaisonVariable::executerLesChangementsDeVariable (TC_unique_dyn_array <C_bdd> & /* tabValeurFormules */,                                                         const sint32 /* numeroFormuleCourante */) {}//----------------------------------------------------------------------------*//                                                                            *//            Methods of 'cPtr_typeDirectVariable'                            *//                                                                            *//----------------------------------------------------------------------------*void cPtr_typeDirectVariable::allocateBDDvariables (uint16 & ioBDDindex) {  mIndex.setUlongValue (ioBDDindex) ;  ioBDDindex += (uint16) mBitSize.getValue () ;}//----------------------------------------------------------------------------*long cPtr_typeDirectVariable::getBDDvariablesCount (void) const {  return 1 ;}//----------------------------------------------------------------------------*void cPtr_typeDirectVariable::defineBDDvariableNames (C_display_bdd & ioBDDvariableNameArray,                                                      const C_string & inVariableName,                                                      uint32 & ioIndex) {  const uint32 dimension = mBitSize.getValue () ;  ioBDDvariableNameArray.definir (ioIndex, inVariableName.getStringPtr (), (uint16) dimension) ;  ioIndex ++ ;}//----------------------------------------------------------------------------*void cPtr_typeDirectVariable::computeBoundsConstraint (C_bdd & ioConstraint) const {  const uint32 borneInf = mLowBound.getValue () ;  const uint32 borneSup = mHighBound.getValue () ;  const uint16 varIndex = (uint16) mIndex.getValue () ;  const uint16 bitSize = (uint16) mBitSize.getValue () ;  if (borneInf > 0) {    ioConstraint &= C_bdd::varCompareConst (varIndex, bitSize, C_bdd::kGreaterOrEqual, borneInf) ;  }  if (borneSup < ((1UL << bitSize) -1UL)) {    ioConstraint &= C_bdd::varCompareConst (varIndex, bitSize, C_bdd::kLowerOrEqual, borneSup) ;  }}//----------------------------------------------------------------------------*//                                                                            *//            Methods of 'cPtr_typeRecordVariable'                            *//                                                                            *//----------------------------------------------------------------------------*void cPtr_typeRecordVariable::allocateBDDvariables (uint16 & ioBDDindex) {  GGS_typeTableVariablesBool::element_type * p = mMap.getFirstItem () ;  while (p != NULL) {    macroValidPointer (p) ;    p->mInfo.mVariableDescriptor ()->allocateBDDvariables (ioBDDindex) ;    p = p->getNextItem () ;  }}//----------------------------------------------------------------------------*long cPtr_typeRecordVariable::getBDDvariablesCount (void) const {  long variableCount = 0 ;  GGS_typeTableVariablesBool::element_type * p = mMap.getFirstItem () ;  while (p != NULL) {    macroValidPointer (p) ;    variableCount += p->mInfo.mVariableDescriptor ()->getBDDvariablesCount () ;    p = p->getNextItem () ;  }  return variableCount ;}//----------------------------------------------------------------------------*void cPtr_typeRecordVariable::defineBDDvariableNames (C_display_bdd & ioBDDvariableNameArray,                                                      const C_string & inVariableName,                                                      uint32 & ioIndex) {  GGS_typeTableVariablesBool::element_type * p = mMap.getFirstItem () ;  while (p != NULL) {    macroValidPointer (p) ;    C_string variableName ;    variableName << inVariableName << '.' << p->mKey ;    p->mInfo.mVariableDescriptor ()->defineBDDvariableNames (ioBDDvariableNameArray, variableName, ioIndex) ;    p = p->getNextItem () ;  }}//----------------------------------------------------------------------------*void cPtr_typeRecordVariable::computeBoundsConstraint (C_bdd & ioConstraint) const {  GGS_typeTableVariablesBool::element_type * p = mMap.getFirstItem () ;  while (p != NULL) {    macroValidPointer (p) ;    p->mInfo.mVariableDescriptor ()->computeBoundsConstraint (ioConstraint) ;    p = p->getNextItem () ;  }}//----------------------------------------------------------------------------*